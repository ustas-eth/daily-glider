["{\"contract\": \"0x696acc2de564b48682d71d0847b3632f87c9a402\", \"contract_name\": \"Feeless\", \"sol_function\": \"function performFeelessTransaction(\\r\\n        address sender, \\r\\n        address target, \\r\\n        bytes memory data, \\r\\n        uint256 nonce, \\r\\n        bytes memory sig) public payable {\\r\\n        require(address(this) == target, \\\"Feeless: Target should be the extended contract\\\");\\r\\n    \\r\\n        bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\r\\n        bytes32 hash = keccak256(abi.encodePacked(prefix, keccak256(abi.encodePacked(target, data, nonce))));\\r\\n        msgSender = ECRecovery.recover(hash, sig);\\r\\n        require(msgSender == sender, \\\"Feeless: Unexpected sender\\\");\\r\\n        require(nonces[msgSender]++ == nonce, \\\"Feeless: nonce does not comply\\\");\\r\\n        (bool _success, bytes memory _payload) = target.call.value(msg.value)(data);\\r\\n        CallResult memory callResult = CallResult(_success, _payload);\\r\\n        require(callResult.success, \\\"Feeless: Call failed\\\");\\r\\n        msgSender = address(0);\\r\\n    }\"}","{\"contract\": \"0x696acc2de564b48682d71d0847b3632f87c9a402\", \"contract_name\": \"AWG\", \"sol_function\": \"function performFeelessTransaction(\\r\\n        address sender, \\r\\n        address target, \\r\\n        bytes memory data, \\r\\n        uint256 nonce, \\r\\n        bytes memory sig) public payable {\\r\\n        require(address(this) == target, \\\"Feeless: Target should be the extended contract\\\");\\r\\n    \\r\\n        bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\r\\n        bytes32 hash = keccak256(abi.encodePacked(prefix, keccak256(abi.encodePacked(target, data, nonce))));\\r\\n        msgSender = ECRecovery.recover(hash, sig);\\r\\n        require(msgSender == sender, \\\"Feeless: Unexpected sender\\\");\\r\\n        require(nonces[msgSender]++ == nonce, \\\"Feeless: nonce does not comply\\\");\\r\\n        (bool _success, bytes memory _payload) = target.call.value(msg.value)(data);\\r\\n        CallResult memory callResult = CallResult(_success, _payload);\\r\\n        require(callResult.success, \\\"Feeless: Call failed\\\");\\r\\n        msgSender = address(0);\\r\\n    }\"}","{\"contract\": \"0xd747b21fb9120e2f02eb2f070b1f417d22387ea7\", \"contract_name\": \"GovernorUpgradeable\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xd747b21fb9120e2f02eb2f070b1f417d22387ea7\", \"contract_name\": \"GovernorUpgradeable\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0xd747b21fb9120e2f02eb2f070b1f417d22387ea7\", \"contract_name\": \"GovernorCountingSimpleUpgradeable\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xd747b21fb9120e2f02eb2f070b1f417d22387ea7\", \"contract_name\": \"GovernorCountingSimpleUpgradeable\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0xd747b21fb9120e2f02eb2f070b1f417d22387ea7\", \"contract_name\": \"GovernorSettingsUpgradeable\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xd747b21fb9120e2f02eb2f070b1f417d22387ea7\", \"contract_name\": \"GovernorSettingsUpgradeable\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0xd747b21fb9120e2f02eb2f070b1f417d22387ea7\", \"contract_name\": \"GovernorVotesQuorumFractionUpgradeable\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xd747b21fb9120e2f02eb2f070b1f417d22387ea7\", \"contract_name\": \"GovernorVotesQuorumFractionUpgradeable\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0xd747b21fb9120e2f02eb2f070b1f417d22387ea7\", \"contract_name\": \"GovernorVotesUpgradeable\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xd747b21fb9120e2f02eb2f070b1f417d22387ea7\", \"contract_name\": \"GovernorVotesUpgradeable\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0xd747b21fb9120e2f02eb2f070b1f417d22387ea7\", \"contract_name\": \"ShipGovernor\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xd747b21fb9120e2f02eb2f070b1f417d22387ea7\", \"contract_name\": \"ShipGovernor\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0xc2ec72b51fde96823f75811663dbbe3a8ad1b672\", \"contract_name\": \"AvocadoMultisigSelfUpgradeable\", \"sol_function\": \"function _verifySig(\\n        bytes32 digest_,\\n        SignatureParams[] memory signaturesParams_,\\n        bool isNonSequentialNonce_\\n    ) internal view returns (bool isValid_, address[] memory recoveredSigners_) {\\n        // gas measurements:\\n        // cost until the for loop in verify signature is:\\n        // 1 signer 3374 (_getSigners() with only owner is cheaper)\\n        // 2 signers 6473\\n        // every additional allowedSigner (!) + 160 gas (additional SSTORE2 load cost)\\n        // For non-sequential nonce additional cold SLOAD + check cost is ~2200\\n        // dynamic cost for verifying any additional signer 7500\\n        // So formula:\\n        // Avoado signersCount == 1 ? -> 11_000 gas\\n        // Avoado signersCount > 1 ? -> 6400  + allowedSignersCount * 160 + signersLength * 7500\\n        // is non Sequential nonce? + 2200\\n        // is smart contract signer? + buffer amount. A very basic ECDSA verify call like with e.g. MockSigner costs ~9k.\\n        uint256 signaturesLength_ = signaturesParams_.length;\\n\\n        if (\\n            // enough signatures must be submitted to reach quorom of `requiredSigners`\\n            signaturesLength_ < _getRequiredSigners() ||\\n            // for non sequential nonce, if nonce is already used, the signature has already been used and is invalid\\n            (isNonSequentialNonce_ && nonSequentialNonces[digest_] == 1)\\n        ) {\\n            revert AvocadoMultisig__InvalidParams();\\n        }\\n\\n        // fill recovered signers array for use in event emit\\n        recoveredSigners_ = new address[](signaturesLength_);\\n\\n        // get current signers from storage\\n        address[] memory allowedSigners_ = _getSigners(); // includes owner\\n        uint256 allowedSignersLength_ = allowedSigners_.length;\\n        // track last allowed signer index for loop performance improvements\\n        uint256 lastAllowedSignerIndex_ = 0;\\n\\n        bool isContract_ = false; // keeping this variable outside the loop so it is not re-initialized in each loop -> cheaper\\n        bool isAllowedSigner_ = false;\\n        for (uint256 i; i < signaturesLength_; ) {\\n            if (Address.isContract(signaturesParams_[i].signer)) {\\n                recoveredSigners_[i] = signaturesParams_[i].signer;\\n                // set flag that the signer is a contract so we don't have to check again in code below\\n                isContract_ = true;\\n            } else {\\n                // recover signer from signature\\n                recoveredSigners_[i] = ECDSA.recover(digest_, signaturesParams_[i].signature);\\n\\n                if (signaturesParams_[i].signer != recoveredSigners_[i]) {\\n                    // signer does not match recovered signer. Either signer param is wrong or params used to\\n                    // build digest are not the same as for the signature\\n                    revert AvocadoMultisig__InvalidParams();\\n                }\\n            }\\n\\n            // because signers in storage and signers from signatures input params must be ordered ascending,\\n            // the for loop can be optimized each new cycle to start from the position where the last signer\\n            // has been found.\\n            // this also ensures that input params signers must be ordered ascending off-chain\\n            // (which again is used to improve performance and simplifies ensuring unique signers)\\n            for (uint256 j = lastAllowedSignerIndex_; j < allowedSignersLength_; ) {\\n                if (allowedSigners_[j] == recoveredSigners_[i]) {\\n                    isAllowedSigner_ = true;\\n                    unchecked {\\n                        lastAllowedSignerIndex_ = j + 1; // set to j+1 so that next cycle starts at next array position\\n                    }\\n                    break;\\n                }\\n\\n                // could be optimized by checking if allowedSigners_[j] > recoveredSigners_[i]\\n                // and immediately skipping with a `break;` if so. Because that implies that the recoveredSigners_[i]\\n                // can not be present in allowedSigners_ due to ascending sort.\\n                // But that would optimize the failing invalid case and increase cost for the default case where\\n                // the input data is valid -> skip.\\n\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            // validate if signer is allowed\\n            if (!isAllowedSigner_) {\\n                return (false, recoveredSigners_);\\n            } else {\\n                // reset `isAllowedSigner_` for next loop\\n                isAllowedSigner_ = false;\\n            }\\n\\n            if (isContract_) {\\n                // validate as smart contract signature\\n                if (\\n                    IERC1271(signaturesParams_[i].signer).isValidSignature(digest_, signaturesParams_[i].signature) !=\\n                    EIP1271_MAGIC_VALUE\\n                ) {\\n                    // return value is not EIP1271_MAGIC_VALUE -> smart contract returned signature is invalid\\n                    return (false, recoveredSigners_);\\n                }\\n\\n                // reset isContract for next loop (because defined outside of the loop to save gas)\\n                isContract_ = false;\\n            }\\n            // else already everything validated through recovered signer must be an allowed signer etc. in logic above\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return (true, recoveredSigners_);\\n    }\"}","{\"contract\": \"0xc2ec72b51fde96823f75811663dbbe3a8ad1b672\", \"contract_name\": \"AvocadoMultisigProtected\", \"sol_function\": \"function _verifySig(\\n        bytes32 digest_,\\n        SignatureParams[] memory signaturesParams_,\\n        bool isNonSequentialNonce_\\n    ) internal view returns (bool isValid_, address[] memory recoveredSigners_) {\\n        // gas measurements:\\n        // cost until the for loop in verify signature is:\\n        // 1 signer 3374 (_getSigners() with only owner is cheaper)\\n        // 2 signers 6473\\n        // every additional allowedSigner (!) + 160 gas (additional SSTORE2 load cost)\\n        // For non-sequential nonce additional cold SLOAD + check cost is ~2200\\n        // dynamic cost for verifying any additional signer 7500\\n        // So formula:\\n        // Avoado signersCount == 1 ? -> 11_000 gas\\n        // Avoado signersCount > 1 ? -> 6400  + allowedSignersCount * 160 + signersLength * 7500\\n        // is non Sequential nonce? + 2200\\n        // is smart contract signer? + buffer amount. A very basic ECDSA verify call like with e.g. MockSigner costs ~9k.\\n        uint256 signaturesLength_ = signaturesParams_.length;\\n\\n        if (\\n            // enough signatures must be submitted to reach quorom of `requiredSigners`\\n            signaturesLength_ < _getRequiredSigners() ||\\n            // for non sequential nonce, if nonce is already used, the signature has already been used and is invalid\\n            (isNonSequentialNonce_ && nonSequentialNonces[digest_] == 1)\\n        ) {\\n            revert AvocadoMultisig__InvalidParams();\\n        }\\n\\n        // fill recovered signers array for use in event emit\\n        recoveredSigners_ = new address[](signaturesLength_);\\n\\n        // get current signers from storage\\n        address[] memory allowedSigners_ = _getSigners(); // includes owner\\n        uint256 allowedSignersLength_ = allowedSigners_.length;\\n        // track last allowed signer index for loop performance improvements\\n        uint256 lastAllowedSignerIndex_ = 0;\\n\\n        bool isContract_ = false; // keeping this variable outside the loop so it is not re-initialized in each loop -> cheaper\\n        bool isAllowedSigner_ = false;\\n        for (uint256 i; i < signaturesLength_; ) {\\n            if (Address.isContract(signaturesParams_[i].signer)) {\\n                recoveredSigners_[i] = signaturesParams_[i].signer;\\n                // set flag that the signer is a contract so we don't have to check again in code below\\n                isContract_ = true;\\n            } else {\\n                // recover signer from signature\\n                recoveredSigners_[i] = ECDSA.recover(digest_, signaturesParams_[i].signature);\\n\\n                if (signaturesParams_[i].signer != recoveredSigners_[i]) {\\n                    // signer does not match recovered signer. Either signer param is wrong or params used to\\n                    // build digest are not the same as for the signature\\n                    revert AvocadoMultisig__InvalidParams();\\n                }\\n            }\\n\\n            // because signers in storage and signers from signatures input params must be ordered ascending,\\n            // the for loop can be optimized each new cycle to start from the position where the last signer\\n            // has been found.\\n            // this also ensures that input params signers must be ordered ascending off-chain\\n            // (which again is used to improve performance and simplifies ensuring unique signers)\\n            for (uint256 j = lastAllowedSignerIndex_; j < allowedSignersLength_; ) {\\n                if (allowedSigners_[j] == recoveredSigners_[i]) {\\n                    isAllowedSigner_ = true;\\n                    unchecked {\\n                        lastAllowedSignerIndex_ = j + 1; // set to j+1 so that next cycle starts at next array position\\n                    }\\n                    break;\\n                }\\n\\n                // could be optimized by checking if allowedSigners_[j] > recoveredSigners_[i]\\n                // and immediately skipping with a `break;` if so. Because that implies that the recoveredSigners_[i]\\n                // can not be present in allowedSigners_ due to ascending sort.\\n                // But that would optimize the failing invalid case and increase cost for the default case where\\n                // the input data is valid -> skip.\\n\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            // validate if signer is allowed\\n            if (!isAllowedSigner_) {\\n                return (false, recoveredSigners_);\\n            } else {\\n                // reset `isAllowedSigner_` for next loop\\n                isAllowedSigner_ = false;\\n            }\\n\\n            if (isContract_) {\\n                // validate as smart contract signature\\n                if (\\n                    IERC1271(signaturesParams_[i].signer).isValidSignature(digest_, signaturesParams_[i].signature) !=\\n                    EIP1271_MAGIC_VALUE\\n                ) {\\n                    // return value is not EIP1271_MAGIC_VALUE -> smart contract returned signature is invalid\\n                    return (false, recoveredSigners_);\\n                }\\n\\n                // reset isContract for next loop (because defined outside of the loop to save gas)\\n                isContract_ = false;\\n            }\\n            // else already everything validated through recovered signer must be an allowed signer etc. in logic above\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return (true, recoveredSigners_);\\n    }\"}","{\"contract\": \"0xc2ec72b51fde96823f75811663dbbe3a8ad1b672\", \"contract_name\": \"AvocadoMultisigEIP1271\", \"sol_function\": \"function _verifySig(\\n        bytes32 digest_,\\n        SignatureParams[] memory signaturesParams_,\\n        bool isNonSequentialNonce_\\n    ) internal view returns (bool isValid_, address[] memory recoveredSigners_) {\\n        // gas measurements:\\n        // cost until the for loop in verify signature is:\\n        // 1 signer 3374 (_getSigners() with only owner is cheaper)\\n        // 2 signers 6473\\n        // every additional allowedSigner (!) + 160 gas (additional SSTORE2 load cost)\\n        // For non-sequential nonce additional cold SLOAD + check cost is ~2200\\n        // dynamic cost for verifying any additional signer 7500\\n        // So formula:\\n        // Avoado signersCount == 1 ? -> 11_000 gas\\n        // Avoado signersCount > 1 ? -> 6400  + allowedSignersCount * 160 + signersLength * 7500\\n        // is non Sequential nonce? + 2200\\n        // is smart contract signer? + buffer amount. A very basic ECDSA verify call like with e.g. MockSigner costs ~9k.\\n        uint256 signaturesLength_ = signaturesParams_.length;\\n\\n        if (\\n            // enough signatures must be submitted to reach quorom of `requiredSigners`\\n            signaturesLength_ < _getRequiredSigners() ||\\n            // for non sequential nonce, if nonce is already used, the signature has already been used and is invalid\\n            (isNonSequentialNonce_ && nonSequentialNonces[digest_] == 1)\\n        ) {\\n            revert AvocadoMultisig__InvalidParams();\\n        }\\n\\n        // fill recovered signers array for use in event emit\\n        recoveredSigners_ = new address[](signaturesLength_);\\n\\n        // get current signers from storage\\n        address[] memory allowedSigners_ = _getSigners(); // includes owner\\n        uint256 allowedSignersLength_ = allowedSigners_.length;\\n        // track last allowed signer index for loop performance improvements\\n        uint256 lastAllowedSignerIndex_ = 0;\\n\\n        bool isContract_ = false; // keeping this variable outside the loop so it is not re-initialized in each loop -> cheaper\\n        bool isAllowedSigner_ = false;\\n        for (uint256 i; i < signaturesLength_; ) {\\n            if (Address.isContract(signaturesParams_[i].signer)) {\\n                recoveredSigners_[i] = signaturesParams_[i].signer;\\n                // set flag that the signer is a contract so we don't have to check again in code below\\n                isContract_ = true;\\n            } else {\\n                // recover signer from signature\\n                recoveredSigners_[i] = ECDSA.recover(digest_, signaturesParams_[i].signature);\\n\\n                if (signaturesParams_[i].signer != recoveredSigners_[i]) {\\n                    // signer does not match recovered signer. Either signer param is wrong or params used to\\n                    // build digest are not the same as for the signature\\n                    revert AvocadoMultisig__InvalidParams();\\n                }\\n            }\\n\\n            // because signers in storage and signers from signatures input params must be ordered ascending,\\n            // the for loop can be optimized each new cycle to start from the position where the last signer\\n            // has been found.\\n            // this also ensures that input params signers must be ordered ascending off-chain\\n            // (which again is used to improve performance and simplifies ensuring unique signers)\\n            for (uint256 j = lastAllowedSignerIndex_; j < allowedSignersLength_; ) {\\n                if (allowedSigners_[j] == recoveredSigners_[i]) {\\n                    isAllowedSigner_ = true;\\n                    unchecked {\\n                        lastAllowedSignerIndex_ = j + 1; // set to j+1 so that next cycle starts at next array position\\n                    }\\n                    break;\\n                }\\n\\n                // could be optimized by checking if allowedSigners_[j] > recoveredSigners_[i]\\n                // and immediately skipping with a `break;` if so. Because that implies that the recoveredSigners_[i]\\n                // can not be present in allowedSigners_ due to ascending sort.\\n                // But that would optimize the failing invalid case and increase cost for the default case where\\n                // the input data is valid -> skip.\\n\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            // validate if signer is allowed\\n            if (!isAllowedSigner_) {\\n                return (false, recoveredSigners_);\\n            } else {\\n                // reset `isAllowedSigner_` for next loop\\n                isAllowedSigner_ = false;\\n            }\\n\\n            if (isContract_) {\\n                // validate as smart contract signature\\n                if (\\n                    IERC1271(signaturesParams_[i].signer).isValidSignature(digest_, signaturesParams_[i].signature) !=\\n                    EIP1271_MAGIC_VALUE\\n                ) {\\n                    // return value is not EIP1271_MAGIC_VALUE -> smart contract returned signature is invalid\\n                    return (false, recoveredSigners_);\\n                }\\n\\n                // reset isContract for next loop (because defined outside of the loop to save gas)\\n                isContract_ = false;\\n            }\\n            // else already everything validated through recovered signer must be an allowed signer etc. in logic above\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return (true, recoveredSigners_);\\n    }\"}","{\"contract\": \"0xc2ec72b51fde96823f75811663dbbe3a8ad1b672\", \"contract_name\": \"AvocadoMultisigSigners\", \"sol_function\": \"function _verifySig(\\n        bytes32 digest_,\\n        SignatureParams[] memory signaturesParams_,\\n        bool isNonSequentialNonce_\\n    ) internal view returns (bool isValid_, address[] memory recoveredSigners_) {\\n        // gas measurements:\\n        // cost until the for loop in verify signature is:\\n        // 1 signer 3374 (_getSigners() with only owner is cheaper)\\n        // 2 signers 6473\\n        // every additional allowedSigner (!) + 160 gas (additional SSTORE2 load cost)\\n        // For non-sequential nonce additional cold SLOAD + check cost is ~2200\\n        // dynamic cost for verifying any additional signer 7500\\n        // So formula:\\n        // Avoado signersCount == 1 ? -> 11_000 gas\\n        // Avoado signersCount > 1 ? -> 6400  + allowedSignersCount * 160 + signersLength * 7500\\n        // is non Sequential nonce? + 2200\\n        // is smart contract signer? + buffer amount. A very basic ECDSA verify call like with e.g. MockSigner costs ~9k.\\n        uint256 signaturesLength_ = signaturesParams_.length;\\n\\n        if (\\n            // enough signatures must be submitted to reach quorom of `requiredSigners`\\n            signaturesLength_ < _getRequiredSigners() ||\\n            // for non sequential nonce, if nonce is already used, the signature has already been used and is invalid\\n            (isNonSequentialNonce_ && nonSequentialNonces[digest_] == 1)\\n        ) {\\n            revert AvocadoMultisig__InvalidParams();\\n        }\\n\\n        // fill recovered signers array for use in event emit\\n        recoveredSigners_ = new address[](signaturesLength_);\\n\\n        // get current signers from storage\\n        address[] memory allowedSigners_ = _getSigners(); // includes owner\\n        uint256 allowedSignersLength_ = allowedSigners_.length;\\n        // track last allowed signer index for loop performance improvements\\n        uint256 lastAllowedSignerIndex_ = 0;\\n\\n        bool isContract_ = false; // keeping this variable outside the loop so it is not re-initialized in each loop -> cheaper\\n        bool isAllowedSigner_ = false;\\n        for (uint256 i; i < signaturesLength_; ) {\\n            if (Address.isContract(signaturesParams_[i].signer)) {\\n                recoveredSigners_[i] = signaturesParams_[i].signer;\\n                // set flag that the signer is a contract so we don't have to check again in code below\\n                isContract_ = true;\\n            } else {\\n                // recover signer from signature\\n                recoveredSigners_[i] = ECDSA.recover(digest_, signaturesParams_[i].signature);\\n\\n                if (signaturesParams_[i].signer != recoveredSigners_[i]) {\\n                    // signer does not match recovered signer. Either signer param is wrong or params used to\\n                    // build digest are not the same as for the signature\\n                    revert AvocadoMultisig__InvalidParams();\\n                }\\n            }\\n\\n            // because signers in storage and signers from signatures input params must be ordered ascending,\\n            // the for loop can be optimized each new cycle to start from the position where the last signer\\n            // has been found.\\n            // this also ensures that input params signers must be ordered ascending off-chain\\n            // (which again is used to improve performance and simplifies ensuring unique signers)\\n            for (uint256 j = lastAllowedSignerIndex_; j < allowedSignersLength_; ) {\\n                if (allowedSigners_[j] == recoveredSigners_[i]) {\\n                    isAllowedSigner_ = true;\\n                    unchecked {\\n                        lastAllowedSignerIndex_ = j + 1; // set to j+1 so that next cycle starts at next array position\\n                    }\\n                    break;\\n                }\\n\\n                // could be optimized by checking if allowedSigners_[j] > recoveredSigners_[i]\\n                // and immediately skipping with a `break;` if so. Because that implies that the recoveredSigners_[i]\\n                // can not be present in allowedSigners_ due to ascending sort.\\n                // But that would optimize the failing invalid case and increase cost for the default case where\\n                // the input data is valid -> skip.\\n\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            // validate if signer is allowed\\n            if (!isAllowedSigner_) {\\n                return (false, recoveredSigners_);\\n            } else {\\n                // reset `isAllowedSigner_` for next loop\\n                isAllowedSigner_ = false;\\n            }\\n\\n            if (isContract_) {\\n                // validate as smart contract signature\\n                if (\\n                    IERC1271(signaturesParams_[i].signer).isValidSignature(digest_, signaturesParams_[i].signature) !=\\n                    EIP1271_MAGIC_VALUE\\n                ) {\\n                    // return value is not EIP1271_MAGIC_VALUE -> smart contract returned signature is invalid\\n                    return (false, recoveredSigners_);\\n                }\\n\\n                // reset isContract for next loop (because defined outside of the loop to save gas)\\n                isContract_ = false;\\n            }\\n            // else already everything validated through recovered signer must be an allowed signer etc. in logic above\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return (true, recoveredSigners_);\\n    }\"}","{\"contract\": \"0xc2ec72b51fde96823f75811663dbbe3a8ad1b672\", \"contract_name\": \"AvocadoMultisigCast\", \"sol_function\": \"function _verifySig(\\n        bytes32 digest_,\\n        SignatureParams[] memory signaturesParams_,\\n        bool isNonSequentialNonce_\\n    ) internal view returns (bool isValid_, address[] memory recoveredSigners_) {\\n        // gas measurements:\\n        // cost until the for loop in verify signature is:\\n        // 1 signer 3374 (_getSigners() with only owner is cheaper)\\n        // 2 signers 6473\\n        // every additional allowedSigner (!) + 160 gas (additional SSTORE2 load cost)\\n        // For non-sequential nonce additional cold SLOAD + check cost is ~2200\\n        // dynamic cost for verifying any additional signer 7500\\n        // So formula:\\n        // Avoado signersCount == 1 ? -> 11_000 gas\\n        // Avoado signersCount > 1 ? -> 6400  + allowedSignersCount * 160 + signersLength * 7500\\n        // is non Sequential nonce? + 2200\\n        // is smart contract signer? + buffer amount. A very basic ECDSA verify call like with e.g. MockSigner costs ~9k.\\n        uint256 signaturesLength_ = signaturesParams_.length;\\n\\n        if (\\n            // enough signatures must be submitted to reach quorom of `requiredSigners`\\n            signaturesLength_ < _getRequiredSigners() ||\\n            // for non sequential nonce, if nonce is already used, the signature has already been used and is invalid\\n            (isNonSequentialNonce_ && nonSequentialNonces[digest_] == 1)\\n        ) {\\n            revert AvocadoMultisig__InvalidParams();\\n        }\\n\\n        // fill recovered signers array for use in event emit\\n        recoveredSigners_ = new address[](signaturesLength_);\\n\\n        // get current signers from storage\\n        address[] memory allowedSigners_ = _getSigners(); // includes owner\\n        uint256 allowedSignersLength_ = allowedSigners_.length;\\n        // track last allowed signer index for loop performance improvements\\n        uint256 lastAllowedSignerIndex_ = 0;\\n\\n        bool isContract_ = false; // keeping this variable outside the loop so it is not re-initialized in each loop -> cheaper\\n        bool isAllowedSigner_ = false;\\n        for (uint256 i; i < signaturesLength_; ) {\\n            if (Address.isContract(signaturesParams_[i].signer)) {\\n                recoveredSigners_[i] = signaturesParams_[i].signer;\\n                // set flag that the signer is a contract so we don't have to check again in code below\\n                isContract_ = true;\\n            } else {\\n                // recover signer from signature\\n                recoveredSigners_[i] = ECDSA.recover(digest_, signaturesParams_[i].signature);\\n\\n                if (signaturesParams_[i].signer != recoveredSigners_[i]) {\\n                    // signer does not match recovered signer. Either signer param is wrong or params used to\\n                    // build digest are not the same as for the signature\\n                    revert AvocadoMultisig__InvalidParams();\\n                }\\n            }\\n\\n            // because signers in storage and signers from signatures input params must be ordered ascending,\\n            // the for loop can be optimized each new cycle to start from the position where the last signer\\n            // has been found.\\n            // this also ensures that input params signers must be ordered ascending off-chain\\n            // (which again is used to improve performance and simplifies ensuring unique signers)\\n            for (uint256 j = lastAllowedSignerIndex_; j < allowedSignersLength_; ) {\\n                if (allowedSigners_[j] == recoveredSigners_[i]) {\\n                    isAllowedSigner_ = true;\\n                    unchecked {\\n                        lastAllowedSignerIndex_ = j + 1; // set to j+1 so that next cycle starts at next array position\\n                    }\\n                    break;\\n                }\\n\\n                // could be optimized by checking if allowedSigners_[j] > recoveredSigners_[i]\\n                // and immediately skipping with a `break;` if so. Because that implies that the recoveredSigners_[i]\\n                // can not be present in allowedSigners_ due to ascending sort.\\n                // But that would optimize the failing invalid case and increase cost for the default case where\\n                // the input data is valid -> skip.\\n\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            // validate if signer is allowed\\n            if (!isAllowedSigner_) {\\n                return (false, recoveredSigners_);\\n            } else {\\n                // reset `isAllowedSigner_` for next loop\\n                isAllowedSigner_ = false;\\n            }\\n\\n            if (isContract_) {\\n                // validate as smart contract signature\\n                if (\\n                    IERC1271(signaturesParams_[i].signer).isValidSignature(digest_, signaturesParams_[i].signature) !=\\n                    EIP1271_MAGIC_VALUE\\n                ) {\\n                    // return value is not EIP1271_MAGIC_VALUE -> smart contract returned signature is invalid\\n                    return (false, recoveredSigners_);\\n                }\\n\\n                // reset isContract for next loop (because defined outside of the loop to save gas)\\n                isContract_ = false;\\n            }\\n            // else already everything validated through recovered signer must be an allowed signer etc. in logic above\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return (true, recoveredSigners_);\\n    }\"}","{\"contract\": \"0xc2ec72b51fde96823f75811663dbbe3a8ad1b672\", \"contract_name\": \"AvocadoMultisigCastAuthorized\", \"sol_function\": \"function _verifySig(\\n        bytes32 digest_,\\n        SignatureParams[] memory signaturesParams_,\\n        bool isNonSequentialNonce_\\n    ) internal view returns (bool isValid_, address[] memory recoveredSigners_) {\\n        // gas measurements:\\n        // cost until the for loop in verify signature is:\\n        // 1 signer 3374 (_getSigners() with only owner is cheaper)\\n        // 2 signers 6473\\n        // every additional allowedSigner (!) + 160 gas (additional SSTORE2 load cost)\\n        // For non-sequential nonce additional cold SLOAD + check cost is ~2200\\n        // dynamic cost for verifying any additional signer 7500\\n        // So formula:\\n        // Avoado signersCount == 1 ? -> 11_000 gas\\n        // Avoado signersCount > 1 ? -> 6400  + allowedSignersCount * 160 + signersLength * 7500\\n        // is non Sequential nonce? + 2200\\n        // is smart contract signer? + buffer amount. A very basic ECDSA verify call like with e.g. MockSigner costs ~9k.\\n        uint256 signaturesLength_ = signaturesParams_.length;\\n\\n        if (\\n            // enough signatures must be submitted to reach quorom of `requiredSigners`\\n            signaturesLength_ < _getRequiredSigners() ||\\n            // for non sequential nonce, if nonce is already used, the signature has already been used and is invalid\\n            (isNonSequentialNonce_ && nonSequentialNonces[digest_] == 1)\\n        ) {\\n            revert AvocadoMultisig__InvalidParams();\\n        }\\n\\n        // fill recovered signers array for use in event emit\\n        recoveredSigners_ = new address[](signaturesLength_);\\n\\n        // get current signers from storage\\n        address[] memory allowedSigners_ = _getSigners(); // includes owner\\n        uint256 allowedSignersLength_ = allowedSigners_.length;\\n        // track last allowed signer index for loop performance improvements\\n        uint256 lastAllowedSignerIndex_ = 0;\\n\\n        bool isContract_ = false; // keeping this variable outside the loop so it is not re-initialized in each loop -> cheaper\\n        bool isAllowedSigner_ = false;\\n        for (uint256 i; i < signaturesLength_; ) {\\n            if (Address.isContract(signaturesParams_[i].signer)) {\\n                recoveredSigners_[i] = signaturesParams_[i].signer;\\n                // set flag that the signer is a contract so we don't have to check again in code below\\n                isContract_ = true;\\n            } else {\\n                // recover signer from signature\\n                recoveredSigners_[i] = ECDSA.recover(digest_, signaturesParams_[i].signature);\\n\\n                if (signaturesParams_[i].signer != recoveredSigners_[i]) {\\n                    // signer does not match recovered signer. Either signer param is wrong or params used to\\n                    // build digest are not the same as for the signature\\n                    revert AvocadoMultisig__InvalidParams();\\n                }\\n            }\\n\\n            // because signers in storage and signers from signatures input params must be ordered ascending,\\n            // the for loop can be optimized each new cycle to start from the position where the last signer\\n            // has been found.\\n            // this also ensures that input params signers must be ordered ascending off-chain\\n            // (which again is used to improve performance and simplifies ensuring unique signers)\\n            for (uint256 j = lastAllowedSignerIndex_; j < allowedSignersLength_; ) {\\n                if (allowedSigners_[j] == recoveredSigners_[i]) {\\n                    isAllowedSigner_ = true;\\n                    unchecked {\\n                        lastAllowedSignerIndex_ = j + 1; // set to j+1 so that next cycle starts at next array position\\n                    }\\n                    break;\\n                }\\n\\n                // could be optimized by checking if allowedSigners_[j] > recoveredSigners_[i]\\n                // and immediately skipping with a `break;` if so. Because that implies that the recoveredSigners_[i]\\n                // can not be present in allowedSigners_ due to ascending sort.\\n                // But that would optimize the failing invalid case and increase cost for the default case where\\n                // the input data is valid -> skip.\\n\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            // validate if signer is allowed\\n            if (!isAllowedSigner_) {\\n                return (false, recoveredSigners_);\\n            } else {\\n                // reset `isAllowedSigner_` for next loop\\n                isAllowedSigner_ = false;\\n            }\\n\\n            if (isContract_) {\\n                // validate as smart contract signature\\n                if (\\n                    IERC1271(signaturesParams_[i].signer).isValidSignature(digest_, signaturesParams_[i].signature) !=\\n                    EIP1271_MAGIC_VALUE\\n                ) {\\n                    // return value is not EIP1271_MAGIC_VALUE -> smart contract returned signature is invalid\\n                    return (false, recoveredSigners_);\\n                }\\n\\n                // reset isContract for next loop (because defined outside of the loop to save gas)\\n                isContract_ = false;\\n            }\\n            // else already everything validated through recovered signer must be an allowed signer etc. in logic above\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return (true, recoveredSigners_);\\n    }\"}","{\"contract\": \"0xc2ec72b51fde96823f75811663dbbe3a8ad1b672\", \"contract_name\": \"AvocadoMultisig\", \"sol_function\": \"function _verifySig(\\n        bytes32 digest_,\\n        SignatureParams[] memory signaturesParams_,\\n        bool isNonSequentialNonce_\\n    ) internal view returns (bool isValid_, address[] memory recoveredSigners_) {\\n        // gas measurements:\\n        // cost until the for loop in verify signature is:\\n        // 1 signer 3374 (_getSigners() with only owner is cheaper)\\n        // 2 signers 6473\\n        // every additional allowedSigner (!) + 160 gas (additional SSTORE2 load cost)\\n        // For non-sequential nonce additional cold SLOAD + check cost is ~2200\\n        // dynamic cost for verifying any additional signer 7500\\n        // So formula:\\n        // Avoado signersCount == 1 ? -> 11_000 gas\\n        // Avoado signersCount > 1 ? -> 6400  + allowedSignersCount * 160 + signersLength * 7500\\n        // is non Sequential nonce? + 2200\\n        // is smart contract signer? + buffer amount. A very basic ECDSA verify call like with e.g. MockSigner costs ~9k.\\n        uint256 signaturesLength_ = signaturesParams_.length;\\n\\n        if (\\n            // enough signatures must be submitted to reach quorom of `requiredSigners`\\n            signaturesLength_ < _getRequiredSigners() ||\\n            // for non sequential nonce, if nonce is already used, the signature has already been used and is invalid\\n            (isNonSequentialNonce_ && nonSequentialNonces[digest_] == 1)\\n        ) {\\n            revert AvocadoMultisig__InvalidParams();\\n        }\\n\\n        // fill recovered signers array for use in event emit\\n        recoveredSigners_ = new address[](signaturesLength_);\\n\\n        // get current signers from storage\\n        address[] memory allowedSigners_ = _getSigners(); // includes owner\\n        uint256 allowedSignersLength_ = allowedSigners_.length;\\n        // track last allowed signer index for loop performance improvements\\n        uint256 lastAllowedSignerIndex_ = 0;\\n\\n        bool isContract_ = false; // keeping this variable outside the loop so it is not re-initialized in each loop -> cheaper\\n        bool isAllowedSigner_ = false;\\n        for (uint256 i; i < signaturesLength_; ) {\\n            if (Address.isContract(signaturesParams_[i].signer)) {\\n                recoveredSigners_[i] = signaturesParams_[i].signer;\\n                // set flag that the signer is a contract so we don't have to check again in code below\\n                isContract_ = true;\\n            } else {\\n                // recover signer from signature\\n                recoveredSigners_[i] = ECDSA.recover(digest_, signaturesParams_[i].signature);\\n\\n                if (signaturesParams_[i].signer != recoveredSigners_[i]) {\\n                    // signer does not match recovered signer. Either signer param is wrong or params used to\\n                    // build digest are not the same as for the signature\\n                    revert AvocadoMultisig__InvalidParams();\\n                }\\n            }\\n\\n            // because signers in storage and signers from signatures input params must be ordered ascending,\\n            // the for loop can be optimized each new cycle to start from the position where the last signer\\n            // has been found.\\n            // this also ensures that input params signers must be ordered ascending off-chain\\n            // (which again is used to improve performance and simplifies ensuring unique signers)\\n            for (uint256 j = lastAllowedSignerIndex_; j < allowedSignersLength_; ) {\\n                if (allowedSigners_[j] == recoveredSigners_[i]) {\\n                    isAllowedSigner_ = true;\\n                    unchecked {\\n                        lastAllowedSignerIndex_ = j + 1; // set to j+1 so that next cycle starts at next array position\\n                    }\\n                    break;\\n                }\\n\\n                // could be optimized by checking if allowedSigners_[j] > recoveredSigners_[i]\\n                // and immediately skipping with a `break;` if so. Because that implies that the recoveredSigners_[i]\\n                // can not be present in allowedSigners_ due to ascending sort.\\n                // But that would optimize the failing invalid case and increase cost for the default case where\\n                // the input data is valid -> skip.\\n\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            // validate if signer is allowed\\n            if (!isAllowedSigner_) {\\n                return (false, recoveredSigners_);\\n            } else {\\n                // reset `isAllowedSigner_` for next loop\\n                isAllowedSigner_ = false;\\n            }\\n\\n            if (isContract_) {\\n                // validate as smart contract signature\\n                if (\\n                    IERC1271(signaturesParams_[i].signer).isValidSignature(digest_, signaturesParams_[i].signature) !=\\n                    EIP1271_MAGIC_VALUE\\n                ) {\\n                    // return value is not EIP1271_MAGIC_VALUE -> smart contract returned signature is invalid\\n                    return (false, recoveredSigners_);\\n                }\\n\\n                // reset isContract for next loop (because defined outside of the loop to save gas)\\n                isContract_ = false;\\n            }\\n            // else already everything validated through recovered signer must be an allowed signer etc. in logic above\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return (true, recoveredSigners_);\\n    }\"}","{\"contract\": \"0xc2ec72b51fde96823f75811663dbbe3a8ad1b672\", \"contract_name\": \"AvocadoMultisigCore\", \"sol_function\": \"function _verifySig(\\n        bytes32 digest_,\\n        SignatureParams[] memory signaturesParams_,\\n        bool isNonSequentialNonce_\\n    ) internal view returns (bool isValid_, address[] memory recoveredSigners_) {\\n        // gas measurements:\\n        // cost until the for loop in verify signature is:\\n        // 1 signer 3374 (_getSigners() with only owner is cheaper)\\n        // 2 signers 6473\\n        // every additional allowedSigner (!) + 160 gas (additional SSTORE2 load cost)\\n        // For non-sequential nonce additional cold SLOAD + check cost is ~2200\\n        // dynamic cost for verifying any additional signer 7500\\n        // So formula:\\n        // Avoado signersCount == 1 ? -> 11_000 gas\\n        // Avoado signersCount > 1 ? -> 6400  + allowedSignersCount * 160 + signersLength * 7500\\n        // is non Sequential nonce? + 2200\\n        // is smart contract signer? + buffer amount. A very basic ECDSA verify call like with e.g. MockSigner costs ~9k.\\n        uint256 signaturesLength_ = signaturesParams_.length;\\n\\n        if (\\n            // enough signatures must be submitted to reach quorom of `requiredSigners`\\n            signaturesLength_ < _getRequiredSigners() ||\\n            // for non sequential nonce, if nonce is already used, the signature has already been used and is invalid\\n            (isNonSequentialNonce_ && nonSequentialNonces[digest_] == 1)\\n        ) {\\n            revert AvocadoMultisig__InvalidParams();\\n        }\\n\\n        // fill recovered signers array for use in event emit\\n        recoveredSigners_ = new address[](signaturesLength_);\\n\\n        // get current signers from storage\\n        address[] memory allowedSigners_ = _getSigners(); // includes owner\\n        uint256 allowedSignersLength_ = allowedSigners_.length;\\n        // track last allowed signer index for loop performance improvements\\n        uint256 lastAllowedSignerIndex_ = 0;\\n\\n        bool isContract_ = false; // keeping this variable outside the loop so it is not re-initialized in each loop -> cheaper\\n        bool isAllowedSigner_ = false;\\n        for (uint256 i; i < signaturesLength_; ) {\\n            if (Address.isContract(signaturesParams_[i].signer)) {\\n                recoveredSigners_[i] = signaturesParams_[i].signer;\\n                // set flag that the signer is a contract so we don't have to check again in code below\\n                isContract_ = true;\\n            } else {\\n                // recover signer from signature\\n                recoveredSigners_[i] = ECDSA.recover(digest_, signaturesParams_[i].signature);\\n\\n                if (signaturesParams_[i].signer != recoveredSigners_[i]) {\\n                    // signer does not match recovered signer. Either signer param is wrong or params used to\\n                    // build digest are not the same as for the signature\\n                    revert AvocadoMultisig__InvalidParams();\\n                }\\n            }\\n\\n            // because signers in storage and signers from signatures input params must be ordered ascending,\\n            // the for loop can be optimized each new cycle to start from the position where the last signer\\n            // has been found.\\n            // this also ensures that input params signers must be ordered ascending off-chain\\n            // (which again is used to improve performance and simplifies ensuring unique signers)\\n            for (uint256 j = lastAllowedSignerIndex_; j < allowedSignersLength_; ) {\\n                if (allowedSigners_[j] == recoveredSigners_[i]) {\\n                    isAllowedSigner_ = true;\\n                    unchecked {\\n                        lastAllowedSignerIndex_ = j + 1; // set to j+1 so that next cycle starts at next array position\\n                    }\\n                    break;\\n                }\\n\\n                // could be optimized by checking if allowedSigners_[j] > recoveredSigners_[i]\\n                // and immediately skipping with a `break;` if so. Because that implies that the recoveredSigners_[i]\\n                // can not be present in allowedSigners_ due to ascending sort.\\n                // But that would optimize the failing invalid case and increase cost for the default case where\\n                // the input data is valid -> skip.\\n\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            // validate if signer is allowed\\n            if (!isAllowedSigner_) {\\n                return (false, recoveredSigners_);\\n            } else {\\n                // reset `isAllowedSigner_` for next loop\\n                isAllowedSigner_ = false;\\n            }\\n\\n            if (isContract_) {\\n                // validate as smart contract signature\\n                if (\\n                    IERC1271(signaturesParams_[i].signer).isValidSignature(digest_, signaturesParams_[i].signature) !=\\n                    EIP1271_MAGIC_VALUE\\n                ) {\\n                    // return value is not EIP1271_MAGIC_VALUE -> smart contract returned signature is invalid\\n                    return (false, recoveredSigners_);\\n                }\\n\\n                // reset isContract for next loop (because defined outside of the loop to save gas)\\n                isContract_ = false;\\n            }\\n            // else already everything validated through recovered signer must be an allowed signer etc. in logic above\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return (true, recoveredSigners_);\\n    }\"}","{\"contract\": \"0x158b791a17956925a2bc55c37b0daf8c3ace4549\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x158b791a17956925a2bc55c37b0daf8c3ace4549\", \"contract_name\": \"PendlePrincipalToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x158b791a17956925a2bc55c37b0daf8c3ace4549\", \"contract_name\": \"PendleERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x905077dbad588b7b98c2e1785baaecf526393bd7\", \"contract_name\": \"UninterestedUnicornsV2\", \"sol_function\": \"function breedSigned(\\r\\n        address sender,\\r\\n        bytes memory nonce,\\r\\n        bytes memory signature,\\r\\n        uint256 parent_1_id,\\r\\n        uint256 parent_2_id\\r\\n    ) private view returns (bool) {\\r\\n        bytes32 hash = keccak256(\\r\\n            abi.encodePacked(sender, nonce, parent_1_id, parent_2_id)\\r\\n        );\\r\\n        return BREED_SIGNER == hash.recover(signature);\\r\\n    }\"}","{\"contract\": \"0x905077dbad588b7b98c2e1785baaecf526393bd7\", \"contract_name\": \"UninterestedUnicornsV2\", \"sol_function\": \"function whitelistSigned(\\r\\n        address sender,\\r\\n        bytes memory nonce,\\r\\n        bytes memory signature\\r\\n    ) private view returns (bool) {\\r\\n        bytes32 hash = keccak256(abi.encodePacked(sender, nonce));\\r\\n        return WHITELIST_SIGNER == hash.recover(signature);\\r\\n    }\"}","{\"contract\": \"0x46e7a89fda0db09d0ad651b7fb62a2c9dce9d152\", \"contract_name\": \"BaseSignature\", \"sol_function\": \"function _getAddressRecover(\\n    bytes32 digest,\\n    DataTypes.EIP712Signature memory sig\\n  ) internal view returns (address) {\\n    return digest.recover(sig.v, sig.r, sig.s);\\n  }\"}","{\"contract\": \"0x46e7a89fda0db09d0ad651b7fb62a2c9dce9d152\", \"contract_name\": \"AuctionSign\", \"sol_function\": \"function _getAddressRecover(\\n    bytes32 digest,\\n    DataTypes.EIP712Signature memory sig\\n  ) internal view returns (address) {\\n    return digest.recover(sig.v, sig.r, sig.s);\\n  }\"}","{\"contract\": \"0x46e7a89fda0db09d0ad651b7fb62a2c9dce9d152\", \"contract_name\": \"Auction\", \"sol_function\": \"function _getAddressRecover(\\n    bytes32 digest,\\n    DataTypes.EIP712Signature memory sig\\n  ) internal view returns (address) {\\n    return digest.recover(sig.v, sig.r, sig.s);\\n  }\"}","{\"contract\": \"0xf4308b0263723b121056938c2172868e408079d0\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xf4308b0263723b121056938c2172868e408079d0\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xf4308b0263723b121056938c2172868e408079d0\", \"contract_name\": \"JBToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x24d0aaac80a457be7843c59d45a1b90fbb02ed8e\", \"contract_name\": \"Governor\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x24d0aaac80a457be7843c59d45a1b90fbb02ed8e\", \"contract_name\": \"Governor\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x24d0aaac80a457be7843c59d45a1b90fbb02ed8e\", \"contract_name\": \"GovernorCountingSimple\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x24d0aaac80a457be7843c59d45a1b90fbb02ed8e\", \"contract_name\": \"GovernorCountingSimple\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x24d0aaac80a457be7843c59d45a1b90fbb02ed8e\", \"contract_name\": \"GovernorSettings\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x24d0aaac80a457be7843c59d45a1b90fbb02ed8e\", \"contract_name\": \"GovernorSettings\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x24d0aaac80a457be7843c59d45a1b90fbb02ed8e\", \"contract_name\": \"GovernorTimelockControl\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x24d0aaac80a457be7843c59d45a1b90fbb02ed8e\", \"contract_name\": \"GovernorTimelockControl\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x24d0aaac80a457be7843c59d45a1b90fbb02ed8e\", \"contract_name\": \"GovernorVotes\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x24d0aaac80a457be7843c59d45a1b90fbb02ed8e\", \"contract_name\": \"GovernorVotes\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x24d0aaac80a457be7843c59d45a1b90fbb02ed8e\", \"contract_name\": \"GovernorVotesQuorumFraction\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x24d0aaac80a457be7843c59d45a1b90fbb02ed8e\", \"contract_name\": \"GovernorVotesQuorumFraction\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x1c2c055ef6db2b4093b198418036b16edc502f15\", \"contract_name\": \"Mara\", \"sol_function\": \"function _verify(\\n    address wallet,\\n    uint256[] calldata vesselIds,\\n    bytes memory signature\\n  )\\n  internal\\n  view\\n  returns (bool)\\n  {\\n    return signer == keccak256(abi.encodePacked(\\n      wallet,\\n      vesselIds\\n    )).toEthSignedMessageHash().recover(signature);\\n  }\"}","{\"contract\": \"0x24d0aaac80a457be7843c59d45a1b90fbb02ed8e\", \"contract_name\": \"Governance\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x24d0aaac80a457be7843c59d45a1b90fbb02ed8e\", \"contract_name\": \"Governance\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0xe89805efcc8a55966c049b50aa9b66063ca18ea0\", \"contract_name\": \"Loot\", \"sol_function\": \"function _verify(\\n    address wallet,\\n    uint256 nonce,\\n    uint256[] calldata itemIds,\\n    uint256[] calldata itemAmounts,\\n    bytes memory signature\\n  )\\n  internal\\n  view\\n  returns (bool)\\n  {\\n    return signer == keccak256(abi.encodePacked(\\n      wallet,\\n      nonce,\\n      itemIds,\\n      itemAmounts\\n    )).toEthSignedMessageHash().recover(signature);\\n  }\"}","{\"contract\": \"0xd881fc440b9c2a2942d9fcb2cea168f8f0426063\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xd881fc440b9c2a2942d9fcb2cea168f8f0426063\", \"contract_name\": \"SnowmanNetworkToken\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x0f3c789b933b45c266b9ea4980b26931dc1cd435\", \"contract_name\": \"Aspect\", \"sol_function\": \"function recoverSigner(bytes32 digest, bytes calldata _signature)\\r\\n        public\\r\\n        pure\\r\\n        returns (address)\\r\\n    {\\r\\n        return ECDSA.recover(digest, _signature);\\r\\n    }\"}","{\"contract\": \"0x4bba877dda523f7c34c59560aa5fffafdbb4cba3\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x4bba877dda523f7c34c59560aa5fffafdbb4cba3\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x4bba877dda523f7c34c59560aa5fffafdbb4cba3\", \"contract_name\": \"JBToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xcfe737843ea809ae1a951675a848ab341f7b5b6c\", \"contract_name\": \"NFT\", \"sol_function\": \"function delegatedTransfer(\\n        address _addressTo,\\n        uint32 _tokenId,\\n        uint32 _expirationDate,\\n        bytes32 _salt,\\n        bytes memory _signature\\n    ) public {\\n        require(_expirationDate > block.timestamp, \\\"Time is out\\\");\\n        require(saltUsed[_salt] == false, \\\"This salt was used\\\");\\n        bytes32 _hash = _hashTypedDataV4(\\n            keccak256(\\n                abi.encode(\\n                    TRANSFER_TYPEHASH,\\n                    _addressTo,\\n                    _tokenId,\\n                    _expirationDate,\\n                    _salt\\n                )\\n            )\\n        );\\n        address owner = ECDSA.recover(_hash, _signature);\\n\\n        saltUsed[_salt] = true;\\n\\n        _transfer(owner, _addressTo, _tokenId);\\n    }\"}","{\"contract\": \"0xcfe737843ea809ae1a951675a848ab341f7b5b6c\", \"contract_name\": \"NFT\", \"sol_function\": \"function delegatedBurn(\\n        uint32 _tokenId,\\n        uint32 _expirationDate,\\n        bytes32 _salt,\\n        bytes memory _signature\\n    ) public {\\n        require(_expirationDate > block.timestamp, \\\"Time is out\\\");\\n        require(saltUsed[_salt] == false, \\\"This salt was used\\\");\\n\\n        bytes32 _hash = _hashTypedDataV4(\\n            keccak256(\\n                abi.encode(BURN_TYPEHASH, _tokenId, _expirationDate, _salt)\\n            )\\n        );\\n        address owner = ECDSA.recover(_hash, _signature);\\n\\n        require(owner == ownerOf(_tokenId), \\\"Wrong sender\\\");\\n\\n        saltUsed[_salt] = true;\\n\\n        _burn(_tokenId);\\n\\n        isTokenBurned[_tokenId] = true;\\n    }\"}","{\"contract\": \"0xdfea3fc33a9f6d5a0e93b0e082a8e6911a7fce4c\", \"contract_name\": \"LudoBalancePool\", \"sol_function\": \"function _verify(UserInfo memory result) internal view returns (address) {\\r\\n        bytes32 digest = _hash(result);\\r\\n        return ECDSA.recover(digest, result.signature);\\r\\n    }\"}","{\"contract\": \"0xdfea3fc33a9f6d5a0e93b0e082a8e6911a7fce4c\", \"contract_name\": \"Signer\", \"sol_function\": \"function _verify(UserInfo memory result) internal view returns (address) {\\r\\n        bytes32 digest = _hash(result);\\r\\n        return ECDSA.recover(digest, result.signature);\\r\\n    }\"}","{\"contract\": \"0x24e801cc44cb97ca996c2f4ad123a9e8ea033848\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x24e801cc44cb97ca996c2f4ad123a9e8ea033848\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x24e801cc44cb97ca996c2f4ad123a9e8ea033848\", \"contract_name\": \"EquityToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xa1af5bab0563f1435238b808d66d6babf5a6d776\", \"contract_name\": \"BalladrMinter\", \"sol_function\": \"function _verifyRequestId(Ticket calldata ticket)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        bytes32 digest = _hashrequestId(ticket);\\n        return ECDSA.recover(digest, ticket.requestSignature);\\n    }\"}","{\"contract\": \"0xa1af5bab0563f1435238b808d66d6babf5a6d776\", \"contract_name\": \"BalladrMinter\", \"sol_function\": \"function _verifyTicket(Ticket calldata ticket)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        bytes32 digest = _hashTicket(ticket);\\n        return ECDSA.recover(digest, ticket.signature);\\n    }\"}","{\"contract\": \"0x801fd3f13c6f99e8926802107701042532b7db9b\", \"contract_name\": \"ERC1155Main\", \"sol_function\": \"function _verifySigner(\\n        string calldata _tokenURI,\\n        uint256 amount,\\n        bytes calldata signature\\n    ) private view {\\n        address signer =\\n            ECDSA.recover(\\n                keccak256(abi.encodePacked(this, _tokenURI, amount)),\\n                signature\\n            );\\n        require(\\n            hasRole(SIGNER_ROLE, signer),\\n            \\\"ERC1155Main: Signer should sign transaction\\\"\\n        );\\n    }\"}","{\"contract\": \"0x801fd3f13c6f99e8926802107701042532b7db9b\", \"contract_name\": \"FactoryErc1155\", \"sol_function\": \"function _verifySigner(address signer, bytes calldata signature)\\n        private\\n        view\\n    {\\n        address messageSigner =\\n            ECDSA.recover(keccak256(abi.encodePacked(signer)), signature);\\n        require(\\n            hasRole(SIGNER_ROLE, messageSigner),\\n            \\\"FactoryErc1155: Signer should sign transaction\\\"\\n        );\\n    }\"}","{\"contract\": \"0xa7e33f1448bc034751193f44b182a01c59d12c4c\", \"contract_name\": \"TalonPaymentReceiver\", \"sol_function\": \"function _verifyInputSignature(CryptoPaymentRawType memory input_) internal view {\\n    uint chainId;\\n    assembly {\\n      chainId := chainid()\\n    }\\n    require(input_.chainId == chainId, \\\"Invalid network\\\");\\n    bytes32 hash_ = keccak256(\\n      abi.encode(\\n        input_.chainId,\\n        input_.paymentId,\\n        input_.userWallet,\\n        input_.highAmount,\\n        input_.option1Amount,\\n        input_.option2Amount,\\n        input_.deadline\\n      )\\n    );\\n    bytes32 appendEthSignedMessageHash = ECDSA.toEthSignedMessageHash(hash_);\\n    address inputSigner = ECDSA.recover(appendEthSignedMessageHash, input_.v, input_.r, input_.s);\\n    require(signer == inputSigner, \\\"Invalid signer\\\");\\n  }\"}","{\"contract\": \"0xe5339bf9799a627e042d1b91a6503ce7b031b951\", \"contract_name\": \"AspenERC1155DropDelegateLogic\", \"sol_function\": \"function _verifySignature(\\n        TermsDataTypes.Terms storage termsData,\\n        address _acceptor,\\n        bytes memory _signature\\n    ) internal view returns (bool) {\\n        if (_signature.length == 0) return false;\\n        bytes32 hash = _hashMessage(termsData, _acceptor);\\n        address signer = ECDSAUpgradeable.recover(hash, _signature);\\n        return signer == _acceptor;\\n    }\"}","{\"contract\": \"0xe5339bf9799a627e042d1b91a6503ce7b031b951\", \"contract_name\": \"AspenERC721DropDelegateLogic\", \"sol_function\": \"function _verifySignature(\\n        TermsDataTypes.Terms storage termsData,\\n        address _acceptor,\\n        bytes memory _signature\\n    ) internal view returns (bool) {\\n        if (_signature.length == 0) return false;\\n        bytes32 hash = _hashMessage(termsData, _acceptor);\\n        address signer = ECDSAUpgradeable.recover(hash, _signature);\\n        return signer == _acceptor;\\n    }\"}","{\"contract\": \"0x76d8fe9fa8768dcf1711c8e6d608e84b1ab4a57b\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x76d8fe9fa8768dcf1711c8e6d608e84b1ab4a57b\", \"contract_name\": \"__Token__\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xf455b05bfcee4ff87e8ffd78b9f2752b3218b537\", \"contract_name\": \"TimeLockPool\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xf455b05bfcee4ff87e8ffd78b9f2752b3218b537\", \"contract_name\": \"BasePool\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xf455b05bfcee4ff87e8ffd78b9f2752b3218b537\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xf455b05bfcee4ff87e8ffd78b9f2752b3218b537\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x7fc09a551e550ce7312d0a759a7e50c3a75621c8\", \"contract_name\": \"FirstThreadReceipts\", \"sol_function\": \"function verifyAddressSigner(\\n        bytes32 messageHash,\\n        bytes calldata signature\\n    ) private view returns (bool) {\\n        address recovery = messageHash.toEthSignedMessageHash().recover(signature);\\n        return signerAddress == recovery;\\n    }\"}","{\"contract\": \"0xf9849f6d4e00ad734e8bfcc8a046658ec612d76a\", \"contract_name\": \"CybertinoCanvasV0\", \"sol_function\": \"function _verify(bytes32 messageHash, bytes memory signature)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();\\n    return ethSignedMessageHash.recover(signature) == signer;\\n  }\"}","{\"contract\": \"0xd673fca4718b2fe41719a8b7d058955068c033aa\", \"contract_name\": \"PeaceClaim\", \"sol_function\": \"function isValidSignature(\\n        address recipient,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) private view returns (bool) {\\n        bytes32 message = keccak256(abi.encode(recipient, amount, deadline));\\n        return message.recover(v, r, s) == signer;\\n    }\"}","{\"contract\": \"0x191afb6f36478f529a0446d0f12857c9eaed991a\", \"contract_name\": \"GenesisProtocol\", \"sol_function\": \"function stakeWithSignature(\\n        bytes32 _proposalId,\\n        uint256 _vote,\\n        uint256 _amount,\\n        uint256 _nonce,\\n        uint256 _signatureType,\\n        bytes calldata _signature\\n        )\\n        external\\n        returns(bool)\\n        {\\n        // Recreate the digest the user signed\\n        bytes32 delegationDigest;\\n        if (_signatureType == 2) {\\n            delegationDigest = keccak256(\\n                abi.encodePacked(\\n                    DELEGATION_HASH_EIP712, keccak256(\\n                        abi.encodePacked(\\n                        address(this),\\n                        _proposalId,\\n                        _vote,\\n                        _amount,\\n                        _nonce)\\n                    )\\n                )\\n            );\\n        } else {\\n            delegationDigest = keccak256(\\n                        abi.encodePacked(\\n                        address(this),\\n                        _proposalId,\\n                        _vote,\\n                        _amount,\\n                        _nonce)\\n                    ).toEthSignedMessageHash();\\n        }\\n        address staker = delegationDigest.recover(_signature);\\n        //a garbage staker address due to wrong signature will revert due to lack of approval and funds.\\n        require(staker != address(0), \\\"staker address cannot be 0\\\");\\n        require(stakesNonce[staker] == _nonce);\\n        stakesNonce[staker] = stakesNonce[staker].add(1);\\n        return _stake(_proposalId, _vote, _amount, staker);\\n    }\"}","{\"contract\": \"0xe8bd21db0be11f3fcfb16bdd9bf9109064ec812f\", \"contract_name\": \"DPoSCore\", \"sol_function\": \"function recover(address _token, address _recipient, uint256 _totalAmount, bytes memory _signature)\\n        public\\n        view\\n        returns (address)\\n    {\\n        bytes32 hash = keccak256(abi.encodePacked(getChainId(), _token, _recipient, _totalAmount));\\n        bytes32 prefixedHash = keccak256(abi.encodePacked(_ETH_PREFIX, hash));\\n        return ECDSA.recover(prefixedHash, _signature);\\n    }\"}","{\"contract\": \"0xe8bd21db0be11f3fcfb16bdd9bf9109064ec812f\", \"contract_name\": \"DPoSUmbRewards\", \"sol_function\": \"function recover(address _token, address _recipient, uint256 _totalAmount, bytes memory _signature)\\n        public\\n        view\\n        returns (address)\\n    {\\n        bytes32 hash = keccak256(abi.encodePacked(getChainId(), _token, _recipient, _totalAmount));\\n        bytes32 prefixedHash = keccak256(abi.encodePacked(_ETH_PREFIX, hash));\\n        return ECDSA.recover(prefixedHash, _signature);\\n    }\"}","{\"contract\": \"0x0857e029c9f165ba76bad695301ce53b40b3a25e\", \"contract_name\": \"MetaFireToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x0857e029c9f165ba76bad695301ce53b40b3a25e\", \"contract_name\": \"ERC20Detailed\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x0857e029c9f165ba76bad695301ce53b40b3a25e\", \"contract_name\": \"ERC20PermitUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x98581d9d7c07700001cba824c488442dd980c7c1\", \"contract_name\": \"Reward\", \"sol_function\": \"function _verify(Voucher calldata voucher) public view returns (address) {\\n        bytes32 digest = _hash(voucher);\\n        return ECDSAUpgradeable.recover(digest, voucher.signature);\\n    }\"}","{\"contract\": \"0x5724373030c355716e9f05338fd3ca2c5b78cd87\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x5724373030c355716e9f05338fd3ca2c5b78cd87\", \"contract_name\": \"SmardexPair\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x23ec9319e6b0832435b52cf667c9c67da659894f\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x23ec9319e6b0832435b52cf667c9c67da659894f\", \"contract_name\": \"SmardexPair\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x991c13ff5e8bd3ffc59244a8cf13e0253c78d2bd\", \"contract_name\": \"Governor\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x991c13ff5e8bd3ffc59244a8cf13e0253c78d2bd\", \"contract_name\": \"Governor\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x991c13ff5e8bd3ffc59244a8cf13e0253c78d2bd\", \"contract_name\": \"GovernorCountingSimple\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x991c13ff5e8bd3ffc59244a8cf13e0253c78d2bd\", \"contract_name\": \"GovernorCountingSimple\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x991c13ff5e8bd3ffc59244a8cf13e0253c78d2bd\", \"contract_name\": \"GovernorSettings\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x991c13ff5e8bd3ffc59244a8cf13e0253c78d2bd\", \"contract_name\": \"GovernorSettings\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x991c13ff5e8bd3ffc59244a8cf13e0253c78d2bd\", \"contract_name\": \"GovernorTimelockControl\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x991c13ff5e8bd3ffc59244a8cf13e0253c78d2bd\", \"contract_name\": \"GovernorTimelockControl\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x991c13ff5e8bd3ffc59244a8cf13e0253c78d2bd\", \"contract_name\": \"GovernorVotes\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x991c13ff5e8bd3ffc59244a8cf13e0253c78d2bd\", \"contract_name\": \"GovernorVotes\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x991c13ff5e8bd3ffc59244a8cf13e0253c78d2bd\", \"contract_name\": \"GovernorVotesQuorumFraction\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x991c13ff5e8bd3ffc59244a8cf13e0253c78d2bd\", \"contract_name\": \"GovernorVotesQuorumFraction\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x991c13ff5e8bd3ffc59244a8cf13e0253c78d2bd\", \"contract_name\": \"Governance\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x991c13ff5e8bd3ffc59244a8cf13e0253c78d2bd\", \"contract_name\": \"Governance\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x62bee413b1f91e9e00b97509568e9ed9afc0afa7\", \"contract_name\": \"Griftels\", \"sol_function\": \"function verifySignature(\\n        uint256 grifterId,\\n        uint256 nonce,\\n        bytes memory signature\\n    ) internal returns (bool) {\\n        bytes32 hash = keccak256(abi.encodePacked(msg.sender, grifterId, nonce));\\n        bytes32 message = ECDSA.toEthSignedMessageHash(hash);\\n        address receivedAddress = ECDSA.recover(message, signature);\\n        require(receivedAddress != address(0), \\\"verifySignature: Cannot be 0x0\\\");\\n        require(!seenNonces[receivedAddress][nonce], \\\"verifySignature: Nonce already used\\\");\\n        seenNonces[receivedAddress][nonce] = true;\\n        \\n        return receivedAddress == signer;\\n    }\"}","{\"contract\": \"0xef947cddfe87f8e03c9722a38d32e14a22ec9ff2\", \"contract_name\": \"MaybeNothingNFT\", \"sol_function\": \"function verifySignerAddress(bytes32 messageHash, bytes calldata signature)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return\\n            presaleSignerAddress ==\\n            messageHash.toEthSignedMessageHash().recover(signature);\\n    }\"}","{\"contract\": \"0x7add7e6f431cfa23dffce61dd9749810dc678b16\", \"contract_name\": \"Validate\", \"sol_function\": \"function recoverPropose(\\n        uint256 _height,\\n        uint256 _round,\\n        bytes memory _blockhash,\\n        uint256 _validRound,\\n        bytes memory _signature\\n    ) internal pure returns (address) {\\n        return ECDSA.recover(sha256(proposeMessage(_height, _round, _blockhash, _validRound)), _signature);\\n    }\"}","{\"contract\": \"0x7add7e6f431cfa23dffce61dd9749810dc678b16\", \"contract_name\": \"Validate\", \"sol_function\": \"function recoverPrevote(\\n        uint256 _height,\\n        uint256 _round,\\n        bytes memory _blockhash,\\n        bytes memory _signature\\n    ) internal pure returns (address) {\\n        return ECDSA.recover(sha256(prevoteMessage(_height, _round, _blockhash)), _signature);\\n    }\"}","{\"contract\": \"0x7add7e6f431cfa23dffce61dd9749810dc678b16\", \"contract_name\": \"Validate\", \"sol_function\": \"function recoverPrecommit(\\n        uint256 _height,\\n        uint256 _round,\\n        bytes memory _blockhash,\\n        bytes memory _signature\\n    ) internal pure returns (address) {\\n        return ECDSA.recover(sha256(precommitMessage(_height, _round, _blockhash)), _signature);\\n    }\"}","{\"contract\": \"0x7add7e6f431cfa23dffce61dd9749810dc678b16\", \"contract_name\": \"Validate\", \"sol_function\": \"function recoverSecret(\\n        uint256 _a,\\n        uint256 _b,\\n        uint256 _c,\\n        uint256 _d,\\n        uint256 _e,\\n        uint256 _f,\\n        bytes memory _signature\\n    ) internal pure returns (address) {\\n        return ECDSA.recover(sha256(secretMessage(_a, _b, _c, _d, _e, _f)), _signature);\\n    }\"}","{\"contract\": \"0xe5d6e5e5785dd347fa0d13e1eaeef025b4e07d2c\", \"contract_name\": \"Forwarder\", \"sol_function\": \"function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) {\\n        address signer = _hashTypedDataV4(\\n            keccak256(abi.encode(TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))\\n        ).recover(signature);\\n\\n        return _nonces[req.from] == req.nonce && signer == req.from;\\n    }\"}","{\"contract\": \"0xe5d6e5e5785dd347fa0d13e1eaeef025b4e07d2c\", \"contract_name\": \"SignatureMint721\", \"sol_function\": \"function recoverAddress(MintRequest calldata _req, bytes calldata _signature) internal view returns (address) {\\n        return\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        TYPEHASH,\\n                        _req.to,\\n                        keccak256(bytes(_req.uri)),\\n                        _req.price,\\n                        _req.currency,\\n                        _req.validityStartTimestamp,\\n                        _req.validityEndTimestamp,\\n                        _req.uid\\n                    )\\n                )\\n            ).recover(_signature);\\n    }\"}","{\"contract\": \"0xc9f704d7fc239a8fd795f8a57b66b83498558175\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xc9f704d7fc239a8fd795f8a57b66b83498558175\", \"contract_name\": \"PoolToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xf7767231aec17c4ce5f630edc45f8159433a44a3\", \"contract_name\": \"OOC\", \"sol_function\": \"function signcheck(_signvrs calldata signinfo)public view returns(address _signer){\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, signinfo.gainer,signinfo.amount,signinfo.deadline,signinfo.typemint));\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n        return ECDSA.recover(hash, signinfo.v, signinfo.r, signinfo.s);\\n    }\"}","{\"contract\": \"0x144044f20314fe694323e01d6c01aa6dfdd6946d\", \"contract_name\": \"ValidatorService\", \"sol_function\": \"function linkNodeAddress(address nodeAddress, bytes calldata sig) external {\\n        // check Validator Exist inside getValidatorId\\n        uint validatorId = getValidatorId(msg.sender);\\n        require(\\n            keccak256(abi.encodePacked(validatorId)).toEthSignedMessageHash().recover(sig) == nodeAddress,\\n            \\\"Signature is not pass\\\"\\n        );\\n        require(_validatorAddressToId[nodeAddress] == 0, \\\"Node address is a validator\\\");\\n\\n        _addNodeAddress(validatorId, nodeAddress);\\n        emit NodeAddressWasAdded(validatorId, nodeAddress);\\n    }\"}","{\"contract\": \"0x5caf53fe97a0e2e1568feac340d78f7a5b3dad1a\", \"contract_name\": \"PhoenixBurn\", \"sol_function\": \"function verify(bytes calldata signature) public view returns (bool) {\\n    bytes32 digest = _hashTypedDataV4(\\n        keccak256(\\n            abi.encode(\\n                MINTKEY_TYPE_HASH,\\n                msg.sender,\\n                GENERATION\\n            )\\n        )\\n      );\\n\\n      return ECDSA.recover(digest, signature) == _signer;\\n    }\"}","{\"contract\": \"0xf4da39a1796a06cbfaea19fb3f2b88b35389ef0e\", \"contract_name\": \"Mint721Validator\", \"sol_function\": \"function validate1271(address signer, bytes32 structHash, bytes memory signature) internal view {\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signerFromSig;\\n        if (signature.length == 65) {\\n            signerFromSig = hash.recover(signature);\\n        }\\n        if  (signerFromSig != signer) {\\n            if (signer.isContract()) {\\n                require(\\n                    ERC1271(signer).isValidSignature(hash, signature) == MAGICVALUE,\\n                    SIGNATURE_ERROR\\n                );\\n            } else {\\n                revert(SIGNATURE_ERROR);\\n            }\\n        }\\n    }\"}","{\"contract\": \"0xf4da39a1796a06cbfaea19fb3f2b88b35389ef0e\", \"contract_name\": \"ERC1271Validator\", \"sol_function\": \"function validate1271(address signer, bytes32 structHash, bytes memory signature) internal view {\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signerFromSig;\\n        if (signature.length == 65) {\\n            signerFromSig = hash.recover(signature);\\n        }\\n        if  (signerFromSig != signer) {\\n            if (signer.isContract()) {\\n                require(\\n                    ERC1271(signer).isValidSignature(hash, signature) == MAGICVALUE,\\n                    SIGNATURE_ERROR\\n                );\\n            } else {\\n                revert(SIGNATURE_ERROR);\\n            }\\n        }\\n    }\"}","{\"contract\": \"0xf4da39a1796a06cbfaea19fb3f2b88b35389ef0e\", \"contract_name\": \"ERC721BaseMinimal\", \"sol_function\": \"function validate1271(address signer, bytes32 structHash, bytes memory signature) internal view {\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signerFromSig;\\n        if (signature.length == 65) {\\n            signerFromSig = hash.recover(signature);\\n        }\\n        if  (signerFromSig != signer) {\\n            if (signer.isContract()) {\\n                require(\\n                    ERC1271(signer).isValidSignature(hash, signature) == MAGICVALUE,\\n                    SIGNATURE_ERROR\\n                );\\n            } else {\\n                revert(SIGNATURE_ERROR);\\n            }\\n        }\\n    }\"}","{\"contract\": \"0xf4da39a1796a06cbfaea19fb3f2b88b35389ef0e\", \"contract_name\": \"ERC721LazyMinimal\", \"sol_function\": \"function validate1271(address signer, bytes32 structHash, bytes memory signature) internal view {\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signerFromSig;\\n        if (signature.length == 65) {\\n            signerFromSig = hash.recover(signature);\\n        }\\n        if  (signerFromSig != signer) {\\n            if (signer.isContract()) {\\n                require(\\n                    ERC1271(signer).isValidSignature(hash, signature) == MAGICVALUE,\\n                    SIGNATURE_ERROR\\n                );\\n            } else {\\n                revert(SIGNATURE_ERROR);\\n            }\\n        }\\n    }\"}","{\"contract\": \"0xf4da39a1796a06cbfaea19fb3f2b88b35389ef0e\", \"contract_name\": \"ERC721RaribleMinimal\", \"sol_function\": \"function validate1271(address signer, bytes32 structHash, bytes memory signature) internal view {\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signerFromSig;\\n        if (signature.length == 65) {\\n            signerFromSig = hash.recover(signature);\\n        }\\n        if  (signerFromSig != signer) {\\n            if (signer.isContract()) {\\n                require(\\n                    ERC1271(signer).isValidSignature(hash, signature) == MAGICVALUE,\\n                    SIGNATURE_ERROR\\n                );\\n            } else {\\n                revert(SIGNATURE_ERROR);\\n            }\\n        }\\n    }\"}","{\"contract\": \"0x21bc76e5c88f4182677da0bbb07f57a1cd18f6c6\", \"contract_name\": \"ERC20PermitUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x21bc76e5c88f4182677da0bbb07f57a1cd18f6c6\", \"contract_name\": \"stTON\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x21bc76e5c88f4182677da0bbb07f57a1cd18f6c6\", \"contract_name\": \"stTON\", \"sol_function\": \"function _validateSignature(\\n        address to,\\n        uint256 amount,\\n        bytes32 salt,\\n        bytes[] memory signature\\n    ) internal {\\n        bytes32 hash = keccak256(abi.encode(VALIDATE_TYPEHASH, to, amount, salt));\\n        if (usedHashes[hash]) revert AlreadyUsedSignature();\\n        usedHashes[hash] = true;\\n\\n        uint256 len = signature.length;\\n        uint256 valGroup1Count;\\n        uint256 valGroup2Count;\\n        uint256 valGroup3Count;\\n        bytes32 digest = _hashTypedDataV4(hash);\\n        address signer;\\n        for (uint256 i; i < len; ) {\\n            signer = ECDSAUpgradeable.recover(digest, signature[i]);\\n            if (hasRole(VALIDATOR_GROUP1, signer)) {\\n                valGroup1Count++;\\n            } else if (hasRole(VALIDATOR_GROUP2, signer)) {\\n                valGroup2Count++;\\n            } else if (hasRole(VALIDATOR_GROUP3, signer)) {\\n                valGroup3Count++;\\n            }\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        _validateGroupCount(valGroup1Count, valGroup2Count, valGroup3Count);\\n    }\"}","{\"contract\": \"0x1fb7317359d88076a24cdb97d84cec796baba876\", \"contract_name\": \"CouncillorNFT\", \"sol_function\": \"function _requireValidProof(\\r\\n        address to,\\r\\n        address delegate,\\r\\n        bytes32[] calldata proof,\\r\\n        bytes calldata signature\\r\\n    ) internal view {\\r\\n        if (msg.sender == owner) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(\\r\\n            keccak256(abi.encode(_TYPE_HASH, to, delegate, _encodeProof(proof)))\\r\\n        );\\r\\n        address claimant = ECDSA.recover(hash, signature);\\r\\n\\r\\n        require(claimant == to, \\\"invalid signature\\\");\\r\\n\\r\\n        bytes32 node = keccak256(abi.encodePacked(to));\\r\\n        require(_merkleRoot.isProofValid(node, proof), \\\"invalid proof\\\");\\r\\n    }\"}","{\"contract\": \"0xe206a4f8c180a4f6745fcb1cfd1824210c691b88\", \"contract_name\": \"LMPVault\", \"sol_function\": \"function recover(\\n        address[] calldata tokens,\\n        uint256[] calldata amounts,\\n        address[] calldata destinations\\n    ) external virtual override hasRole(Roles.TOKEN_RECOVERY_ROLE) {\\n        AutoPool4626.recover(tokens, amounts, destinations);\\n    }\"}","{\"contract\": \"0xefd97fa150ad7c01f146614386f23987e147f609\", \"contract_name\": \"TheNFTLeagueV2\", \"sol_function\": \"function whitelistMint(uint256 quantity, bytes calldata signature)\\n        public\\n        payable\\n        whenNotPaused\\n    {\\n        require(\\n            signerAddress ==\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                        bytes32(uint256(uint160(msg.sender)))\\n                    )\\n                ).recover(signature),\\n            \\\"Signer address mismatch.\\\"\\n        );\\n        require(\\n            (signatureMintedAmount[signature] + quantity) <\\n                whitelistMintPerSignature,\\n            \\\"No whitelist mints remaining for this wallet\\\"\\n        );\\n        require((_totalMinted() + quantity) < maxSupply, \\\"Exceeded Max Supply\\\");\\n        require(quantity * price == msg.value, \\\"Invalid funds provided.\\\");\\n        signatureMintedAmount[signature] += quantity;\\n        _mint(msg.sender, quantity);\\n    }\"}","{\"contract\": \"0x993cef2cddc608ecf4feb8eeabdfc3c9f90c38c1\", \"contract_name\": \"ERC20PermitUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x110b7afe5e60a918b8df7247e6588afa2b909d0b\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\naddress owner,\\r\\naddress spender,\\r\\nuint256 value,\\r\\nuint256 deadline,\\r\\nuint8 v,\\r\\nbytes32 r,\\r\\nbytes32 s\\r\\n) public virtual override {\\r\\nrequire(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\nbytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\nbytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\naddress signer = ECDSA.recover(hash, v, r, s);\\r\\nrequire(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n_approve(owner, spender, value);\\r\\n}\"}","{\"contract\": \"0x110b7afe5e60a918b8df7247e6588afa2b909d0b\", \"contract_name\": \"cowcoin\", \"sol_function\": \"function permit(\\r\\naddress owner,\\r\\naddress spender,\\r\\nuint256 value,\\r\\nuint256 deadline,\\r\\nuint8 v,\\r\\nbytes32 r,\\r\\nbytes32 s\\r\\n) public virtual override {\\r\\nrequire(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\nbytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\nbytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\naddress signer = ECDSA.recover(hash, v, r, s);\\r\\nrequire(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n_approve(owner, spender, value);\\r\\n}\"}","{\"contract\": \"0x993cef2cddc608ecf4feb8eeabdfc3c9f90c38c1\", \"contract_name\": \"Mnt\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x993cef2cddc608ecf4feb8eeabdfc3c9f90c38c1\", \"contract_name\": \"MntVotes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x7947d80985d696cb9058da3b10935c73b79525ab\", \"contract_name\": \"MutariuumStaking\", \"sol_function\": \"function _verifySignature(address nft, uint256 tokenId, bytes calldata signature) internal view returns (bool){\\n        bytes32 message = keccak256(abi.encodePacked(msg.sender, _signatureNonces[msg.sender], nft, tokenId));\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                message\\n            )\\n        );\\n        address signer = ECDSA.recover(hash, signature);\\n        return signer == owner();\\n    }\"}","{\"contract\": \"0x8cc02c0d9592976635e98e6446ef4976567e7a81\", \"contract_name\": \"VotingEscrowBoost\", \"sol_function\": \"function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external {\\n    if (block.timestamp > deadline) {\\n      revert ExpiredDeadline();\\n    }\\n\\n    bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n    bytes32 hash = _hashTypedDataV4(structHash);\\n\\n    address signer = ECDSA.recover(hash, v, r, s);\\n    if (signer != owner) {\\n      revert InvalidSignature();\\n    }\\n\\n    _approve(owner, spender, value);\\n  }\"}","{\"contract\": \"0x977e25619f0068a9150e2a99abebcee559133ae1\", \"contract_name\": \"Signed\", \"sol_function\": \"function getSigner( bytes32 hash, bytes memory signature ) internal pure returns( address ){\\r\\n    return hash.toEthSignedMessageHash().recover( signature );\\r\\n  }\"}","{\"contract\": \"0x977e25619f0068a9150e2a99abebcee559133ae1\", \"contract_name\": \"ElonEffect\", \"sol_function\": \"function getSigner( bytes32 hash, bytes memory signature ) internal pure returns( address ){\\r\\n    return hash.toEthSignedMessageHash().recover( signature );\\r\\n  }\"}","{\"contract\": \"0x29ee0d92c5d9b3982173ccea98520c59a1e58046\", \"contract_name\": \"CryptoAtomica\", \"sol_function\": \"function matchAddresSigner(bytes memory signature) private view returns (bool) {\\r\\n        bytes32 hash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", keccak256(abi.encodePacked(msg.sender, SIG_WORD))));\\r\\n        return _signer == hash.recover(signature);\\r\\n    }\"}","{\"contract\": \"0xfe687ed4cd16bf383fcbd7409d33091bbadddf81\", \"contract_name\": \"GenesisNftStake\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xfe687ed4cd16bf383fcbd7409d33091bbadddf81\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x1953d641ad8b2d060cee858065c3883fe5cc7c2a\", \"contract_name\": \"SRC20\", \"sol_function\": \"function _transferToken(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value,\\r\\n        uint256 nonce,\\r\\n        uint256 expirationTime,\\r\\n        bytes32 hash,\\r\\n        bytes memory signature\\r\\n    )\\r\\n        internal returns (bool)\\r\\n    {\\r\\n        if (address(_restrictions) != address(0)) {\\r\\n            require(_restrictions.authorize(from, to, value), \\\"transferToken restrictions failed\\\");\\r\\n        }\\r\\n\\r\\n        require(now <= expirationTime, \\\"transferToken params expired\\\");\\r\\n        require(nonce == _nonce[from], \\\"transferToken params wrong nonce\\\");\\r\\n\\r\\n        (bytes32 kyaHash, string memory kyaUrl) = _assetRegistry.getKYA(address(this));\\r\\n\\r\\n        require(\\r\\n            keccak256(abi.encodePacked(kyaHash, from, to, value, nonce, expirationTime)) == hash,\\r\\n            \\\"transferToken params bad hash\\\"\\r\\n        );\\r\\n        require(_roles.isAuthority(hash.toEthSignedMessageHash().recover(signature)), \\\"transferToken params not authority\\\");\\r\\n\\r\\n        require(_features.checkTransfer(from, to), \\\"Feature transfer check\\\");\\r\\n        _transfer(from, to, value);\\r\\n\\r\\n        return true;\\r\\n    }\"}","{\"contract\": \"0x67a26f2ebdb2448605936fe9a5f496cda7941ec0\", \"contract_name\": \"BeaconInactivity\", \"sol_function\": \"function verifyClaim(\\n        SortitionPool sortitionPool,\\n        Claim calldata claim,\\n        bytes memory groupPubKey,\\n        uint256 nonce,\\n        uint32[] calldata groupMembers\\n    ) external view returns (uint32[] memory inactiveMembers) {\\n        // Validate inactive members indices. Maximum indices count is equal to\\n        // the group size and is not limited deliberately to leave a theoretical\\n        // possibility to accuse more members than `groupSize - groupThreshold`.\\n        validateMembersIndices(\\n            claim.inactiveMembersIndices,\\n            groupMembers.length\\n        );\\n\\n        // Validate signatures array is properly formed and number of\\n        // signatures and signers is correct.\\n        uint256 signaturesCount = claim.signatures.length / signatureByteSize;\\n        require(claim.signatures.length != 0, \\\"No signatures provided\\\");\\n        require(\\n            claim.signatures.length % signatureByteSize == 0,\\n            \\\"Malformed signatures array\\\"\\n        );\\n        require(\\n            signaturesCount == claim.signingMembersIndices.length,\\n            \\\"Unexpected signatures count\\\"\\n        );\\n        require(signaturesCount >= groupThreshold, \\\"Too few signatures\\\");\\n        require(signaturesCount <= groupMembers.length, \\\"Too many signatures\\\");\\n\\n        // Validate signing members indices. Note that `signingMembersIndices`\\n        // were already partially validated during `signatures` parameter\\n        // validation.\\n        validateMembersIndices(\\n            claim.signingMembersIndices,\\n            groupMembers.length\\n        );\\n\\n        // Usage of group public key and not group ID is important because it\\n        // provides uniqueness of signed messages and prevent against reusing\\n        // them in future in case some other application has a group with the\\n        // same ID and subset of members.\\n        bytes32 signedMessageHash = keccak256(\\n            abi.encode(\\n                block.chainid,\\n                nonce,\\n                groupPubKey,\\n                claim.inactiveMembersIndices\\n            )\\n        ).toEthSignedMessageHash();\\n\\n        address[] memory groupMembersAddresses = sortitionPool.getIDOperators(\\n            groupMembers\\n        );\\n\\n        // Verify each signature.\\n        bytes memory checkedSignature;\\n        bool senderSignatureExists = false;\\n        for (uint256 i = 0; i < signaturesCount; i++) {\\n            uint256 memberIndex = claim.signingMembersIndices[i];\\n            checkedSignature = claim.signatures.slice(\\n                signatureByteSize * i,\\n                signatureByteSize\\n            );\\n            address recoveredAddress = signedMessageHash.recover(\\n                checkedSignature\\n            );\\n\\n            require(\\n                groupMembersAddresses[memberIndex - 1] == recoveredAddress,\\n                \\\"Invalid signature\\\"\\n            );\\n\\n            if (!senderSignatureExists && msg.sender == recoveredAddress) {\\n                senderSignatureExists = true;\\n            }\\n        }\\n\\n        require(senderSignatureExists, \\\"Sender must be claim signer\\\");\\n\\n        inactiveMembers = new uint32[](claim.inactiveMembersIndices.length);\\n        for (uint256 i = 0; i < claim.inactiveMembersIndices.length; i++) {\\n            uint256 memberIndex = claim.inactiveMembersIndices[i];\\n            inactiveMembers[i] = groupMembers[memberIndex - 1];\\n        }\\n\\n        return inactiveMembers;\\n    }\"}","{\"contract\": \"0x7159208a705966b2b4677e7e01efb2bec8f490b5\", \"contract_name\": \"WagmiTraits\", \"sol_function\": \"function _isVerifiedSignature(bytes calldata signature)\\n    internal\\n    view\\n    returns (bool)\\n    {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                bytes32(uint256(uint160(msg.sender)))\\n            )\\n        );\\n        return ECDSAUpgradeable.recover(digest, signature) == signer;\\n    }\"}","{\"contract\": \"0x528461a346c803684ff19fa6642ef6e38c28d7d3\", \"contract_name\": \"AO2023Minter\", \"sol_function\": \"function claim(\\n    uint8 _methodId,\\n    uint16 _amount,\\n    bytes calldata _encodedParams,\\n    bytes calldata _signature\\n  ) external payable {\\n    require(tx.origin == msg.sender, \\\"Not allowed\\\");\\n    bytes32 message = keccak256(abi.encodePacked(msg.sender, address(this), _encodedParams));\\n    require(message.toEthSignedMessageHash().recover(_signature) == verifier, \\\"Invalid signature\\\");\\n    (uint8 methodId, uint16 maxPerWallet, uint16 maxPerTxn, uint32 maxSupply, uint64 startTime, uint64 endTime, uint256 price) = getClaimParams(_encodedParams);\\n\\n    uint32 totalClaimed;\\n    for (uint8 i = 0; i <= methodId; i++) {\\n      totalClaimed += claimedInfo[i].claimed;\\n    }\\n    require(methodId == _methodId, \\\"Invalid method id\\\");\\n    require(startTime <= block.timestamp && block.timestamp <= endTime, \\\"Expired\\\");\\n    require(_amount <= maxPerTxn, \\\"Exceed max per txn\\\");\\n    require(claimedInfo[methodId].claimedPerWallet[msg.sender] + _amount <= maxPerWallet, \\\"Exceed max per wallet\\\");\\n    require(totalClaimed + _amount <= maxSupply, \\\"Exceed max supply\\\");\\n    require(msg.value >= _amount * price, \\\"Ether value incorrect\\\");\\n\\n    for (uint16 i = 0; i < _amount; i++) {\\n      _mintRandomToken(msg.sender);\\n    }\\n    claimedInfo[methodId].claimedPerWallet[msg.sender] += _amount;\\n    claimedInfo[methodId].claimed += _amount;\\n  }\"}","{\"contract\": \"0xdbb5cf12408a3ac17d668037ce289f9ea75439d7\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xdbb5cf12408a3ac17d668037ce289f9ea75439d7\", \"contract_name\": \"WorldMobileToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xe876342cab4bdf5df1db99a47436f66e1cd172a6\", \"contract_name\": \"ERC20PermitUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xe876342cab4bdf5df1db99a47436f66e1cd172a6\", \"contract_name\": \"AgTokenSideChain\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xe876342cab4bdf5df1db99a47436f66e1cd172a6\", \"contract_name\": \"BaseAgTokenSideChain\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x9fbda2d403c2cd9a5cae1a5e2efd63550fd4120e\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x9fbda2d403c2cd9a5cae1a5e2efd63550fd4120e\", \"contract_name\": \"Token\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x21728dd7bc8e643667331643dc5f7e300f351e72\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x21728dd7bc8e643667331643dc5f7e300f351e72\", \"contract_name\": \"Share\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x21728dd7bc8e643667331643dc5f7e300f351e72\", \"contract_name\": \"Radao\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xada371e5ab96e3b4e818316a1ddd447ccbf8dfc4\", \"contract_name\": \"BenCoinV2\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC20PermitExpired();\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC20PermitInvalidSignature();\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xada371e5ab96e3b4e818316a1ddd447ccbf8dfc4\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC20PermitExpired();\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC20PermitInvalidSignature();\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xada371e5ab96e3b4e818316a1ddd447ccbf8dfc4\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC20PermitExpired();\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC20PermitInvalidSignature();\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xe56607c4396c546cb6a137659e42a5fd16e17cfe\", \"contract_name\": \"LibSiloPermit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        address token,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(block.timestamp <= deadline, \\\"Silo: permit expired deadline\\\");\\n        bytes32 structHash = keccak256(abi.encode(DEPOSIT_PERMIT_TYPEHASH, owner, spender, token, value, _useNonce(owner), deadline));\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"Silo: permit invalid signature\\\");\\n    }\"}","{\"contract\": \"0xe56607c4396c546cb6a137659e42a5fd16e17cfe\", \"contract_name\": \"LibSiloPermit\", \"sol_function\": \"function permits(\\n        address owner,\\n        address spender,\\n        address[] memory tokens,\\n        uint256[] memory values,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(block.timestamp <= deadline, \\\"Silo: permit expired deadline\\\");\\n        bytes32 structHash = keccak256(abi.encode(DEPOSITS_PERMIT_TYPEHASH, owner, spender, keccak256(abi.encodePacked(tokens)), keccak256(abi.encodePacked(values)), _useNonce(owner), deadline));\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"Silo: permit invalid signature\\\");\\n    }\"}","{\"contract\": \"0x9ed6960bd1bc6ad3d0f0c755b4c5d7ebd9f0ea35\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x9ed6960bd1bc6ad3d0f0c755b4c5d7ebd9f0ea35\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x9ed6960bd1bc6ad3d0f0c755b4c5d7ebd9f0ea35\", \"contract_name\": \"Ben10\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xc0101abafce0bd3de10aa1f3dd827672b150436e\", \"contract_name\": \"PoolV3\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xc0101abafce0bd3de10aa1f3dd827672b150436e\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x9d660785ad7b846354958a72d4de19abc7c35424\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x9d660785ad7b846354958a72d4de19abc7c35424\", \"contract_name\": \"PoolToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x62a83c6791a3d7950d823bb71a38e47252b6b6f4\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x62a83c6791a3d7950d823bb71a38e47252b6b6f4\", \"contract_name\": \"Asset\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x15ea0ec460a0e6847ec0aa8d50a84b3a51b95f74\", \"contract_name\": \"ERC20PermitUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x15ea0ec460a0e6847ec0aa8d50a84b3a51b95f74\", \"contract_name\": \"Token\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x2c47692823f92435b9b07f9a237daf7959ef98a3\", \"contract_name\": \"FNDNFTMarket\", \"sol_function\": \"function buyFromPrivateSaleFor(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) public payable nonReentrant {\\n    // now + 2 days cannot overflow\\n    unchecked {\\n      if (deadline < block.timestamp) {\\n        // The signed message from the seller has expired.\\n        revert NFTMarketPrivateSale_Sale_Expired();\\n      } else if (deadline > block.timestamp + 2 days) {\\n        // Private sales typically expire in 24 hours, but 2 days is used here in order to ensure\\n        // that transactions do not fail due to a minor timezone error or similar during signing.\\n\\n        // This prevents malicious actors from requesting signatures that never expire.\\n        revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();\\n      }\\n    }\\n\\n    // Cancel the buyer's offer if there is one in order to free up their FETH balance\\n    // even if they don't need the FETH for this specific purchase.\\n    _cancelSendersOffer(address(nftContract), tokenId);\\n\\n    if (amount > msg.value) {\\n      // Withdraw additional ETH required from their available FETH balance.\\n\\n      unchecked {\\n        // The if above ensures delta will not underflow\\n        feth.marketWithdrawFrom(msg.sender, amount - msg.value);\\n      }\\n    } else if (amount < msg.value) {\\n      // The terms of the sale cannot change, so if too much ETH is sent then something went wrong.\\n      revert NFTMarketPrivateSale_Too_Much_Value_Provided();\\n    }\\n\\n    // The seller must have the NFT in their wallet when this function is called,\\n    // otherwise the signature verification below will fail.\\n    address payable seller = payable(IERC721(nftContract).ownerOf(tokenId));\\n\\n    // Ensure that the offer can only be accepted once.\\n    if (privateSaleInvalidated[nftContract][tokenId][msg.sender][seller][amount][deadline]) {\\n      revert NFTMarketPrivateSale_Signature_Canceled_Or_Already_Claimed();\\n    }\\n    privateSaleInvalidated[nftContract][tokenId][msg.sender][seller][amount][deadline] = true;\\n\\n    // Scoping this block to avoid a stack too deep error\\n    {\\n      bytes32 digest = keccak256(\\n        abi.encodePacked(\\n          \\\"\\\\x19\\\\x01\\\",\\n          DOMAIN_SEPARATOR,\\n          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))\\n        )\\n      );\\n\\n      // Revert if the signature is invalid, the terms are not as expected, or if the seller transferred the NFT.\\n      if (digest.recover(v, r, s) != seller) {\\n        revert NFTMarketPrivateSale_Signature_Verification_Failed();\\n      }\\n    }\\n\\n    // This should revert if the seller has not given the market contract approval.\\n    IERC721(nftContract).transferFrom(seller, msg.sender, tokenId);\\n\\n    // Distribute revenue for this sale.\\n    (uint256 protocolFee, uint256 creatorFee, uint256 sellerRev) = _distributeFunds(\\n      nftContract,\\n      tokenId,\\n      seller,\\n      amount,\\n      payable(address(0))\\n    );\\n\\n    emit PrivateSaleFinalized(nftContract, tokenId, seller, msg.sender, protocolFee, creatorFee, sellerRev, deadline);\\n  }\"}","{\"contract\": \"0x2c47692823f92435b9b07f9a237daf7959ef98a3\", \"contract_name\": \"NFTMarketPrivateSale\", \"sol_function\": \"function buyFromPrivateSaleFor(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) public payable nonReentrant {\\n    // now + 2 days cannot overflow\\n    unchecked {\\n      if (deadline < block.timestamp) {\\n        // The signed message from the seller has expired.\\n        revert NFTMarketPrivateSale_Sale_Expired();\\n      } else if (deadline > block.timestamp + 2 days) {\\n        // Private sales typically expire in 24 hours, but 2 days is used here in order to ensure\\n        // that transactions do not fail due to a minor timezone error or similar during signing.\\n\\n        // This prevents malicious actors from requesting signatures that never expire.\\n        revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();\\n      }\\n    }\\n\\n    // Cancel the buyer's offer if there is one in order to free up their FETH balance\\n    // even if they don't need the FETH for this specific purchase.\\n    _cancelSendersOffer(address(nftContract), tokenId);\\n\\n    if (amount > msg.value) {\\n      // Withdraw additional ETH required from their available FETH balance.\\n\\n      unchecked {\\n        // The if above ensures delta will not underflow\\n        feth.marketWithdrawFrom(msg.sender, amount - msg.value);\\n      }\\n    } else if (amount < msg.value) {\\n      // The terms of the sale cannot change, so if too much ETH is sent then something went wrong.\\n      revert NFTMarketPrivateSale_Too_Much_Value_Provided();\\n    }\\n\\n    // The seller must have the NFT in their wallet when this function is called,\\n    // otherwise the signature verification below will fail.\\n    address payable seller = payable(IERC721(nftContract).ownerOf(tokenId));\\n\\n    // Ensure that the offer can only be accepted once.\\n    if (privateSaleInvalidated[nftContract][tokenId][msg.sender][seller][amount][deadline]) {\\n      revert NFTMarketPrivateSale_Signature_Canceled_Or_Already_Claimed();\\n    }\\n    privateSaleInvalidated[nftContract][tokenId][msg.sender][seller][amount][deadline] = true;\\n\\n    // Scoping this block to avoid a stack too deep error\\n    {\\n      bytes32 digest = keccak256(\\n        abi.encodePacked(\\n          \\\"\\\\x19\\\\x01\\\",\\n          DOMAIN_SEPARATOR,\\n          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))\\n        )\\n      );\\n\\n      // Revert if the signature is invalid, the terms are not as expected, or if the seller transferred the NFT.\\n      if (digest.recover(v, r, s) != seller) {\\n        revert NFTMarketPrivateSale_Signature_Verification_Failed();\\n      }\\n    }\\n\\n    // This should revert if the seller has not given the market contract approval.\\n    IERC721(nftContract).transferFrom(seller, msg.sender, tokenId);\\n\\n    // Distribute revenue for this sale.\\n    (uint256 protocolFee, uint256 creatorFee, uint256 sellerRev) = _distributeFunds(\\n      nftContract,\\n      tokenId,\\n      seller,\\n      amount,\\n      payable(address(0))\\n    );\\n\\n    emit PrivateSaleFinalized(nftContract, tokenId, seller, msg.sender, protocolFee, creatorFee, sellerRev, deadline);\\n  }\"}","{\"contract\": \"0xe640f371ce538208de46badfe4c9b4b634698b84\", \"contract_name\": \"MasterchefMasatoshiJuniorX\", \"sol_function\": \"function verifyAddressSigner(bytes32 messageHash, bytes memory signature) private view returns (bool) {\\n    return signerAddress == messageHash.toEthSignedMessageHash().recover(signature);\\n  }\"}","{\"contract\": \"0x131aebbfe55bca0c9eaad4ea24d386c5c082dd58\", \"contract_name\": \"ERC721Sale\", \"sol_function\": \"function buy(IERC721 token, uint256 tokenId, uint256 price, uint256 sellerFee, Sig memory signature) public payable {\\r\\n        address payable owner = address(uint160(token.ownerOf(tokenId)));\\r\\n        uint256 nonce = nonceHolder.getNonce(token, tokenId);\\r\\n        uint256 buyerFeeValue = price.mul(buyerFee).div(10000);\\r\\n        require(msg.value == price + buyerFeeValue, \\\"msg.value is incorrect\\\");\\r\\n        require(owner == prepareMessage(address(token), tokenId, price, sellerFee, nonce).recover(signature.v, signature.r, signature.s), \\\"owner should sign correct message\\\");\\r\\n        transferProxy.erc721safeTransferFrom(token, owner, msg.sender, tokenId);\\r\\n        transferEther(token, tokenId, owner, price, sellerFee);\\r\\n        nonceHolder.setNonce(token, tokenId, nonce + 1);\\r\\n        emit Buy(address(token), tokenId, owner, msg.sender, price, nonce + 1);\\r\\n    }\"}","{\"contract\": \"0xfcfab4ecdf2caf3c98145b6fcdac1b46760ffcb6\", \"contract_name\": \"ERC20BridgeGateway\", \"sol_function\": \"function verifySignature(bytes32 _signedMessageHash, bytes memory _sig) public view returns (bool) {\\r\\n        bytes32 ethSignedMessageHash = ECDSA.toEthSignedMessageHash(_signedMessageHash);\\r\\n        address signer = ECDSA.recover(ethSignedMessageHash, _sig);\\r\\n        return admin == signer;\\r\\n    }\"}","{\"contract\": \"0xb7a2eca93343aba7922b6fffce7f1017281c7103\", \"contract_name\": \"DiscordboundTokens\", \"sol_function\": \"function requireRecovery(\\n        address sender,\\n        uint256 nonce_,\\n        uint256 tokenId_,\\n        bytes memory signature_\\n    ) internal view {\\n        bytes32 hash = keccak256(abi.encodePacked(sender, nonce_, tokenId_));\\n        bytes32 message = ECDSA.toEthSignedMessageHash(hash);\\n\\n        require(\\n            ECDSA.recover(message, signature_) == authorizerAddress,\\n            \\\"Bad signature\\\"\\n        );\\n    }\"}","{\"contract\": \"0xb7a2eca93343aba7922b6fffce7f1017281c7103\", \"contract_name\": \"ERC1155AuthorizerV1\", \"sol_function\": \"function requireRecovery(\\n        address sender,\\n        uint256 nonce_,\\n        uint256 tokenId_,\\n        bytes memory signature_\\n    ) internal view {\\n        bytes32 hash = keccak256(abi.encodePacked(sender, nonce_, tokenId_));\\n        bytes32 message = ECDSA.toEthSignedMessageHash(hash);\\n\\n        require(\\n            ECDSA.recover(message, signature_) == authorizerAddress,\\n            \\\"Bad signature\\\"\\n        );\\n    }\"}","{\"contract\": \"0x065f006c9494541a92cb957d2ce77095f486b080\", \"contract_name\": \"SporesRegistry\", \"sol_function\": \"function addCollectionByConstructor(\\n        address _collection,\\n        address _admin,\\n        uint256 _collectionId,\\n        uint256 _maxEdition,\\n        uint256 _requestId,\\n        bytes calldata _signature\\n    ) external {\\n        //  Not neccessary to check validity of `_admin`\\n        //  Signature is provided by Verifier\\n        bytes32 _data = \\n            keccak256(\\n                abi.encodePacked(\\n                    _collectionId, _maxEdition, _requestId, _admin, address(this)\\n                )\\n            );\\n        bytes32 _msgHash = ECDSA.toEthSignedMessageHash(_data);  \\n        address _verifier = ECDSA.recover(_msgHash, _signature);\\n        _checkAuthorization(_verifier, keccak256(_signature));\\n        collections[_collection] = true;\\n    }\"}","{\"contract\": \"0x065f006c9494541a92cb957d2ce77095f486b080\", \"contract_name\": \"Signature\", \"sol_function\": \"function getSigner(bytes32 _data, bytes calldata _signature) private pure returns (address) {\\n        bytes32 _msgHash = ECDSA.toEthSignedMessageHash(_data);\\n        return ECDSA.recover(_msgHash, _signature);\\n    }\"}","{\"contract\": \"0x76b16aa88f932c309abc421f1a9e5c545ff6e28d\", \"contract_name\": \"AidSquadToken\", \"sol_function\": \"function getSigner(\\r\\n    bytes32 msgHash,\\r\\n    bytes calldata signature,\\r\\n    address[] calldata causes,\\r\\n    uint[] calldata rewards,\\r\\n    uint random\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    whenNotPaused\\r\\n    returns (address)\\r\\n  {\\r\\n    require(causes.length < __maxCausesPerBlock, tooManyCauses);\\r\\n    require(causes.length == rewards.length, arrayDymensionsDoNotMatch);\\r\\n    require(msgHash == keccak256(abi.encodePacked(causes, rewards, random, address(this))), hashDoesNotMatch);\\r\\n\\r\\n\\r\\n    bytes32 ethHash = msgHash.toEthSignedMessageHash();\\r\\n    address signer = ethHash.recover(signature);\\r\\n    return signer;\\r\\n  }\"}","{\"contract\": \"0x76b16aa88f932c309abc421f1a9e5c545ff6e28d\", \"contract_name\": \"AidSquadToken\", \"sol_function\": \"function releaseReward(\\r\\n    bytes32 msgHash,\\r\\n    bytes calldata signature,\\r\\n    address[] calldata causes,\\r\\n    uint[] calldata rewards,\\r\\n    uint random\\r\\n  )\\r\\n    external\\r\\n    whenNotPaused\\r\\n    returns (bool)\\r\\n  {\\r\\n\\r\\n    require(causes.length < __maxCausesPerBlock, tooManyCauses);\\r\\n    require(causes.length == rewards.length, arrayDymensionsDoNotMatch);\\r\\n\\r\\n    // Primero, compruebo que la firma es v\\u00e1lida\\r\\n    bytes32 ethHash = msgHash.toEthSignedMessageHash(); // Hago las parafernalias de las librer\\u00edas de web3\\r\\n    address signer = ethHash.recover(signature); // Compruebo firma\\r\\n    require(signer == owner(), signatureIsNotValid);\\r\\n\\r\\n    require(msgHash == keccak256(abi.encodePacked(causes, rewards, random, address(this))), hashDoesNotMatch);\\r\\n    require(!usedHashes[msgHash], hashAlreadyUsed);\\r\\n    usedHashes[msgHash] = true;\\r\\n\\r\\n    for(uint i = 0; i < causes.length; i++) {\\r\\n      ERC777PullPayment.increaseBalance(causes[i], rewards[i]);\\r\\n    }\\r\\n\\r\\n    emit RewardEmitted(msg.sender, msgHash, signature, causes, rewards, random);\\r\\n\\r\\n    return true;\\r\\n  }\"}","{\"contract\": \"0x76b16aa88f932c309abc421f1a9e5c545ff6e28d\", \"contract_name\": \"AidSquadToken\", \"sol_function\": \"function isSignedBy(\\r\\n      address signer,\\r\\n      bytes32 msgHash,\\r\\n      bytes calldata signature\\r\\n  )\\r\\n      external\\r\\n      pure\\r\\n      returns (bool)\\r\\n  {\\r\\n      bytes32 ethHash = msgHash.toEthSignedMessageHash();\\r\\n      return (ethHash.recover(signature) == signer);\\r\\n  }\"}","{\"contract\": \"0xfe4ad9ec15f816648d30296f48f16cf90c368aa0\", \"contract_name\": \"Marketplace\", \"sol_function\": \"function _getSigner(\\n        Order memory _order,\\n        bytes memory _signature\\n    ) private view returns (address) {\\n        bytes32 digest = _hashTypedDataV4(\\n            keccak256(\\n                abi.encode(\\n                    _ORDER_TYPEHASH,\\n                    _order.seller,\\n                    _order.nftAddress,\\n                    _order.nftId,\\n                    _order.expiryTime,\\n                    keccak256(abi.encodePacked(_order.paymentTokenAddresses)),\\n                    keccak256(abi.encodePacked(_order.paymentTokenAmounts)),\\n                    keccak256(abi.encodePacked(_order.voucherCode))\\n                )\\n            )\\n        );\\n        address signer = ECDSAUpgradeable.recover(digest, _signature);\\n        return signer;\\n    }\"}","{\"contract\": \"0x197c3c38eb9fc75da2f6b7646480034501dbfc4f\", \"contract_name\": \"Governor\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x197c3c38eb9fc75da2f6b7646480034501dbfc4f\", \"contract_name\": \"Governor\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x197c3c38eb9fc75da2f6b7646480034501dbfc4f\", \"contract_name\": \"GovernorCountingSimple\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x197c3c38eb9fc75da2f6b7646480034501dbfc4f\", \"contract_name\": \"GovernorCountingSimple\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x197c3c38eb9fc75da2f6b7646480034501dbfc4f\", \"contract_name\": \"GovernorSettings\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x197c3c38eb9fc75da2f6b7646480034501dbfc4f\", \"contract_name\": \"GovernorSettings\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x197c3c38eb9fc75da2f6b7646480034501dbfc4f\", \"contract_name\": \"GovernorTimelockControl\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x197c3c38eb9fc75da2f6b7646480034501dbfc4f\", \"contract_name\": \"GovernorTimelockControl\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x197c3c38eb9fc75da2f6b7646480034501dbfc4f\", \"contract_name\": \"GovernorVotes\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x197c3c38eb9fc75da2f6b7646480034501dbfc4f\", \"contract_name\": \"GovernorVotes\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x197c3c38eb9fc75da2f6b7646480034501dbfc4f\", \"contract_name\": \"GovernorVotesQuorumFraction\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x197c3c38eb9fc75da2f6b7646480034501dbfc4f\", \"contract_name\": \"GovernorVotesQuorumFraction\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x197c3c38eb9fc75da2f6b7646480034501dbfc4f\", \"contract_name\": \"Governance\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x197c3c38eb9fc75da2f6b7646480034501dbfc4f\", \"contract_name\": \"Governance\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x94b18006fbad07304ab3b2ebbdf3c96ac0fa9d05\", \"contract_name\": \"NeighborheadzNFT\", \"sol_function\": \"function _mintNFT(uint256 salt, bytes memory sig) internal {\\n        require(UNIT_PRICE <= msg.value, \\\"NBHZ: Invalid amount\\\");\\n        require(_tokenIndex < _totalSupply, \\\"NBHZ: Reach total supply\\\");\\n\\n        bytes32 _verifiedHash = keccak256(abi.encodePacked(msg.sender, salt));\\n        require(!finalized[_verifiedHash], \\\"NBHZ: Salt used\\\");\\n        require(_verifiers[_verifiedHash.toEthSignedMessageHash().recover(sig)], \\\"NBHZ: Unauthorized\\\");\\n        \\n        finalized[_verifiedHash] = true;\\n        Address.sendValue(_fundRecipient, msg.value);\\n        _tokenIndex++;\\n        _mint(msg.sender, _tokenIndex);\\n    }\"}","{\"contract\": \"0x46951040588131aa132d5b38f8c662247199a837\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x46951040588131aa132d5b38f8c662247199a837\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x46951040588131aa132d5b38f8c662247199a837\", \"contract_name\": \"FUCKTWITTER\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x50dc8adb60228a4c0200e8ae7e46d57dcb1d8390\", \"contract_name\": \"TheGardenbySanho\", \"sol_function\": \"function changeTokenAttribute(\\n        uint256 tokenId, \\n        string memory attrName,\\n        string memory attrValueStr,\\n        string memory changeMessage, \\n        bytes memory signature\\n    ) public onlyOwner {\\n        address tokenOwner = ownerOf(tokenId);\\n        bytes32 messageHash = toEthSignedMessageHash(bytes(changeMessage));\\n        address messageSigner = ECDSA.recover(messageHash, signature);\\n        require(tokenOwner == messageSigner, \\\"Token property change message must be signed by token owner!\\\");\\n\\n        uint256 newTokenId = _tokenIdCounter.current();\\n        _burn(tokenId);\\n        _safeMint(tokenOwner, newTokenId);\\n        _tokenIdCounter.increment();\\n\\n        emit ApprovedAttributeChange(tokenId, newTokenId, attrName, attrValueStr);\\n    }\"}","{\"contract\": \"0x4df63ae8143014a8dff2c5e3e76b81379bdc0380\", \"contract_name\": \"ArtistCreator\", \"sol_function\": \"function getSigner(bytes calldata signature) public view returns (address) {\\n        require(admin != address(0), 'whitelist not enabled');\\n        // Verify EIP-712 signature by recreating the data structure\\n        // that we signed on the client side, and then using that to recover\\n        // the address that signed the signature for this data.\\n        bytes32 digest = keccak256(\\n            abi.encodePacked('\\\\x19\\\\x01', DOMAIN_SEPARATOR, keccak256(abi.encode(MINTER_TYPEHASH, msg.sender)))\\n        );\\n        // Use the recover method to see what address was used to create\\n        // the signature on this data.\\n        // Note that if the digest doesn't exactly match what was signed we'll\\n        // get a random recovered address.\\n        address recoveredAddress = digest.recover(signature);\\n        return recoveredAddress;\\n    }\"}","{\"contract\": \"0x050b174994feadb8342abe5134afe48e9f25bc2b\", \"contract_name\": \"ERC20PermitUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x050b174994feadb8342abe5134afe48e9f25bc2b\", \"contract_name\": \"MBA\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x609aa0dbb59606a9f51133c4f5f2a83d88267d73\", \"contract_name\": \"StandardArbERC20\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x609aa0dbb59606a9f51133c4f5f2a83d88267d73\", \"contract_name\": \"L2GatewayToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x609aa0dbb59606a9f51133c4f5f2a83d88267d73\", \"contract_name\": \"aeERC20\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x609aa0dbb59606a9f51133c4f5f2a83d88267d73\", \"contract_name\": \"aeWETH\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x609aa0dbb59606a9f51133c4f5f2a83d88267d73\", \"contract_name\": \"ERC20PermitUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x4a5ad53ed70357961e58faf304ccfd06180d2c30\", \"contract_name\": \"FairXYZDeployer\", \"sol_function\": \"function changeURI(\\n        bytes memory signature,\\n        string memory newPathURI,\\n        string memory newURI\\n    ) external {\\n        if (!hasRole(SECOND_ADMIN_ROLE, msg.sender)) revert UnauthorisedUser();\\n\\n        // URI cannot be modified if it has been locked\\n        if (lockURI) revert AlreadyLockedURI();\\n\\n        bytes32 messageHash = hashURIChange(msg.sender, newPathURI, newURI);\\n\\n        if (messageHash.recover(signature) != FairxyzSignerAddress)\\n            revert UnrecognizableHash();\\n\\n        if (bytes(newPathURI).length != 0) {\\n            pathURI = newPathURI;\\n            emit NewPathURI(pathURI);\\n        }\\n        if (bytes(newURI).length != 0) {\\n            _overrideURI = newURI;\\n            baseURI = \\\"\\\";\\n            emit NewTokenURI(_overrideURI);\\n        }\\n    }\"}","{\"contract\": \"0x4a5ad53ed70357961e58faf304ccfd06180d2c30\", \"contract_name\": \"FairXYZDeployer\", \"sol_function\": \"function mint(\\n        bytes memory signature,\\n        uint256 nonce,\\n        uint256 numberOfTokens,\\n        uint256 maxMintsPerWallet,\\n        address recipient\\n    ) external payable {\\n        // At least 1 and no more than 20 tokens can be minted per transaction\\n        if (!((0 < numberOfTokens) && (numberOfTokens <= 20)))\\n            revert TokenLimitPerTx();\\n\\n        // Check the active stage - reverts if no stage is active\\n        uint256 presentStage = viewCurrentStage();\\n\\n        // Load the minting parameters for this stage\\n        StageData memory dropData = stageMap[presentStage];\\n\\n        // Check that enough ETH is sent for the minting quantity\\n        uint256 costPerToken = dropData.price + FairxyzMintFee;\\n        if (msg.value != costPerToken * numberOfTokens) revert NotEnoughETH();\\n\\n        // Nonce = 0 is reserved for airdrop mints, to distinguish them from other mints in the\\n        // _mint function on ERC721xyzUpgradeable\\n        if (nonce == 0) revert InvalidNonce();\\n\\n        uint256 currentMintedTokens = _mintedTokens;\\n\\n        // The number of minted tokens cannot exceed the number of NFTs on sale for this stage\\n        if (currentMintedTokens >= dropData.phaseLimit) revert PhaseLimitEnd();\\n\\n        // If a Merkle Root is defined for the stage, then this is an allowlist stage. Thus the function merkleMint\\n        // must be used instead\\n        if (dropData.merkleRoot != bytes32(0)) revert MerkleStage();\\n\\n        // If the contract is released from signature minting, skips this signature verification\\n        if (!signatureReleased) {\\n            // Hash the variables\\n            bytes32 messageHash = hashMintParams(\\n                recipient,\\n                numberOfTokens,\\n                nonce,\\n                maxMintsPerWallet\\n            );\\n\\n            // Ensure the recovered address from the signature is the Fair.xyz signer address\\n            if (messageHash.recover(signature) != FairxyzSignerAddress)\\n                revert UnrecognizableHash();\\n\\n            // mintData[recipient].blockNumber is the last block (nonce) that was used to mint from the given address.\\n            // Nonces can only increase in number in each transaction, and are part of the signature. This ensures\\n            // that past signatures are not reused\\n            if (mintData[recipient].blockNumber >= nonce) revert ReusedHash();\\n\\n            // Set a time limit of 40 blocks for the signature\\n            if (block.number > nonce + 40) revert TimeLimit();\\n        }\\n\\n        uint256 adjustedNumberOfTokens = handleReimbursement(\\n            recipient,\\n            presentStage,\\n            numberOfTokens,\\n            currentMintedTokens,\\n            dropData,\\n            maxMintsPerWallet\\n        );\\n\\n        // Mint the NFTs\\n        _safeMint(recipient, adjustedNumberOfTokens, nonce);\\n\\n        (bool feeSent, ) = FairxyzReceiverAddress.call{\\n            value: (FairxyzMintFee * adjustedNumberOfTokens)\\n        }(\\\"\\\");\\n        if (!feeSent) revert ETHSendFail();\\n\\n        // If the value for numberOfTokens is less than the origMintCount, then there is reimbursement\\n        // to be done\\n        if (adjustedNumberOfTokens < numberOfTokens) {\\n            uint256 reimbursementPrice = (numberOfTokens -\\n                adjustedNumberOfTokens) * costPerToken;\\n            (bool sent, ) = msg.sender.call{value: reimbursementPrice}(\\\"\\\");\\n            if (!sent) revert ETHSendFail();\\n        }\\n\\n        emit Mint(recipient, presentStage, adjustedNumberOfTokens);\\n    }\"}","{\"contract\": \"0xba52e1530a6dfcbfe15a04c638071ddf29fb9b74\", \"contract_name\": \"RelayingUtils\", \"sol_function\": \"function recoverSigner(RelayedMessage memory message, bytes memory signature) internal pure returns (address) {\\r\\n        return ECDSA.recover(signingHash(message), signature);\\r\\n    }\"}","{\"contract\": \"0xba52e1530a6dfcbfe15a04c638071ddf29fb9b74\", \"contract_name\": \"RelayingUtils\", \"sol_function\": \"function recoverSigner(RelayedTransfer memory transfer, bytes memory signature) internal pure returns (address) {\\r\\n        return ECDSA.recover(signingHash(transfer), signature);\\r\\n    }\"}","{\"contract\": \"0x7f75dc4eb9d41c907eb1fc6c9b4fbbc2c5580bf5\", \"contract_name\": \"SignatureChecker\", \"sol_function\": \"function isValidSignature(\\r\\n        address signer,\\r\\n        bytes32 hash,\\r\\n        bytes memory signature\\r\\n    ) internal view returns (bool) {\\r\\n        if (Address.isContract(signer)) {\\r\\n            bytes4 selector = IERC1271.isValidSignature.selector;\\r\\n            (bool success, bytes memory returndata) =\\r\\n                signer.staticcall(abi.encodeWithSelector(selector, hash, signature));\\r\\n            return success && abi.decode(returndata, (bytes4)) == selector;\\r\\n        } else {\\r\\n            return ECDSA.recover(hash, signature) == signer;\\r\\n        }\\r\\n    }\"}","{\"contract\": \"0x9381847441d896cbf273c78dc075eae7d575653e\", \"contract_name\": \"LPStakingV4\", \"sol_function\": \"function _verify(\\n        address _staker, // staker address\\n        uint256 _tokenId, // NFt id\\n        uint256 _amountUSD, // liquity amount in USD\\n        uint256 _ETHUSD, // 1 ethereum price\\n        uint256 _mpwrUSD,\\n        uint256 _totalLpStaked,\\n        bytes memory _signature // signature\\n    ) public view returns (bool) {\\n        bytes32 signedHash = keccak256(\\n            abi.encodePacked(_staker, NAME_HASH, _tokenId, _amountUSD, _ETHUSD, _mpwrUSD, _totalLpStaked)\\n        );\\n        bytes32 messageHash = signedHash.toEthSignedMessageHash();\\n        address messageSender = messageHash.recover(_signature);\\n        return messageSender == validator;\\n    }\"}","{\"contract\": \"0x79b00c4b7c73519c8ae319bd98c16109531570ca\", \"contract_name\": \"OrderState\", \"sol_function\": \"function validateOrderSignature(Order memory order, Sig memory sig)\\r\\n        internal\\r\\n        view\\r\\n    {\\r\\n        require(completed[getCompletedKey(order)] != true, \\\"Signature exist\\\");\\r\\n        if (sig.v == 0 && sig.r == bytes32(0x0) && sig.s == bytes32(0x0)) {\\r\\n            revert(\\\"incorrect signature\\\");\\r\\n        } else {\\r\\n            require(\\r\\n                prepareOrderHash(order).recover(sig.v, sig.r, sig.s) ==\\r\\n                    order.key.owner,\\r\\n                \\\"Incorrect signature\\\"\\r\\n            );\\r\\n        }\\r\\n    }\"}","{\"contract\": \"0x79b00c4b7c73519c8ae319bd98c16109531570ca\", \"contract_name\": \"OrderState\", \"sol_function\": \"function validateOrderSignatureView(Order memory order, Sig memory sig)\\r\\n        public\\r\\n        view \\r\\n        returns (address)\\r\\n    {\\r\\n        require(completed[getCompletedKey(order)] != true, \\\"Signature exist\\\");\\r\\n        if (sig.v == 0 && sig.r == bytes32(0x0) && sig.s == bytes32(0x0)) {\\r\\n            revert(\\\"Incorrect signature\\\");\\r\\n        } else {\\r\\n              return prepareOrderHash(order).recover(sig.v, sig.r, sig.s);\\r\\n        }\\r\\n    }\"}","{\"contract\": \"0x79b00c4b7c73519c8ae319bd98c16109531570ca\", \"contract_name\": \"OrderState\", \"sol_function\": \"function validateBidOrderSignature(\\r\\n        Order memory order,\\r\\n        Sig memory sig,\\r\\n        address bidder,\\r\\n        uint256 buyingAmount\\r\\n    ) internal view {\\r\\n        require(\\r\\n            completed[getBidOrderCompletedKey(order, bidder, buyingAmount)] !=\\r\\n                true,\\r\\n            \\\"Signature exist\\\"\\r\\n        );\\r\\n        if (sig.v == 0 && sig.r == bytes32(0x0) && sig.s == bytes32(0x0)) {\\r\\n            revert(\\\"Incorrect bid signature\\\");\\r\\n        } else {\\r\\n            require(\\r\\n                prepareBidOrderHash(order, bidder, buyingAmount).recover(\\r\\n                    sig.v,\\r\\n                    sig.r,\\r\\n                    sig.s\\r\\n                ) == bidder,\\r\\n                \\\"Incorrect bid signature\\\"\\r\\n            );\\r\\n        }\\r\\n    }\"}","{\"contract\": \"0x79b00c4b7c73519c8ae319bd98c16109531570ca\", \"contract_name\": \"OrderState\", \"sol_function\": \"function validateBidOrderSignatureView(\\r\\n        Order memory order,\\r\\n        Sig memory sig,\\r\\n        address bidder,\\r\\n        uint256 buyingAmount\\r\\n    ) public view returns (address) {\\r\\n        require(completed[getCompletedKey(order)] != true, \\\"Signature exist\\\");\\r\\n        if (sig.v == 0 && sig.r == bytes32(0x0) && sig.s == bytes32(0x0)) {\\r\\n            revert(\\\"Incorrect bid signature\\\");\\r\\n        } else {\\r\\n                return prepareBidOrderHash(order, bidder, buyingAmount).recover(\\r\\n                    sig.v,\\r\\n                    sig.r,\\r\\n                    sig.s\\r\\n                );\\r\\n        }\\r\\n    }\"}","{\"contract\": \"0x79b00c4b7c73519c8ae319bd98c16109531570ca\", \"contract_name\": \"Exchange\", \"sol_function\": \"function validateOrderSignature(Order memory order, Sig memory sig)\\r\\n        internal\\r\\n        view\\r\\n    {\\r\\n        require(completed[getCompletedKey(order)] != true, \\\"Signature exist\\\");\\r\\n        if (sig.v == 0 && sig.r == bytes32(0x0) && sig.s == bytes32(0x0)) {\\r\\n            revert(\\\"incorrect signature\\\");\\r\\n        } else {\\r\\n            require(\\r\\n                prepareOrderHash(order).recover(sig.v, sig.r, sig.s) ==\\r\\n                    order.key.owner,\\r\\n                \\\"Incorrect signature\\\"\\r\\n            );\\r\\n        }\\r\\n    }\"}","{\"contract\": \"0x79b00c4b7c73519c8ae319bd98c16109531570ca\", \"contract_name\": \"Exchange\", \"sol_function\": \"function validateOrderSignatureView(Order memory order, Sig memory sig)\\r\\n        public\\r\\n        view \\r\\n        returns (address)\\r\\n    {\\r\\n        require(completed[getCompletedKey(order)] != true, \\\"Signature exist\\\");\\r\\n        if (sig.v == 0 && sig.r == bytes32(0x0) && sig.s == bytes32(0x0)) {\\r\\n            revert(\\\"Incorrect signature\\\");\\r\\n        } else {\\r\\n              return prepareOrderHash(order).recover(sig.v, sig.r, sig.s);\\r\\n        }\\r\\n    }\"}","{\"contract\": \"0x79b00c4b7c73519c8ae319bd98c16109531570ca\", \"contract_name\": \"Exchange\", \"sol_function\": \"function validateBidOrderSignature(\\r\\n        Order memory order,\\r\\n        Sig memory sig,\\r\\n        address bidder,\\r\\n        uint256 buyingAmount\\r\\n    ) internal view {\\r\\n        require(\\r\\n            completed[getBidOrderCompletedKey(order, bidder, buyingAmount)] !=\\r\\n                true,\\r\\n            \\\"Signature exist\\\"\\r\\n        );\\r\\n        if (sig.v == 0 && sig.r == bytes32(0x0) && sig.s == bytes32(0x0)) {\\r\\n            revert(\\\"Incorrect bid signature\\\");\\r\\n        } else {\\r\\n            require(\\r\\n                prepareBidOrderHash(order, bidder, buyingAmount).recover(\\r\\n                    sig.v,\\r\\n                    sig.r,\\r\\n                    sig.s\\r\\n                ) == bidder,\\r\\n                \\\"Incorrect bid signature\\\"\\r\\n            );\\r\\n        }\\r\\n    }\"}","{\"contract\": \"0x79b00c4b7c73519c8ae319bd98c16109531570ca\", \"contract_name\": \"Exchange\", \"sol_function\": \"function validateBidOrderSignatureView(\\r\\n        Order memory order,\\r\\n        Sig memory sig,\\r\\n        address bidder,\\r\\n        uint256 buyingAmount\\r\\n    ) public view returns (address) {\\r\\n        require(completed[getCompletedKey(order)] != true, \\\"Signature exist\\\");\\r\\n        if (sig.v == 0 && sig.r == bytes32(0x0) && sig.s == bytes32(0x0)) {\\r\\n            revert(\\\"Incorrect bid signature\\\");\\r\\n        } else {\\r\\n                return prepareBidOrderHash(order, bidder, buyingAmount).recover(\\r\\n                    sig.v,\\r\\n                    sig.r,\\r\\n                    sig.s\\r\\n                );\\r\\n        }\\r\\n    }\"}","{\"contract\": \"0x79b00c4b7c73519c8ae319bd98c16109531570ca\", \"contract_name\": \"Exchange\", \"sol_function\": \"function validateBuyerFeeSig(\\r\\n        Order memory order,\\r\\n        uint256 buyerFee,\\r\\n        address royaltyReceipt,\\r\\n        Sig memory sig\\r\\n    ) internal view {\\r\\n        require(\\r\\n            prepareBuyerFeeMessage(order, buyerFee, royaltyReceipt).recover(\\r\\n                sig.v,\\r\\n                sig.r,\\r\\n                sig.s\\r\\n            ) == buyerFeeSigner,\\r\\n            \\\"Incorrect buyer fee signature\\\"\\r\\n        );\\r\\n    }\"}","{\"contract\": \"0x79b00c4b7c73519c8ae319bd98c16109531570ca\", \"contract_name\": \"Exchange\", \"sol_function\": \"function validateBuyerFeeSigView(\\r\\n        Order memory order,\\r\\n        uint256 buyerFee,\\r\\n        address royaltyReceipt,\\r\\n        Sig memory sig\\r\\n    ) public pure returns (address) {\\r\\n            return prepareBuyerFeeMessage(order, buyerFee, royaltyReceipt).recover(\\r\\n                sig.v,\\r\\n                sig.r,\\r\\n                sig.s\\r\\n            ); \\r\\n    }\"}","{\"contract\": \"0x79b00c4b7c73519c8ae319bd98c16109531570ca\", \"contract_name\": \"Exchange\", \"sol_function\": \"function toEthSignedMessageHash(bytes32 hash, Sig memory sig)\\r\\n        public\\r\\n        pure\\r\\n        returns (address signer)\\r\\n    {\\r\\n        signer = hash.recover(sig.v, sig.r, sig.s);\\r\\n    }\"}","{\"contract\": \"0x95f3a99b53ee4dae43ce8eacdf41ba7a05fe10db\", \"contract_name\": \"FiatMintable\", \"sol_function\": \"function verifySignature(bytes memory signature, bytes32 transactionHash) private view returns (bool) {\\n    address signer = transactionHash.toEthSignedMessageHash().recover(signature);\\n    return owner() == signer;\\n  }\"}","{\"contract\": \"0x95f3a99b53ee4dae43ce8eacdf41ba7a05fe10db\", \"contract_name\": \"GCDSWirdos\", \"sol_function\": \"function verifySignature(bytes memory signature, bytes32 transactionHash) private view returns (bool) {\\n    address signer = transactionHash.toEthSignedMessageHash().recover(signature);\\n    return owner() == signer;\\n  }\"}","{\"contract\": \"0x348f0b5c3d9613bf2836a0079e939ed25db7be37\", \"contract_name\": \"CyberFriends\", \"sol_function\": \"function _checkSig(address _wallet, bytes memory _signature) private view returns(bool) {\\r\\n        return ECDSA.recover(\\r\\n            ECDSA.toEthSignedMessageHash(keccak256(abi.encodePacked(_wallet))),\\r\\n            _signature\\r\\n        ) == owner();\\r\\n    }\"}","{\"contract\": \"0x3dbeb76d9d9444d7db9dcf3799e17acd247f8fac\", \"contract_name\": \"SmartAccount\", \"sol_function\": \"function isValidSignature(\\n        bytes32 _hash,\\n        bytes calldata _signature\\n    ) external view returns (bytes4) {\\n        if (isOwner(ECDSA.recover(_hash, _signature))) {\\n            return 0x1626ba7e;\\n        } else {\\n            return 0xffffffff;\\n        }\\n    }\"}","{\"contract\": \"0x3dbeb76d9d9444d7db9dcf3799e17acd247f8fac\", \"contract_name\": \"SignatureManager\", \"sol_function\": \"function validateUserOp(\\n        UserOperation calldata userOp,\\n        bytes32,\\n        address,\\n        uint256 missingAccountFunds\\n    ) public virtual returns (uint256) {\\n        if (missingAccountFunds != 0) {\\n            payable(msg.sender).call{\\n                value: missingAccountFunds,\\n                gas: type(uint256).max\\n            }(\\\"\\\");\\n        }\\n\\n        unchecked {\\n            if (userOp.nonce != nonce++) {\\n                return NONCE_VALIDATION_FAILED;\\n            }\\n        }\\n\\n        if (\\n            ECDSA.recover(\\n                getUOPSignedHash(\\n                    SignatureType(uint8(bytes1(userOp.signature[0:1]))),\\n                    msg.sender,\\n                    userOp\\n                ),\\n                userOp.signature[33:]\\n            ) != owner\\n        ) {\\n            return SIG_VALIDATION_FAILED;\\n        } else {\\n            return uint256(bytes32(userOp.signature[1:33]));\\n        }\\n    }\"}","{\"contract\": \"0x3dbeb76d9d9444d7db9dcf3799e17acd247f8fac\", \"contract_name\": \"SignatureManager\", \"sol_function\": \"function validateUserOpWithoutSig(\\n        UserOperation calldata userOp,\\n        bytes32,\\n        address,\\n        uint256 missingAccountFunds\\n    ) public virtual returns (uint256) {\\n        if (missingAccountFunds != 0) {\\n            payable(msg.sender).call{\\n                value: missingAccountFunds,\\n                gas: type(uint256).max\\n            }(\\\"\\\");\\n        }\\n\\n        unchecked {\\n            if (userOp.nonce != nonce++) {\\n                return NONCE_VALIDATION_FAILED;\\n            }\\n        }\\n\\n        if (\\n            ECDSA.recover(\\n                getUOPSignedHash(\\n                    SignatureType(uint8(bytes1(userOp.signature[0:1]))),\\n                    msg.sender,\\n                    userOp\\n                ),\\n                userOp.signature[33:]\\n            ) != owner\\n        ) {\\n            return uint256(bytes32(userOp.signature[1:33]));\\n        } else {\\n            return uint256(bytes32(userOp.signature[1:33]));\\n        }\\n    }\"}","{\"contract\": \"0x3dbeb76d9d9444d7db9dcf3799e17acd247f8fac\", \"contract_name\": \"SignatureManager\", \"sol_function\": \"function isValidSignature(\\n        bytes32 _hash,\\n        bytes calldata _signature\\n    ) external view returns (bytes4) {\\n        if (isOwner(ECDSA.recover(_hash, _signature))) {\\n            return 0x1626ba7e;\\n        } else {\\n            return 0xffffffff;\\n        }\\n    }\"}","{\"contract\": \"0xa12ba2d89a16f57c4b714b03c7951c41c7695502\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xa12ba2d89a16f57c4b714b03c7951c41c7695502\", \"contract_name\": \"Asset\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xa12ba2d89a16f57c4b714b03c7951c41c7695502\", \"contract_name\": \"DynamicAsset\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xa12ba2d89a16f57c4b714b03c7951c41c7695502\", \"contract_name\": \"WstETHAsset_Mainnet\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x55e4e0916babaf9853f57e9d3e80488a5155dd67\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x55e4e0916babaf9853f57e9d3e80488a5155dd67\", \"contract_name\": \"BlackCat\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xd993778fcd8273fa84644bee9b9c3cb9cc92b15b\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xd993778fcd8273fa84644bee9b9c3cb9cc92b15b\", \"contract_name\": \"BToken\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xe88bd78d1dab2a63df6e41bc44e738a373c3805e\", \"contract_name\": \"ETHWalkersMiami\", \"sol_function\": \"function allowlistETHWalkersMiami(uint8 numberOfTokens, uint index, bytes memory signature) external payable whenNotPaused {\\n        require(block.timestamp >= allowListSale && block.timestamp <= endSale, \\\"Allowlist-sale must be started\\\");\\n        require(numberMinted[_msgSender()] + numberOfTokens <= maxMiamiMint, \\\"Exceeds maximum per wallet\\\");\\n        require(msg.value >= _MiamiPrice.mul(numberOfTokens), \\\"Ether value is incorrect. Check and try again\\\");\\n        require(!isContract(_msgSender()), \\\"I fight for the user! No contracts\\\");\\n        require(totalSupply().add(numberOfTokens) <= totalSupplyMiami, \\\"Purchase exceeds max supply of ETH Walkers\\\");\\n\\n        // verify signature\\n        bytes32 digest = getDigest(index);\\n        address claimSigner = ECDSA.recover(digest, signature);\\n        require(claimSigner == whitelistSigner, \\\"Invalid Message Signer.\\\");\\n\\n        _mint(_msgSender(), numberOfTokens);\\n        numberMinted[_msgSender()] += numberOfTokens;\\n\\n        (bool sent, ) = payoutsAddress.call{value: address(this).balance}(\\\"\\\");\\n        require(sent, \\\"Something wrong with payoutsAddress\\\");\\n    }\"}","{\"contract\": \"0xe88bd78d1dab2a63df6e41bc44e738a373c3805e\", \"contract_name\": \"ETHWalkersMiami\", \"sol_function\": \"function mintS1PlayerFreeMints(uint freemints, bytes memory signature, bool isSurvivor) external whenNotPaused {\\n        require(block.timestamp >= allowListSale && block.timestamp <= endSale, \\\"Pre-sale must be started\\\");\\n        require(!isContract(_msgSender()), \\\"I fight for the user! No contracts\\\");\\n\\n        // verify signature\\n        bytes32 digest = getDigest(freemints);\\n        address claimSigner = ECDSA.recover(digest, signature);\\n        if(isSurvivor){\\n            require(numberMintedS1Survivor[_msgSender()] < freemints, \\\"Exceeds maximum per wallet\\\");\\n            require(claimSigner == S1SurvivorSigner, \\\"Invalid Message Signer.\\\");\\n            _mint(_msgSender(), freemints);\\n            numberMintedS1Survivor[_msgSender()] += freemints;\\n        }\\n        else {\\n            require(numberMintedS1Player[_msgSender()] < freemints, \\\"Exceeds maximum per wallet\\\");\\n            require(claimSigner == S1PlayerSigner, \\\"Invalid Message Signer.\\\");\\n            _mint(_msgSender(), freemints);\\n            numberMintedS1Player[_msgSender()] += freemints;\\n        }\\n    }\"}","{\"contract\": \"0xe88bd78d1dab2a63df6e41bc44e738a373c3805e\", \"contract_name\": \"FreeAndFriendsMint\", \"sol_function\": \"function friendsAndFreeETHWalkersMiamiMint(uint8 numberOfTokens, uint maxMints, bytes memory signature) external whenNotPaused {\\n        require(friendsMintLive, \\\"Free mint must be started\\\");\\n        require(numberMinted[_msgSender()] + numberOfTokens <= maxMints, \\\"Exceeds maximum per wallet\\\");\\n        require(!isContract(_msgSender()), \\\"I fight for the user! No contracts\\\");\\n        require(ewalk.totalSupply().add(numberOfTokens) <= ewalk.totalSupplyMiami(), \\\"Purchase exceeds max supply of ETH Walkers\\\");\\n\\n        // verify signature\\n        bytes32 digest = getDigest(maxMints);\\n        address claimSigner = ECDSA.recover(digest, signature);\\n        require(claimSigner == whitelistSigner, \\\"Invalid Message Signer.\\\");\\n\\n        ewalk.controllerMint(_msgSender(), numberOfTokens);\\n        numberMinted[_msgSender()] += numberOfTokens;\\n    }\"}","{\"contract\": \"0xd812eede3aee33db80bad446e085ef6e9d2f02c6\", \"contract_name\": \"SignatureVerification\", \"sol_function\": \"function requireValidSignature(\\n        bytes memory data,\\n        bytes memory signature,\\n        address signerAddress\\n    ) internal pure {\\n        require(\\n            signerAddress != address(0),\\n            \\\"verification address not initialized\\\"\\n        );\\n\\n        require(\\n            keccak256(data).toEthSignedMessageHash().recover(signature) == signerAddress,\\n            \\\"signature invalid\\\"\\n        );\\n    }\"}","{\"contract\": \"0x80336ad7a747236ef41f47ed2c7641828a480baa\", \"contract_name\": \"Chimpers\", \"sol_function\": \"function _validatePurchaseRequest(bytes32 message, bytes calldata signature, string calldata nonce) internal virtual { \\n        // Verify nonce usage/re-use\\n        bytes32 nonceBytes32 = _getNonceBytes32(nonce);\\n        require(!_usedNonces[nonceBytes32], \\\"Cannot replay transaction\\\");\\n        // Verify valid message based on input variables\\n        bytes32 expectedMessage = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", (20+bytes(nonce).length).toString(), msg.sender, nonce));\\n        require(message == expectedMessage, \\\"Malformed message\\\");\\n        // Verify signature was performed by the expected signing address\\n        address signer = message.recover(signature);\\n        require(signer == _signingAddress, \\\"Invalid signature\\\");\\n\\n        _usedNonces[nonceBytes32] = true;\\n    }\"}","{\"contract\": \"0x80336ad7a747236ef41f47ed2c7641828a480baa\", \"contract_name\": \"Chimpers\", \"sol_function\": \"function _validatePurchaseRequestWithAmount(bytes32 message, bytes calldata signature, string calldata nonce, uint16 amount) internal virtual {\\n        // Verify nonce usage/re-use\\n        bytes32 nonceBytes32 = _getNonceBytes32(nonce);\\n        require(!_usedNonces[nonceBytes32], \\\"Cannot replay transaction\\\");\\n        // Verify valid message based on input variables\\n        bytes32 expectedMessage = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", (20+bytes(nonce).length+bytes(uint256(amount).toString()).length).toString(), msg.sender, nonce, uint256(amount).toString()));\\n        require(message == expectedMessage, \\\"Malformed message\\\");\\n        // Verify signature was performed by the expected signing address\\n        address signer = message.recover(signature);\\n        require(signer == _signingAddress, \\\"Invalid signature\\\");\\n\\n        _usedNonces[nonceBytes32] = true;\\n    }\"}","{\"contract\": \"0x80336ad7a747236ef41f47ed2c7641828a480baa\", \"contract_name\": \"CollectionBase\", \"sol_function\": \"function _validatePurchaseRequest(bytes32 message, bytes calldata signature, string calldata nonce) internal virtual { \\n        // Verify nonce usage/re-use\\n        bytes32 nonceBytes32 = _getNonceBytes32(nonce);\\n        require(!_usedNonces[nonceBytes32], \\\"Cannot replay transaction\\\");\\n        // Verify valid message based on input variables\\n        bytes32 expectedMessage = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", (20+bytes(nonce).length).toString(), msg.sender, nonce));\\n        require(message == expectedMessage, \\\"Malformed message\\\");\\n        // Verify signature was performed by the expected signing address\\n        address signer = message.recover(signature);\\n        require(signer == _signingAddress, \\\"Invalid signature\\\");\\n\\n        _usedNonces[nonceBytes32] = true;\\n    }\"}","{\"contract\": \"0x80336ad7a747236ef41f47ed2c7641828a480baa\", \"contract_name\": \"CollectionBase\", \"sol_function\": \"function _validatePurchaseRequestWithAmount(bytes32 message, bytes calldata signature, string calldata nonce, uint16 amount) internal virtual {\\n        // Verify nonce usage/re-use\\n        bytes32 nonceBytes32 = _getNonceBytes32(nonce);\\n        require(!_usedNonces[nonceBytes32], \\\"Cannot replay transaction\\\");\\n        // Verify valid message based on input variables\\n        bytes32 expectedMessage = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", (20+bytes(nonce).length+bytes(uint256(amount).toString()).length).toString(), msg.sender, nonce, uint256(amount).toString()));\\n        require(message == expectedMessage, \\\"Malformed message\\\");\\n        // Verify signature was performed by the expected signing address\\n        address signer = message.recover(signature);\\n        require(signer == _signingAddress, \\\"Invalid signature\\\");\\n\\n        _usedNonces[nonceBytes32] = true;\\n    }\"}","{\"contract\": \"0x80336ad7a747236ef41f47ed2c7641828a480baa\", \"contract_name\": \"ERC721CollectionBase\", \"sol_function\": \"function _validatePurchaseRequest(bytes32 message, bytes calldata signature, string calldata nonce) internal virtual { \\n        // Verify nonce usage/re-use\\n        bytes32 nonceBytes32 = _getNonceBytes32(nonce);\\n        require(!_usedNonces[nonceBytes32], \\\"Cannot replay transaction\\\");\\n        // Verify valid message based on input variables\\n        bytes32 expectedMessage = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", (20+bytes(nonce).length).toString(), msg.sender, nonce));\\n        require(message == expectedMessage, \\\"Malformed message\\\");\\n        // Verify signature was performed by the expected signing address\\n        address signer = message.recover(signature);\\n        require(signer == _signingAddress, \\\"Invalid signature\\\");\\n\\n        _usedNonces[nonceBytes32] = true;\\n    }\"}","{\"contract\": \"0x80336ad7a747236ef41f47ed2c7641828a480baa\", \"contract_name\": \"ERC721CollectionBase\", \"sol_function\": \"function _validatePurchaseRequestWithAmount(bytes32 message, bytes calldata signature, string calldata nonce, uint16 amount) internal virtual {\\n        // Verify nonce usage/re-use\\n        bytes32 nonceBytes32 = _getNonceBytes32(nonce);\\n        require(!_usedNonces[nonceBytes32], \\\"Cannot replay transaction\\\");\\n        // Verify valid message based on input variables\\n        bytes32 expectedMessage = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", (20+bytes(nonce).length+bytes(uint256(amount).toString()).length).toString(), msg.sender, nonce, uint256(amount).toString()));\\n        require(message == expectedMessage, \\\"Malformed message\\\");\\n        // Verify signature was performed by the expected signing address\\n        address signer = message.recover(signature);\\n        require(signer == _signingAddress, \\\"Invalid signature\\\");\\n\\n        _usedNonces[nonceBytes32] = true;\\n    }\"}","{\"contract\": \"0x287f941ab4b5aadad2f13f9363fcec8ee312a969\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x287f941ab4b5aadad2f13f9363fcec8ee312a969\", \"contract_name\": \"BaseVault\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x287f941ab4b5aadad2f13f9363fcec8ee312a969\", \"contract_name\": \"FUDVault\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x73b1988a3336208e55275c52fac7f5d3a7dfb89f\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x73b1988a3336208e55275c52fac7f5d3a7dfb89f\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x73b1988a3336208e55275c52fac7f5d3a7dfb89f\", \"contract_name\": \"esLBR\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xec1d0a2674160be5d274326cb142bbd64d275226\", \"contract_name\": \"ERC721Sale\", \"sol_function\": \"function buy(IERC721 token, uint256 tokenId, uint256 price, uint256 sellerFee, Sig memory signature) public payable {\\r\\n        address payable owner = address(uint160(token.ownerOf(tokenId)));\\r\\n        uint256 nonce = nonceHolder.getNonce(token, tokenId);\\r\\n        uint256 buyerFeeValue = price.mul(buyerFee).div(10000);\\r\\n        require(msg.value == price + buyerFeeValue, \\\"msg.value is incorrect\\\");\\r\\n        require(owner == prepareMessage(address(token), tokenId, price, sellerFee, nonce).recover(signature.v, signature.r, signature.s), \\\"owner should sign correct message\\\");\\r\\n        transferProxy.erc721safeTransferFrom(token, owner, msg.sender, tokenId);\\r\\n        transferEther(token, tokenId, owner, price, sellerFee);\\r\\n        nonceHolder.setNonce(token, tokenId, nonce + 1);\\r\\n        emit Buy(address(token), tokenId, owner, msg.sender, price, nonce + 1);\\r\\n    }\"}","{\"contract\": \"0x6bfdb6f4e65ead27118592a41eb927cea6956198\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x6bfdb6f4e65ead27118592a41eb927cea6956198\", \"contract_name\": \"FameErc20\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xd81e97075dbda444ef65db3a96706c679b5311fd\", \"contract_name\": \"DistributeV1\", \"sol_function\": \"function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external {\\n        require(_earningsToDate > claimedAmount[_to], \\\"nothing to claim\\\");\\n        require(_nonce > lastUsedNonce[_to], \\\"nonce is too old\\\");\\n\\n        address signer = ECDSA.recover(hashForSignature(_to, _earningsToDate, _nonce), _signature);\\n        require(signer == accountManager, \\\"signer is not the account manager\\\");\\n\\n        lastUsedNonce[_to] = _nonce;\\n        uint256 claimableAmount = _earningsToDate.sub(claimedAmount[_to]);\\n        claimedAmount[_to] = _earningsToDate;\\n\\n        kprToken.transfer(_to, claimableAmount);\\n        emit Claimed(_to, claimableAmount);\\n    }\"}","{\"contract\": \"0xd81e97075dbda444ef65db3a96706c679b5311fd\", \"contract_name\": \"KeeperDistributor\", \"sol_function\": \"function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external {\\n        require(_earningsToDate > claimedAmount[_to], \\\"nothing to claim\\\");\\n        require(_nonce > lastUsedNonce[_to], \\\"nonce is too old\\\");\\n\\n        address signer = ECDSA.recover(hashForSignature(_to, _earningsToDate, _nonce), _signature);\\n        require(signer == accountManager, \\\"signer is not the account manager\\\");\\n\\n        lastUsedNonce[_to] = _nonce;\\n        uint256 claimableAmount = _earningsToDate.sub(claimedAmount[_to]);\\n        claimedAmount[_to] = _earningsToDate;\\n\\n        kprToken.transfer(_to, claimableAmount);\\n        emit Claimed(_to, claimableAmount);\\n    }\"}","{\"contract\": \"0xd81e97075dbda444ef65db3a96706c679b5311fd\", \"contract_name\": \"LPDistributor\", \"sol_function\": \"function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external {\\n        require(_earningsToDate > claimedAmount[_to], \\\"nothing to claim\\\");\\n        require(_nonce > lastUsedNonce[_to], \\\"nonce is too old\\\");\\n\\n        address signer = ECDSA.recover(hashForSignature(_to, _earningsToDate, _nonce), _signature);\\n        require(signer == accountManager, \\\"signer is not the account manager\\\");\\n\\n        lastUsedNonce[_to] = _nonce;\\n        uint256 claimableAmount = _earningsToDate.sub(claimedAmount[_to]);\\n        claimedAmount[_to] = _earningsToDate;\\n\\n        kprToken.transfer(_to, claimableAmount);\\n        emit Claimed(_to, claimableAmount);\\n    }\"}","{\"contract\": \"0xd81e97075dbda444ef65db3a96706c679b5311fd\", \"contract_name\": \"LPPreDistributor\", \"sol_function\": \"function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external {\\n        require(_earningsToDate > claimedAmount[_to], \\\"nothing to claim\\\");\\n        require(_nonce > lastUsedNonce[_to], \\\"nonce is too old\\\");\\n\\n        address signer = ECDSA.recover(hashForSignature(_to, _earningsToDate, _nonce), _signature);\\n        require(signer == accountManager, \\\"signer is not the account manager\\\");\\n\\n        lastUsedNonce[_to] = _nonce;\\n        uint256 claimableAmount = _earningsToDate.sub(claimedAmount[_to]);\\n        claimedAmount[_to] = _earningsToDate;\\n\\n        kprToken.transfer(_to, claimableAmount);\\n        emit Claimed(_to, claimableAmount);\\n    }\"}","{\"contract\": \"0xd81e97075dbda444ef65db3a96706c679b5311fd\", \"contract_name\": \"LPQ2Distributor\", \"sol_function\": \"function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external {\\n        require(_earningsToDate > claimedAmount[_to], \\\"nothing to claim\\\");\\n        require(_nonce > lastUsedNonce[_to], \\\"nonce is too old\\\");\\n\\n        address signer = ECDSA.recover(hashForSignature(_to, _earningsToDate, _nonce), _signature);\\n        require(signer == accountManager, \\\"signer is not the account manager\\\");\\n\\n        lastUsedNonce[_to] = _nonce;\\n        uint256 claimableAmount = _earningsToDate.sub(claimedAmount[_to]);\\n        claimedAmount[_to] = _earningsToDate;\\n\\n        kprToken.transfer(_to, claimableAmount);\\n        emit Claimed(_to, claimableAmount);\\n    }\"}","{\"contract\": \"0xd81e97075dbda444ef65db3a96706c679b5311fd\", \"contract_name\": \"HidingGameDistributor\", \"sol_function\": \"function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external {\\n        require(_earningsToDate > claimedAmount[_to], \\\"nothing to claim\\\");\\n        require(_nonce > lastUsedNonce[_to], \\\"nonce is too old\\\");\\n\\n        address signer = ECDSA.recover(hashForSignature(_to, _earningsToDate, _nonce), _signature);\\n        require(signer == accountManager, \\\"signer is not the account manager\\\");\\n\\n        lastUsedNonce[_to] = _nonce;\\n        uint256 claimableAmount = _earningsToDate.sub(claimedAmount[_to]);\\n        claimedAmount[_to] = _earningsToDate;\\n\\n        kprToken.transfer(_to, claimableAmount);\\n        emit Claimed(_to, claimableAmount);\\n    }\"}","{\"contract\": \"0xa839b884774bb843e20cf4869667bdd17a4630f5\", \"contract_name\": \"SupportSig\", \"sol_function\": \"function getSigner(bytes memory typedContents, bytes memory sig) internal view returns (address) {\\n        return ECDSA.recover(_hashTypedDataV4(keccak256(typedContents)), sig);\\n    }\"}","{\"contract\": \"0xf492aebe8ed344f2beeaff4ed83dfc65ea695980\", \"contract_name\": \"LP\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xf492aebe8ed344f2beeaff4ed83dfc65ea695980\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x5207ca53386e1b462316ec9726b9e150de82bc14\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x5207ca53386e1b462316ec9726b9e150de82bc14\", \"contract_name\": \"NeverGibUpFren\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xd04f98c88ce1054c90022ee34d566b9237a1203c\", \"contract_name\": \"Forwarder\", \"sol_function\": \"function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) {\\n        address signer = _hashTypedDataV4(\\n            keccak256(abi.encode(TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))\\n        ).recover(signature);\\n\\n        return _nonces[req.from] == req.nonce && signer == req.from;\\n    }\"}","{\"contract\": \"0xfbf8f1a5e00034762d928f46d438b947f5d4065d\", \"contract_name\": \"MainModule\", \"sol_function\": \"function signatureRecovery(\\n    bytes32 _digest,\\n    bytes calldata _signature\\n  ) public override virtual view returns (\\n    uint256 threshold,\\n    uint256 weight,\\n    bytes32 imageHash,\\n    bytes32 subdigest,\\n    uint256 checkpoint\\n  ) {\\n    bytes1 signatureType = _signature[0];\\n\\n    if (signatureType == LEGACY_TYPE) {\\n      // networkId digest + base recover\\n      subdigest = SequenceBaseSig.subdigest(_digest);\\n      (threshold, weight, imageHash, checkpoint) = SequenceBaseSig.recover(subdigest, _signature);\\n      return (threshold, weight, imageHash, subdigest, checkpoint);\\n    }\\n\\n    if (signatureType == DYNAMIC_TYPE) {\\n      // networkId digest + dynamic recover\\n      subdigest = SequenceBaseSig.subdigest(_digest);\\n      (threshold, weight, imageHash, checkpoint) = SequenceDynamicSig.recover(subdigest, _signature);\\n      return (threshold, weight, imageHash, subdigest, checkpoint);\\n    }\\n\\n    if (signatureType == NO_CHAIN_ID_TYPE) {\\n      // noChainId digest + dynamic recover\\n      subdigest = SequenceNoChainIdSig.subdigest(_digest);\\n      (threshold, weight, imageHash, checkpoint) = SequenceDynamicSig.recover(subdigest, _signature);\\n      return (threshold, weight, imageHash, subdigest, checkpoint);\\n    }\\n\\n    if (signatureType == CHAINED_TYPE) {\\n      // original digest + chained recover\\n      // (subdigest will be computed in the chained recover)\\n      return chainedRecover(_digest, _signature);\\n    }\\n\\n    revert InvalidSignatureType(signatureType);\\n  }\"}","{\"contract\": \"0xfbf8f1a5e00034762d928f46d438b947f5d4065d\", \"contract_name\": \"ModuleAuth\", \"sol_function\": \"function signatureRecovery(\\n    bytes32 _digest,\\n    bytes calldata _signature\\n  ) public override virtual view returns (\\n    uint256 threshold,\\n    uint256 weight,\\n    bytes32 imageHash,\\n    bytes32 subdigest,\\n    uint256 checkpoint\\n  ) {\\n    bytes1 signatureType = _signature[0];\\n\\n    if (signatureType == LEGACY_TYPE) {\\n      // networkId digest + base recover\\n      subdigest = SequenceBaseSig.subdigest(_digest);\\n      (threshold, weight, imageHash, checkpoint) = SequenceBaseSig.recover(subdigest, _signature);\\n      return (threshold, weight, imageHash, subdigest, checkpoint);\\n    }\\n\\n    if (signatureType == DYNAMIC_TYPE) {\\n      // networkId digest + dynamic recover\\n      subdigest = SequenceBaseSig.subdigest(_digest);\\n      (threshold, weight, imageHash, checkpoint) = SequenceDynamicSig.recover(subdigest, _signature);\\n      return (threshold, weight, imageHash, subdigest, checkpoint);\\n    }\\n\\n    if (signatureType == NO_CHAIN_ID_TYPE) {\\n      // noChainId digest + dynamic recover\\n      subdigest = SequenceNoChainIdSig.subdigest(_digest);\\n      (threshold, weight, imageHash, checkpoint) = SequenceDynamicSig.recover(subdigest, _signature);\\n      return (threshold, weight, imageHash, subdigest, checkpoint);\\n    }\\n\\n    if (signatureType == CHAINED_TYPE) {\\n      // original digest + chained recover\\n      // (subdigest will be computed in the chained recover)\\n      return chainedRecover(_digest, _signature);\\n    }\\n\\n    revert InvalidSignatureType(signatureType);\\n  }\"}","{\"contract\": \"0xfbf8f1a5e00034762d928f46d438b947f5d4065d\", \"contract_name\": \"ModuleAuthConvenience\", \"sol_function\": \"function signatureRecovery(\\n    bytes32 _digest,\\n    bytes calldata _signature\\n  ) public override virtual view returns (\\n    uint256 threshold,\\n    uint256 weight,\\n    bytes32 imageHash,\\n    bytes32 subdigest,\\n    uint256 checkpoint\\n  ) {\\n    bytes1 signatureType = _signature[0];\\n\\n    if (signatureType == LEGACY_TYPE) {\\n      // networkId digest + base recover\\n      subdigest = SequenceBaseSig.subdigest(_digest);\\n      (threshold, weight, imageHash, checkpoint) = SequenceBaseSig.recover(subdigest, _signature);\\n      return (threshold, weight, imageHash, subdigest, checkpoint);\\n    }\\n\\n    if (signatureType == DYNAMIC_TYPE) {\\n      // networkId digest + dynamic recover\\n      subdigest = SequenceBaseSig.subdigest(_digest);\\n      (threshold, weight, imageHash, checkpoint) = SequenceDynamicSig.recover(subdigest, _signature);\\n      return (threshold, weight, imageHash, subdigest, checkpoint);\\n    }\\n\\n    if (signatureType == NO_CHAIN_ID_TYPE) {\\n      // noChainId digest + dynamic recover\\n      subdigest = SequenceNoChainIdSig.subdigest(_digest);\\n      (threshold, weight, imageHash, checkpoint) = SequenceDynamicSig.recover(subdigest, _signature);\\n      return (threshold, weight, imageHash, subdigest, checkpoint);\\n    }\\n\\n    if (signatureType == CHAINED_TYPE) {\\n      // original digest + chained recover\\n      // (subdigest will be computed in the chained recover)\\n      return chainedRecover(_digest, _signature);\\n    }\\n\\n    revert InvalidSignatureType(signatureType);\\n  }\"}","{\"contract\": \"0xfbf8f1a5e00034762d928f46d438b947f5d4065d\", \"contract_name\": \"ModuleAuthFixed\", \"sol_function\": \"function signatureRecovery(\\n    bytes32 _digest,\\n    bytes calldata _signature\\n  ) public override virtual view returns (\\n    uint256 threshold,\\n    uint256 weight,\\n    bytes32 imageHash,\\n    bytes32 subdigest,\\n    uint256 checkpoint\\n  ) {\\n    bytes1 signatureType = _signature[0];\\n\\n    if (signatureType == LEGACY_TYPE) {\\n      // networkId digest + base recover\\n      subdigest = SequenceBaseSig.subdigest(_digest);\\n      (threshold, weight, imageHash, checkpoint) = SequenceBaseSig.recover(subdigest, _signature);\\n      return (threshold, weight, imageHash, subdigest, checkpoint);\\n    }\\n\\n    if (signatureType == DYNAMIC_TYPE) {\\n      // networkId digest + dynamic recover\\n      subdigest = SequenceBaseSig.subdigest(_digest);\\n      (threshold, weight, imageHash, checkpoint) = SequenceDynamicSig.recover(subdigest, _signature);\\n      return (threshold, weight, imageHash, subdigest, checkpoint);\\n    }\\n\\n    if (signatureType == NO_CHAIN_ID_TYPE) {\\n      // noChainId digest + dynamic recover\\n      subdigest = SequenceNoChainIdSig.subdigest(_digest);\\n      (threshold, weight, imageHash, checkpoint) = SequenceDynamicSig.recover(subdigest, _signature);\\n      return (threshold, weight, imageHash, subdigest, checkpoint);\\n    }\\n\\n    if (signatureType == CHAINED_TYPE) {\\n      // original digest + chained recover\\n      // (subdigest will be computed in the chained recover)\\n      return chainedRecover(_digest, _signature);\\n    }\\n\\n    revert InvalidSignatureType(signatureType);\\n  }\"}","{\"contract\": \"0xfbf8f1a5e00034762d928f46d438b947f5d4065d\", \"contract_name\": \"ModuleExtraAuth\", \"sol_function\": \"function signatureRecovery(\\n    bytes32 _digest,\\n    bytes calldata _signature\\n  ) public override virtual view returns (\\n    uint256 threshold,\\n    uint256 weight,\\n    bytes32 imageHash,\\n    bytes32 subdigest,\\n    uint256 checkpoint\\n  ) {\\n    bytes1 signatureType = _signature[0];\\n\\n    if (signatureType == LEGACY_TYPE) {\\n      // networkId digest + base recover\\n      subdigest = SequenceBaseSig.subdigest(_digest);\\n      (threshold, weight, imageHash, checkpoint) = SequenceBaseSig.recover(subdigest, _signature);\\n      return (threshold, weight, imageHash, subdigest, checkpoint);\\n    }\\n\\n    if (signatureType == DYNAMIC_TYPE) {\\n      // networkId digest + dynamic recover\\n      subdigest = SequenceBaseSig.subdigest(_digest);\\n      (threshold, weight, imageHash, checkpoint) = SequenceDynamicSig.recover(subdigest, _signature);\\n      return (threshold, weight, imageHash, subdigest, checkpoint);\\n    }\\n\\n    if (signatureType == NO_CHAIN_ID_TYPE) {\\n      // noChainId digest + dynamic recover\\n      subdigest = SequenceNoChainIdSig.subdigest(_digest);\\n      (threshold, weight, imageHash, checkpoint) = SequenceDynamicSig.recover(subdigest, _signature);\\n      return (threshold, weight, imageHash, subdigest, checkpoint);\\n    }\\n\\n    if (signatureType == CHAINED_TYPE) {\\n      // original digest + chained recover\\n      // (subdigest will be computed in the chained recover)\\n      return chainedRecover(_digest, _signature);\\n    }\\n\\n    revert InvalidSignatureType(signatureType);\\n  }\"}","{\"contract\": \"0xfbf8f1a5e00034762d928f46d438b947f5d4065d\", \"contract_name\": \"SequenceDynamicSig\", \"sol_function\": \"function recover(\\n    bytes32 _subdigest,\\n    bytes calldata _signature\\n  ) internal view returns (\\n    uint256 threshold,\\n    uint256 weight,\\n    bytes32 imageHash,\\n    uint256 checkpoint\\n  ) {\\n    return SequenceBaseSig.recover(_subdigest, _signature[1:]);\\n  }\"}","{\"contract\": \"0xfa2dbc4eb68ca6e20be05c8a3d0a6ebeaedc169d\", \"contract_name\": \"HUGMembershipPass\", \"sol_function\": \"function verifySenderApproved(\\n        bool isCurator,\\n        bool oneFree,\\n        bytes memory signature\\n    ) private view {\\n        bytes32 hashedInsideContract = keccak256(\\n            abi.encodePacked(msg.sender, isCurator, oneFree)\\n        );\\n        bytes32 messageDigest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                hashedInsideContract\\n            )\\n        );\\n        address recovered = ECDSA.recover(messageDigest, signature);\\n        if (recovered != hugApprovalSigner) revert InvalidApproval();\\n    }\"}","{\"contract\": \"0x6a76157a757f877a2db866c0cb30a3330edb655e\", \"contract_name\": \"Minter\", \"sol_function\": \"function isValidVerifySignature(\\n        string memory designId,\\n        bytes memory signature\\n    ) private view returns (bool) {\\n        bytes32 hash = keccak256(abi.encodePacked(designId));\\n        bytes32 messageDigest = ECDSA.toEthSignedMessageHash(hash);\\n\\n        address recoveredSigner = ECDSA.recover(messageDigest, signature);\\n        return recoveredSigner == verifySigner;\\n    }\"}","{\"contract\": \"0x6a76157a757f877a2db866c0cb30a3330edb655e\", \"contract_name\": \"Minter\", \"sol_function\": \"function isValidAllowlistSignature(\\n        bytes memory signature\\n    ) private view returns (bool) {\\n        bytes32 hashed = keccak256(abi.encodePacked(msg.sender));\\n        bytes32 messageDigest = ECDSA.toEthSignedMessageHash(hashed);\\n\\n        address recoveredSigner = ECDSA.recover(messageDigest, signature);\\n        return recoveredSigner == allowlistSigner;\\n    }\"}","{\"contract\": \"0xecaf045a5c44d6eef7f728e297f5655fc675b6b4\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xecaf045a5c44d6eef7f728e297f5655fc675b6b4\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xecaf045a5c44d6eef7f728e297f5655fc675b6b4\", \"contract_name\": \"Tally\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x6dddae6d68b7fdcdc8d0d6d5321a3a930a9172e6\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x6dddae6d68b7fdcdc8d0d6d5321a3a930a9172e6\", \"contract_name\": \"Tulpa\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x7f76204c9e3c0fa5871856dff89c192bb4c1493b\", \"contract_name\": \"HARUNA\", \"sol_function\": \"function isWhitelisted(bytes memory signature) internal view returns(bool){\\n        bytes32 messagehash = keccak256(\\n             abi.encodePacked(address(this), msg.sender)\\n         );\\n         address signer = messagehash.toEthSignedMessageHash().recover(\\n             signature\\n         ); \\n            return((_signer == signer));\\n  }\"}","{\"contract\": \"0xa3e3d287d21f64045db85f4f2ce990941c31b0ae\", \"contract_name\": \"ApeEscape\", \"sol_function\": \"function checkValidity(\\n        bytes calldata signature,\\n        string memory action\\n    ) public view returns (bool) {\\n        require(\\n            ECDSA.recover(\\n                ECDSA.toEthSignedMessageHash(\\n                    keccak256(abi.encodePacked(msg.sender, action))\\n                ),\\n                signature\\n            ) == signer,\\n            \\\"invalid signature\\\"\\n        );\\n        return true;\\n    }\"}","{\"contract\": \"0x30c9334d28bc1401388d9954dc8425b49f5bd67d\", \"contract_name\": \"Wrapper\", \"sol_function\": \"function mint(bytes memory signedMsg, string memory ipfsLink) public payable {\\n      require(wrappedTokensByAddress[msg.sender].stakedTokens.length >= 2, \\\"You need at least 2 or more staked tokens to mint\\\");\\n\\t\\t  require(msg.value == PRICE, 'Incorrect Payment');\\n      // Signature verification\\n      uint256[] memory tokenIds = getStakedTokensByTokenOwner(msg.sender);\\n      string memory tmp = concatUintToString(tokenIds);\\n      bytes32 hash = keccak256(abi.encodePacked(ipfsLink, tmp));\\n      bytes32 newProof = hash.toEthSignedMessageHash();\\n      address ecRecover = ECDSA.recover(newProof, signedMsg);\\n      require(ecRecover == signerIpfsLinks, \\\"Signature is invalid\\\");\\n      // end signature verification\\n      _tokenIds++;\\n      _mint(msg.sender, _tokenIds);\\n      _setTokenURI(_tokenIds, ipfsLink);\\n      wrappedTokensByAddress[msg.sender].id = _tokenIds;\\n      wrappedTokensByAddress[msg.sender].wrapped = true;\\n      // Move token to the wrapper mapping by token Id\\n      wrappedTokensByTokenId[_tokenIds] = wrappedTokensByAddress[msg.sender];\\n      _tokens.push(msg.sender);\\n      delete wrappedTokensByAddress[msg.sender];\\n    }\"}","{\"contract\": \"0x0ff7bd781f30802c674d129268a604aa855ac88e\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x0ff7bd781f30802c674d129268a604aa855ac88e\", \"contract_name\": \"WAQHO\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x28b63b2dbb5a757e5b9e45b5a6e37e334f03e964\", \"contract_name\": \"Dippies\", \"sol_function\": \"function mint(uint256 quantity, bytes calldata signature, bytes32 nonce) external payable {\\n        require((state == Status.SALE_LIVE || state == Status.PRESALE_LIVE), \\\"Dippies: Sale Not Live\\\");\\n        require(msg.sender == tx.origin, \\\"Dippies: Contract Interaction Not Allowed\\\");\\n        require(ECDSA.recover(keccak256(abi.encodePacked(msg.sender, quantity, state, nonce)), signature) == _signer, \\\"Dippies: Invalid Signer\\\");\\n        require(totalSupply() + quantity <= (state == Status.SALE_LIVE ? SUPPLY_MAX : (PRESALE_MAX + _reservedTeamTokens)), \\\"Dippies: Exceed Max Supply\\\");\\n        require(quantity <= 2, \\\"Dippies: Exceeds Max Per TX\\\");\\n        require(msg.value >= PRICE * quantity, \\\"Dippies: Insufficient ETH\\\");\\n\\n        if(state == Status.PRESALE_LIVE) {\\n            require(_numberMinted(msg.sender) + quantity <= 2, \\\"Dippies: Exceeds Max Per Wallet\\\");\\n        } else {\\n            require(!_nonceUsed[nonce], \\\"Dippies: Nonce Used\\\");\\n            _nonceUsed[nonce] = true;\\n        }\\n        \\n        _safeMint(msg.sender, quantity);\\n    }\"}","{\"contract\": \"0xc32013503e14ba11fd299fba9d50a96b4041a9f6\", \"contract_name\": \"EndemicExchange\", \"sol_function\": \"function _verifySignature(\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s,\\n        Sale calldata sale\\n    ) internal view {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                _buildDomainSeparator(),\\n                keccak256(\\n                    abi.encode(\\n                        SALE_TYPEHASH,\\n                        sale.orderNonce,\\n                        sale.nftContract,\\n                        sale.tokenId,\\n                        sale.paymentErc20TokenAddress,\\n                        sale.price,\\n                        sale.buyer,\\n                        sale.expiresAt\\n                    )\\n                )\\n            )\\n        );\\n\\n        if (digest.recover(v, r, s) != sale.seller) {\\n            revert InvalidSignature();\\n        }\\n    }\"}","{\"contract\": \"0xc32013503e14ba11fd299fba9d50a96b4041a9f6\", \"contract_name\": \"EndemicExchange\", \"sol_function\": \"function _verifySignature(\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s,\\n        Offer calldata offer\\n    ) internal view {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                _buildDomainSeparator(),\\n                keccak256(\\n                    abi.encode(\\n                        OFFER_TYPEHASH,\\n                        offer.orderNonce,\\n                        offer.nftContract,\\n                        offer.tokenId,\\n                        offer.paymentErc20TokenAddress,\\n                        offer.price,\\n                        offer.expiresAt,\\n                        offer.isForCollection\\n                    )\\n                )\\n            )\\n        );\\n\\n        if (digest.recover(v, r, s) != offer.bidder) {\\n            revert InvalidSignature();\\n        }\\n    }\"}","{\"contract\": \"0xc32013503e14ba11fd299fba9d50a96b4041a9f6\", \"contract_name\": \"EndemicExchange\", \"sol_function\": \"function _verifySignature(ReserveAuction calldata data) internal view {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                _buildDomainSeparator(),\\n                keccak256(\\n                    abi.encode(\\n                        RESERVE_AUCTION_TYPEHASH,\\n                        data.orderNonce,\\n                        data.nftContract,\\n                        data.tokenId,\\n                        data.paymentErc20TokenAddress,\\n                        data.price,\\n                        data.isBid\\n                    )\\n                )\\n            )\\n        );\\n\\n        if (digest.recover(data.v, data.r, data.s) != data.signer) {\\n            revert InvalidSignature();\\n        }\\n    }\"}","{\"contract\": \"0xc32013503e14ba11fd299fba9d50a96b4041a9f6\", \"contract_name\": \"EndemicExchange\", \"sol_function\": \"function _verifySignature(\\n        DutchAuction calldata auction,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                _buildDomainSeparator(),\\n                keccak256(\\n                    abi.encode(\\n                        AUCTION_TYPEHASH,\\n                        auction.orderNonce,\\n                        auction.nftContract,\\n                        auction.tokenId,\\n                        auction.paymentErc20TokenAddress,\\n                        auction.startingPrice,\\n                        auction.endingPrice,\\n                        auction.startingAt,\\n                        auction.duration\\n                    )\\n                )\\n            )\\n        );\\n\\n        if (digest.recover(v, r, s) != auction.seller) {\\n            revert InvalidSignature();\\n        }\\n    }\"}","{\"contract\": \"0xc32013503e14ba11fd299fba9d50a96b4041a9f6\", \"contract_name\": \"EndemicOffer\", \"sol_function\": \"function _verifySignature(\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s,\\n        Offer calldata offer\\n    ) internal view {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                _buildDomainSeparator(),\\n                keccak256(\\n                    abi.encode(\\n                        OFFER_TYPEHASH,\\n                        offer.orderNonce,\\n                        offer.nftContract,\\n                        offer.tokenId,\\n                        offer.paymentErc20TokenAddress,\\n                        offer.price,\\n                        offer.expiresAt,\\n                        offer.isForCollection\\n                    )\\n                )\\n            )\\n        );\\n\\n        if (digest.recover(v, r, s) != offer.bidder) {\\n            revert InvalidSignature();\\n        }\\n    }\"}","{\"contract\": \"0xc32013503e14ba11fd299fba9d50a96b4041a9f6\", \"contract_name\": \"EndemicSale\", \"sol_function\": \"function _verifySignature(\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s,\\n        Sale calldata sale\\n    ) internal view {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                _buildDomainSeparator(),\\n                keccak256(\\n                    abi.encode(\\n                        SALE_TYPEHASH,\\n                        sale.orderNonce,\\n                        sale.nftContract,\\n                        sale.tokenId,\\n                        sale.paymentErc20TokenAddress,\\n                        sale.price,\\n                        sale.buyer,\\n                        sale.expiresAt\\n                    )\\n                )\\n            )\\n        );\\n\\n        if (digest.recover(v, r, s) != sale.seller) {\\n            revert InvalidSignature();\\n        }\\n    }\"}","{\"contract\": \"0xc32013503e14ba11fd299fba9d50a96b4041a9f6\", \"contract_name\": \"EndemicDutchAuction\", \"sol_function\": \"function _verifySignature(\\n        DutchAuction calldata auction,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                _buildDomainSeparator(),\\n                keccak256(\\n                    abi.encode(\\n                        AUCTION_TYPEHASH,\\n                        auction.orderNonce,\\n                        auction.nftContract,\\n                        auction.tokenId,\\n                        auction.paymentErc20TokenAddress,\\n                        auction.startingPrice,\\n                        auction.endingPrice,\\n                        auction.startingAt,\\n                        auction.duration\\n                    )\\n                )\\n            )\\n        );\\n\\n        if (digest.recover(v, r, s) != auction.seller) {\\n            revert InvalidSignature();\\n        }\\n    }\"}","{\"contract\": \"0xc32013503e14ba11fd299fba9d50a96b4041a9f6\", \"contract_name\": \"EndemicReserveAuction\", \"sol_function\": \"function _verifySignature(ReserveAuction calldata data) internal view {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                _buildDomainSeparator(),\\n                keccak256(\\n                    abi.encode(\\n                        RESERVE_AUCTION_TYPEHASH,\\n                        data.orderNonce,\\n                        data.nftContract,\\n                        data.tokenId,\\n                        data.paymentErc20TokenAddress,\\n                        data.price,\\n                        data.isBid\\n                    )\\n                )\\n            )\\n        );\\n\\n        if (digest.recover(data.v, data.r, data.s) != data.signer) {\\n            revert InvalidSignature();\\n        }\\n    }\"}","{\"contract\": \"0x0096cb5ea64c105d5e6877556e890d51a512eb71\", \"contract_name\": \"JBToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x0096cb5ea64c105d5e6877556e890d51a512eb71\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x7c1b67ecb3b199a5880e57065c85c3cb599bc979\", \"contract_name\": \"DiagonalOrg\", \"sol_function\": \"function _verifyChargeSignature(ChargeStruct calldata chargeRequest, Signature calldata signature) private view {\\n        bytes32 digest = keccak256(\\n            abi.encode(\\n                chargeRequest.id,\\n                chargeRequest.source,\\n                chargeRequest.token,\\n                chargeRequest.amount,\\n                address(this),\\n                block.chainid\\n            )\\n        );\\n        address _signer = ECDSA.recover(digest, signature.v, signature.r, signature.s);\\n        if (signer != _signer) revert InvalidChargeSignatureVerification();\\n    }\"}","{\"contract\": \"0x7c1b67ecb3b199a5880e57065c85c3cb599bc979\", \"contract_name\": \"Charge\", \"sol_function\": \"function _verifyChargeSignature(ChargeStruct calldata chargeRequest, Signature calldata signature) private view {\\n        bytes32 digest = keccak256(\\n            abi.encode(\\n                chargeRequest.id,\\n                chargeRequest.source,\\n                chargeRequest.token,\\n                chargeRequest.amount,\\n                address(this),\\n                block.chainid\\n            )\\n        );\\n        address _signer = ECDSA.recover(digest, signature.v, signature.r, signature.s);\\n        if (signer != _signer) revert InvalidChargeSignatureVerification();\\n    }\"}","{\"contract\": \"0x838dc0d1dd2063633352d5a2950de67a0d20d1f2\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x838dc0d1dd2063633352d5a2950de67a0d20d1f2\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x838dc0d1dd2063633352d5a2950de67a0d20d1f2\", \"contract_name\": \"SomeEXP\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x04d4128dd50a0b3b142f630ec7c3f2d1c5f29353\", \"contract_name\": \"EtherFox\", \"sol_function\": \"function verifySignerAddress(bytes32 messageHash, bytes calldata signature)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return\\n            presaleSignerAddress ==\\n            messageHash.toEthSignedMessageHash().recover(signature);\\n    }\"}","{\"contract\": \"0x073211c927535010a8d3810521535d89f22172c4\", \"contract_name\": \"justquestioneverything\", \"sol_function\": \"function requireRecovery(\\n        address sender,\\n        uint256 nonce_,\\n        bytes memory signature_\\n    ) internal view {\\n        bytes32 hash = keccak256(abi.encodePacked(sender, nonce_));\\n        bytes32 message = ECDSA.toEthSignedMessageHash(hash);\\n\\n        require(\\n            ECDSA.recover(message, signature_) == authorizerAddress,\\n            \\\"Bad signature\\\"\\n        );\\n    }\"}","{\"contract\": \"0x073211c927535010a8d3810521535d89f22172c4\", \"contract_name\": \"AuthorizerV1\", \"sol_function\": \"function requireRecovery(\\n        address sender,\\n        uint256 nonce_,\\n        bytes memory signature_\\n    ) internal view {\\n        bytes32 hash = keccak256(abi.encodePacked(sender, nonce_));\\n        bytes32 message = ECDSA.toEthSignedMessageHash(hash);\\n\\n        require(\\n            ECDSA.recover(message, signature_) == authorizerAddress,\\n            \\\"Bad signature\\\"\\n        );\\n    }\"}","{\"contract\": \"0x3a5051566b2241285be871f650c445a88a970edd\", \"contract_name\": \"TheHumanoids\", \"sol_function\": \"function mintPresale(uint256 _amount, uint256 _maxTotal, uint8 _signatureV, bytes32 _signatureR, bytes32 _signatureS) external payable {\\r\\n        require(presaleIsActive,\\\"Presale must be active\\\");\\r\\n        require(_tokenCount.current() + _amount <= maxTokens, \\\"Purchase would exceed max supply of Tokens\\\");\\r\\n        require(msg.value >= price * _amount, \\\"Ether value sent is not correct\\\");\\r\\n        require(minted[msg.sender] + _amount <= _maxTotal, \\\"Purchase would exceed max tokens for presale\\\");\\r\\n\\r\\n        bytes32 hash = keccak256(abi.encode(msg.sender, _maxTotal));\\r\\n        address signer = ECDSA.recover(hash, _signatureV,  _signatureR,  _signatureS);\\r\\n        require(signer == _signerAddress, \\\"Invalid signature\\\");\\r\\n        \\r\\n        for(uint i; i < _amount; i++){\\r\\n            _tokenCount.increment();\\r\\n            _safeMint(msg.sender, _tokenCount.current());\\r\\n        }\\r\\n\\r\\n        minted[msg.sender] += _amount;\\r\\n    }\"}","{\"contract\": \"0x1f98fdc4d8d0806eb3902d57df7a2183b333b80c\", \"contract_name\": \"Home\", \"sol_function\": \"function _isUpdaterSignature(\\n        bytes32 _oldRoot,\\n        bytes32 _newRoot,\\n        bytes memory _signature\\n    ) internal view returns (bool) {\\n        bytes32 _digest = keccak256(\\n            abi.encodePacked(homeDomainHash(), _oldRoot, _newRoot)\\n        );\\n        _digest = ECDSA.toEthSignedMessageHash(_digest);\\n        return (ECDSA.recover(_digest, _signature) == updater);\\n    }\"}","{\"contract\": \"0x1f98fdc4d8d0806eb3902d57df7a2183b333b80c\", \"contract_name\": \"NomadBase\", \"sol_function\": \"function _isUpdaterSignature(\\n        bytes32 _oldRoot,\\n        bytes32 _newRoot,\\n        bytes memory _signature\\n    ) internal view returns (bool) {\\n        bytes32 _digest = keccak256(\\n            abi.encodePacked(homeDomainHash(), _oldRoot, _newRoot)\\n        );\\n        _digest = ECDSA.toEthSignedMessageHash(_digest);\\n        return (ECDSA.recover(_digest, _signature) == updater);\\n    }\"}","{\"contract\": \"0x8191dc3053fe4564c17694cb203663d3c07b8960\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x8191dc3053fe4564c17694cb203663d3c07b8960\", \"contract_name\": \"USDe\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x8726e455769d5c58c4ad8453c0c4b7ae116f3113\", \"contract_name\": \"MemecoinFiresaleV1\", \"sol_function\": \"function _checkValidity(address _requester, bytes calldata _signature, string memory _action)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        bytes32 hashVal = keccak256(abi.encodePacked(_requester, _action));\\n        bytes32 signedHash = hashVal.toEthSignedMessageHash();\\n\\n        return signedHash.recover(_signature) == signer;\\n    }\"}","{\"contract\": \"0x109e5a790044d8762f44b34927ad363301feeea7\", \"contract_name\": \"LMPVault\", \"sol_function\": \"function recover(\\n        address[] calldata tokens,\\n        uint256[] calldata amounts,\\n        address[] calldata destinations\\n    ) external virtual override hasRole(Roles.TOKEN_RECOVERY_ROLE) {\\n        AutoPool4626.recover(tokens, amounts, destinations);\\n    }\"}","{\"contract\": \"0x4b44e4305b42405382b7bec717f64d0552a9d9fe\", \"contract_name\": \"MultisigValidatorManager\", \"sol_function\": \"function _recoverCheckpointSigner(\\n        bytes32 _root,\\n        uint256 _index,\\n        bytes calldata _signature\\n    ) internal view returns (address) {\\n        bytes32 _digest = keccak256(\\n            abi.encodePacked(domainHash, _root, _index)\\n        );\\n        return ECDSA.recover(ECDSA.toEthSignedMessageHash(_digest), _signature);\\n    }\"}","{\"contract\": \"0x4b44e4305b42405382b7bec717f64d0552a9d9fe\", \"contract_name\": \"TestMultisigValidatorManager\", \"sol_function\": \"function _recoverCheckpointSigner(\\n        bytes32 _root,\\n        uint256 _index,\\n        bytes calldata _signature\\n    ) internal view returns (address) {\\n        bytes32 _digest = keccak256(\\n            abi.encodePacked(domainHash, _root, _index)\\n        );\\n        return ECDSA.recover(ECDSA.toEthSignedMessageHash(_digest), _signature);\\n    }\"}","{\"contract\": \"0x4b44e4305b42405382b7bec717f64d0552a9d9fe\", \"contract_name\": \"InboxValidatorManager\", \"sol_function\": \"function _recoverCheckpointSigner(\\n        bytes32 _root,\\n        uint256 _index,\\n        bytes calldata _signature\\n    ) internal view returns (address) {\\n        bytes32 _digest = keccak256(\\n            abi.encodePacked(domainHash, _root, _index)\\n        );\\n        return ECDSA.recover(ECDSA.toEthSignedMessageHash(_digest), _signature);\\n    }\"}","{\"contract\": \"0x4b44e4305b42405382b7bec717f64d0552a9d9fe\", \"contract_name\": \"OutboxValidatorManager\", \"sol_function\": \"function _recoverCheckpointSigner(\\n        bytes32 _root,\\n        uint256 _index,\\n        bytes calldata _signature\\n    ) internal view returns (address) {\\n        bytes32 _digest = keccak256(\\n            abi.encodePacked(domainHash, _root, _index)\\n        );\\n        return ECDSA.recover(ECDSA.toEthSignedMessageHash(_digest), _signature);\\n    }\"}","{\"contract\": \"0x110fd9a44a056cb418d07f7d9957d0303f0020e4\", \"contract_name\": \"Bridge\", \"sol_function\": \"function _verifyMessage(bytes memory preimage, EventProof calldata proof)\\n        internal\\n    {\\n        // gas savings\\n        uint256 _eventId = proof.eventId;\\n        uint32 _validatorSetId = proof.validatorSetId;\\n        address[] memory _validators = proof.validators;\\n\\n        require(active, \\\"Bridge: bridge inactive\\\");\\n        require(!verifiedEventIds[_eventId], \\\"Bridge: eventId replayed\\\");\\n        require(\\n            _validatorSetId <= activeValidatorSetId,\\n            \\\"Bridge: future validator set\\\"\\n        );\\n        require(\\n            activeValidatorSetId - _validatorSetId <= proofTTL,\\n            \\\"Bridge: expired proof\\\"\\n        );\\n        // audit item #1\\n        require(_validators.length > 0, \\\"Bridge: invalid validator set\\\");\\n        require(\\n            keccak256(abi.encode(_validators)) ==\\n                validatorSetDigests[_validatorSetId],\\n            \\\"Bridge: unexpected validator digest\\\"\\n        );\\n\\n        bytes32 digest = keccak256(preimage);\\n        uint acceptanceTreshold = ((_validators.length * thresholdPercent) /\\n            100);\\n        uint witnessCount; // uint256(0)\\n        bytes32 ommited; // bytes32(0)\\n\\n        for (uint i; i < _validators.length; ++i) {\\n            if (proof.r[i] != ommited) { // check signature omitted == bytes32(0)\\n                // check signature\\n                require(\\n                    _validators[i] == digest.recover(proof.v[i], proof.r[i], proof.s[i]),\\n                    \\\"Bridge: signature invalid\\\"\\n                );\\n                witnessCount += 1;\\n                // have we got proven consensus?\\n                if (witnessCount >= acceptanceTreshold) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        require(witnessCount >= acceptanceTreshold, \\\"Bridge: not enough signatures\\\");\\n        verifiedEventIds[_eventId] = true;\\n    }\"}","{\"contract\": \"0x44e63635d5b5af01da45e0a919b704a49c0e9d39\", \"contract_name\": \"CryptoHongKongLands\", \"sol_function\": \"function verifyHash(bytes32 hash, bytes32 signatureR, bytes32 signatureVS) public pure returns (address signer) {\\r\\n        bytes32 messageDigest = ECDSA.toEthSignedMessageHash(hash);\\r\\n        return ECDSA.recover(messageDigest, signatureR, signatureVS);\\r\\n    }\"}","{\"contract\": \"0x74e27e64841d09005c3df348bceef78f4c52dec0\", \"contract_name\": \"Sale\", \"sol_function\": \"function _verify(uint256 tokenId, uint256 tier, uint256 rate, bytes memory signature) internal view returns (address) {\\r\\n        bytes32 msgHash = keccak256(abi.encodePacked(_signingDomain, _signingVersion, address(this), tokenId, tier, rate));\\r\\n        bytes32 signedHash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", msgHash));\\r\\n        return signedHash.recover(signature);\\r\\n    }\"}","{\"contract\": \"0xcb43becfb5947bb6b7629a4d282b6f12c1b29ddd\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xcb43becfb5947bb6b7629a4d282b6f12c1b29ddd\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xcb43becfb5947bb6b7629a4d282b6f12c1b29ddd\", \"contract_name\": \"NablaWorld\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x233a922f203b2eb705b833cf147979556eae7a45\", \"contract_name\": \"SbeeTokenClaim\", \"sol_function\": \"function _verify(\\n        ClaimOptions memory _options,\\n        bytes memory signature\\n    ) internal view returns (address) {\\n        bytes32 digest = _hash(_options);\\n        return ECDSA.recover(digest, signature);\\n    }\"}","{\"contract\": \"0xd09f00d03adb33623b89637717258f4169af71d4\", \"contract_name\": \"DeployToken\", \"sol_function\": \"function _isValidSigner(bytes32 hash, bytes memory signature)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    require(signer != address(0), ErrInvalidSigner);\\n\\n    bytes32 signedHash = hash.toEthSignedMessageHash();\\n    address recoveredAddress = signedHash.recover(signature);\\n    return recoveredAddress == signer;\\n  }\"}","{\"contract\": \"0xeee8aed1957ca1545a0508afb51b53cca7e3c0d1\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xeee8aed1957ca1545a0508afb51b53cca7e3c0d1\", \"contract_name\": \"PendlePrincipalToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xeee8aed1957ca1545a0508afb51b53cca7e3c0d1\", \"contract_name\": \"PendleERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x76ce2cb1ae48fa067f4fb8c5f803111ae0b24bea\", \"contract_name\": \"ForwarderEOAOnly\", \"sol_function\": \"function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) {\\n        address signer = _hashTypedDataV4(\\n            keccak256(abi.encode(_TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))\\n        ).recover(signature);\\n        return _nonces[req.from] == req.nonce && signer == req.from;\\n    }\"}","{\"contract\": \"0x76ce2cb1ae48fa067f4fb8c5f803111ae0b24bea\", \"contract_name\": \"MinimalForwarderEOAOnly\", \"sol_function\": \"function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) {\\n        address signer = _hashTypedDataV4(\\n            keccak256(abi.encode(_TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))\\n        ).recover(signature);\\n        return _nonces[req.from] == req.nonce && signer == req.from;\\n    }\"}","{\"contract\": \"0x5aa1ef3e3f29d25785b031fc58280a4c0ec786f1\", \"contract_name\": \"VispxWhitelist\", \"sol_function\": \"function getSignerAddress(bytes32 _messageHash, bytes memory _signature)\\n        public\\n        pure\\n        returns (address signer)\\n    {\\n        return ECDSA.recover(_messageHash, _signature);\\n    }\"}","{\"contract\": \"0x5aa1ef3e3f29d25785b031fc58280a4c0ec786f1\", \"contract_name\": \"PreSalePool02\", \"sol_function\": \"function getSignerAddress(bytes32 _messageHash, bytes memory _signature)\\n        public\\n        pure\\n        returns (address signer)\\n    {\\n        return ECDSA.recover(_messageHash, _signature);\\n    }\"}","{\"contract\": \"0xdc47edc036daae45d3f019ccfd443bf72fbd981c\", \"contract_name\": \"MultisigValidatorManager\", \"sol_function\": \"function _recoverCheckpointSigner(\\n        bytes32 _root,\\n        uint256 _index,\\n        bytes calldata _signature\\n    ) internal view returns (address) {\\n        bytes32 _digest = keccak256(\\n            abi.encodePacked(domainHash, _root, _index)\\n        );\\n        return ECDSA.recover(ECDSA.toEthSignedMessageHash(_digest), _signature);\\n    }\"}","{\"contract\": \"0xdc47edc036daae45d3f019ccfd443bf72fbd981c\", \"contract_name\": \"TestMultisigValidatorManager\", \"sol_function\": \"function _recoverCheckpointSigner(\\n        bytes32 _root,\\n        uint256 _index,\\n        bytes calldata _signature\\n    ) internal view returns (address) {\\n        bytes32 _digest = keccak256(\\n            abi.encodePacked(domainHash, _root, _index)\\n        );\\n        return ECDSA.recover(ECDSA.toEthSignedMessageHash(_digest), _signature);\\n    }\"}","{\"contract\": \"0xdc47edc036daae45d3f019ccfd443bf72fbd981c\", \"contract_name\": \"InboxValidatorManager\", \"sol_function\": \"function _recoverCheckpointSigner(\\n        bytes32 _root,\\n        uint256 _index,\\n        bytes calldata _signature\\n    ) internal view returns (address) {\\n        bytes32 _digest = keccak256(\\n            abi.encodePacked(domainHash, _root, _index)\\n        );\\n        return ECDSA.recover(ECDSA.toEthSignedMessageHash(_digest), _signature);\\n    }\"}","{\"contract\": \"0xdc47edc036daae45d3f019ccfd443bf72fbd981c\", \"contract_name\": \"OutboxValidatorManager\", \"sol_function\": \"function _recoverCheckpointSigner(\\n        bytes32 _root,\\n        uint256 _index,\\n        bytes calldata _signature\\n    ) internal view returns (address) {\\n        bytes32 _digest = keccak256(\\n            abi.encodePacked(domainHash, _root, _index)\\n        );\\n        return ECDSA.recover(ECDSA.toEthSignedMessageHash(_digest), _signature);\\n    }\"}","{\"contract\": \"0x219589690f8163a38da35fe082ee442f1dd90a9d\", \"contract_name\": \"DelegatePermit\", \"sol_function\": \"function _verifyDelegatePermit(\\n        address delegator,\\n        address delegatee,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(\\n            block.timestamp <= deadline,\\n            \\\"DelegatePermit: expired deadline\\\"\\n        );\\n        require(delegator != address(0), \\\"invalid delegator\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _DELEGATE_TYPEHASH,\\n                delegator,\\n                delegatee,\\n                _useDelegationNonce(delegator),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == delegator, \\\"DelegatePermit: invalid signature\\\");\\n    }\"}","{\"contract\": \"0x219589690f8163a38da35fe082ee442f1dd90a9d\", \"contract_name\": \"ECO\", \"sol_function\": \"function _verifyDelegatePermit(\\n        address delegator,\\n        address delegatee,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(\\n            block.timestamp <= deadline,\\n            \\\"DelegatePermit: expired deadline\\\"\\n        );\\n        require(delegator != address(0), \\\"invalid delegator\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _DELEGATE_TYPEHASH,\\n                delegator,\\n                delegatee,\\n                _useDelegationNonce(delegator),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == delegator, \\\"DelegatePermit: invalid signature\\\");\\n    }\"}","{\"contract\": \"0x219589690f8163a38da35fe082ee442f1dd90a9d\", \"contract_name\": \"ECO\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x219589690f8163a38da35fe082ee442f1dd90a9d\", \"contract_name\": \"ECOx\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x219589690f8163a38da35fe082ee442f1dd90a9d\", \"contract_name\": \"ERC20\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x219589690f8163a38da35fe082ee442f1dd90a9d\", \"contract_name\": \"ERC20Pausable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x219589690f8163a38da35fe082ee442f1dd90a9d\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x219589690f8163a38da35fe082ee442f1dd90a9d\", \"contract_name\": \"InflationCheckpoints\", \"sol_function\": \"function _verifyDelegatePermit(\\n        address delegator,\\n        address delegatee,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(\\n            block.timestamp <= deadline,\\n            \\\"DelegatePermit: expired deadline\\\"\\n        );\\n        require(delegator != address(0), \\\"invalid delegator\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _DELEGATE_TYPEHASH,\\n                delegator,\\n                delegatee,\\n                _useDelegationNonce(delegator),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == delegator, \\\"DelegatePermit: invalid signature\\\");\\n    }\"}","{\"contract\": \"0x219589690f8163a38da35fe082ee442f1dd90a9d\", \"contract_name\": \"InflationCheckpoints\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x219589690f8163a38da35fe082ee442f1dd90a9d\", \"contract_name\": \"VoteCheckpoints\", \"sol_function\": \"function _verifyDelegatePermit(\\n        address delegator,\\n        address delegatee,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(\\n            block.timestamp <= deadline,\\n            \\\"DelegatePermit: expired deadline\\\"\\n        );\\n        require(delegator != address(0), \\\"invalid delegator\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _DELEGATE_TYPEHASH,\\n                delegator,\\n                delegatee,\\n                _useDelegationNonce(delegator),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == delegator, \\\"DelegatePermit: invalid signature\\\");\\n    }\"}","{\"contract\": \"0x219589690f8163a38da35fe082ee442f1dd90a9d\", \"contract_name\": \"VoteCheckpoints\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x219589690f8163a38da35fe082ee442f1dd90a9d\", \"contract_name\": \"ECOxStaking\", \"sol_function\": \"function _verifyDelegatePermit(\\n        address delegator,\\n        address delegatee,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(\\n            block.timestamp <= deadline,\\n            \\\"DelegatePermit: expired deadline\\\"\\n        );\\n        require(delegator != address(0), \\\"invalid delegator\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _DELEGATE_TYPEHASH,\\n                delegator,\\n                delegatee,\\n                _useDelegationNonce(delegator),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == delegator, \\\"DelegatePermit: invalid signature\\\");\\n    }\"}","{\"contract\": \"0x219589690f8163a38da35fe082ee442f1dd90a9d\", \"contract_name\": \"ECOxStaking\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xc2170f947ab74a864bca72736f3fe9e5209f7bc9\", \"contract_name\": \"DoorsAdditions\", \"sol_function\": \"function validateUsingECDASignature(bytes calldata signature, uint256 amount) private view\\r\\n  {\\r\\n    bytes32 hash = keccak256(\\r\\n      abi.encodePacked(\\r\\n        bytes32(uint256(uint160(address(this)))),\\r\\n        bytes32(uint256(uint160(msg.sender))),\\r\\n        addressNonce[msg.sender],\\r\\n        amount\\r\\n      )\\r\\n    );\\r\\n    require(\\r\\n      signerAddress == hash.toEthSignedMessageHash().recover(signature),\\r\\n      \\\"Signer address mismatch.\\\"\\r\\n    );\\r\\n  }\"}","{\"contract\": \"0x153f8df0ce6a014e21f6fe6825129c53fa6ce0d8\", \"contract_name\": \"KILLAGEAR\", \"sol_function\": \"function checkSignature(\\n        uint256 nonce,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        uint256 expires,\\n        bytes calldata signature\\n    ) private view {\\n        if (\\n            signer !=\\n            ECDSA\\n                .toEthSignedMessageHash(\\n                    abi.encodePacked(msg.sender, nonce, ids, amounts, expires)\\n                )\\n                .recover(signature)\\n        ) revert InvalidSignature();\\n    }\"}","{\"contract\": \"0x6003994adeca13407e8dbee808280cc3ef2ab820\", \"contract_name\": \"FeralfileExhibitionV3\", \"sol_function\": \"function isValidRequest(\\r\\n        bytes32 message_,\\r\\n        address owner_,\\r\\n        bytes32 r_,\\r\\n        bytes32 s_,\\r\\n        uint8 v_\\r\\n    ) internal pure returns (bool) {\\r\\n        address signer = ECDSA.recover(\\r\\n            ECDSA.toEthSignedMessageHash(message_),\\r\\n            v_,\\r\\n            r_,\\r\\n            s_\\r\\n        );\\r\\n        return signer == owner_;\\r\\n    }\"}","{\"contract\": \"0x6003994adeca13407e8dbee808280cc3ef2ab820\", \"contract_name\": \"FeralfileExhibitionV3_2\", \"sol_function\": \"function isValidRequest(\\r\\n        bytes32 message_,\\r\\n        address owner_,\\r\\n        bytes32 r_,\\r\\n        bytes32 s_,\\r\\n        uint8 v_\\r\\n    ) internal pure returns (bool) {\\r\\n        address signer = ECDSA.recover(\\r\\n            ECDSA.toEthSignedMessageHash(message_),\\r\\n            v_,\\r\\n            r_,\\r\\n            s_\\r\\n        );\\r\\n        return signer == owner_;\\r\\n    }\"}","{\"contract\": \"0x7b67e3661942fda6c1d73bbe99856b6a11cdd2ee\", \"contract_name\": \"OrderOfInk\", \"sol_function\": \"function autoclave (\\n     /*          \\u2584\\u2588\\u2588\\u256c\\u255a\\u0393\\u0393\\u2591\\u2591\\u2591\\u2514\\u2591\\u2591!!!!!!\\u2514\\u2514\\u2591\\u2591\\u2591\\u0393\\u2559\\u2569\\u256c\\u2593\\u2584 */ bytes calldata signature,\\n     /*        \\u2584\\u2588\\u256c\\u255a\\u0393\\u2591\\u2591\\u2514:\\u2310\\\".\\u2584'^'.\\u2584\\u00b5^'.,\\\"\\\"\\\":!!\\u2591\\u2559\\u2569\\u256c\\u258c\\u00b5 */ MintKey calldata key\\n     /*      \\u2553\\u2588\\u2580\\u2591\\u2591\\u2514\\\"^'^\\u2588\\u2588\\u2588\\u2584\\u2588\\u258c''\\u2593\\u2588 \\u2584\\u2588\\u2588\\u2588\\u2588\\u2500'''\\\"^\\\"!\\u2591\\u255a\\u256c\\u258c */ ) public view returns (bool) {\\n     /*     \\u2584\\u2593\\u2591\\u2591\\u2514^''''    \\u2559\\u2588\\u2588\\u258c \\u2588\\u258c\\u2588\\u2593        '''^':\\u2514\\u255a\\u2563\\u2584 */ bytes32 digest = _hashTypedDataV4(\\n     /*    \\u2584\\u2580\\u2591\\u2310^''.      \\u2553\\u2588\\u2588\\u2588\\u2588\\u2584\\u2588\\u2588\\u2580\\u2580\\u258c\\u2584    ,\\u00b5    '^\\u250c'\\u255a\\u256b\\u00b5 */ keccak256(abi.encode(\\n     /*   \\u2590\\u256c\\u2591\\u2310'^^.      \\u2584\\u2588\\u2588\\u256b\\u2588\\u2588\\u2580\\u2591\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u258c\\u2593\\u2580\\u2588\\u2588     '.\\u250c'\\u255a\\u2588 */  MINTKEY_TYPE_HASH,\\n     /*   \\u2593\\u2591\\u2310'^^..     \\u2584\\u2588\\u2588\\u2588\\u2588\\u2588b\\u03c6\\u2588\\u2588\\u2593\\u2559\\u2514\\u2514\\u2584\\u2584\\u2593\\u2588\\u2588\\u2588\\u2588\\u2584  .'''^!\\u2560\\u258c */ msg.sender,\\n     /*  j\\u2592\\u2591\\u2310~.~.    .\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2593\\u2592\\u2590\\u2588\\u2588\\u2580 :\\u2588\\u2559\\u2514\\u2559\\u2593\\u2588\\u2588\\u2588J    ''~^\\u03c6\\u2588 */ key.free,\\n     /*  \\u2590\\u2592\\u2591~.^~'    \\u2588\\u2588\\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2593\\u2593\\u00bcQ\\u2588\\u2584\\u2593\\u2580\\u2593\\u256b\\u258c       ''^:\\u2591\\u2588 */ key.allowed )));\\n     /*   \\u2592\\u2591\\u2310.^~.    \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2510~\\u2559\\u2580\\u2588\\u2584\\u2310\\u2590\\u2588\\u2588\\u258c  \\u2588\\u2500       .^.]\\u2591\\u2588 */ return ECDSA.recover(\\n     /*   \\u256c\\u255a\\u2591.^~    \\u00b5\\u2590\\u2588\\u2588\\u2588\\u2588\\u2588\\u00ff\\u00bf ^m\\u2559\\u2559\\u2514\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u252c-\\u2584\\u2310   .'.:\\u2591\\u2560\\u258c */ digest, signature\\n     /*   \\u2514\\u2592\\u2592\\u2229'^.'  \\u2559Q\\u2588\\u2588\\u2588\\u2588\\u2592\\u2591>  \\u2553''\\u2565\\u2588\\u258c\\u2559\\u2588\\u2588\\u2588\\u00b5]\\u2580    ''\\u250c\\u2591\\u2592\\u2593 */ ) == _signer; }\"}","{\"contract\": \"0x7b67e3661942fda6c1d73bbe99856b6a11cdd2ee\", \"contract_name\": \"OrderOfInk\", \"sol_function\": \"function autoclaveCombine(\\n     /*      \\u2514\\u256c\\u2592\\u2591\\u250c^... \\u2559\\u00b5\\u2514\\u2588\\u2588\\u2588\\u2588\\u2584\\u2553\\u2588 \\u2559b\\u2553\\u2588\\u2588\\u2580\\u2580   ..,\\u250c\\u2591\\u2560\\u2569 */ bytes calldata signature,\\n     /* C      \\u2560\\u2592\\u2591-^... \\u2559\\u00b5 \\u2559\\u2588\\u2588\\u2588\\u2588\\u2584;\\u2554\\u2593\\u2588\\u2588\\u2588\\u2569 .....:\\u03c6\\u2592\\u2580 */ uint256[] calldata tokenIds\\n     /* H  S    \\u255a\\u2592\\u2591\\u2310^... \\u2559\\u00b5  \\u2559\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2580\\u2569  .'..:\\u03c6\\u2584\\u2568 */ ) public view returns (bool) {\\n     /* E  I     \\u255f\\u2592\\u2591'\\u250c^~' \\u2559\\u00b5  ^\\u2592\\u2559\\u2588\\u2559\\u2514 \\u2569  '.,.\\u250c\\u2591\\u2593\\u2310 */ bytes32 digest = _hashTypedDataV4(\\n     /* C  G  M   \\u2560\\u255a~\\\\\\\"^   \\u256b,,\\\"\\u2580\\u00a5\\u2580,\\u2553\\u258c  ...,^]\\u2560b */ keccak256(abi.encode(\\n     /* K  N  E   \\u2590\\u2591\\u2229\\u250c\\u250c.~' ]\\u2588  \\u2584\\u00e6\\u00b5 \\u2588\\u258c . .^\\u250c~\\u03c6\\u2593 */ COMBINEKEY_TYPE_HASH,\\n     /*    E  S    \\u2592\\u2591:\\u250c''~..\\u2588\\u2584\\u2563\\u2584,\\u2588\\u2584\\u2588T. '.\\u250c\\u250c,\\u2590\\u258c */ keccak256(abi.encodePacked(tokenIds)))));\\n     /* E  D  S    \\u255f\\u2560\\u2591\\\\\\u250c'^' \\u2590\\u2588\\u2593\\u256c\\u2588\\u2588\\u2563\\u2588 '..^\\u250c:\\u03c6\\u2563T */ return ECDSA.recover(\\n     /* I     A    \\u2580\\u2588\\u2584\\u2584\\u2584\\u2593\\u2593\\u258c\\u2593\\u2584\\u256b\\u2563\\u256b\\u2580W\\u2593\\u2593\\u258c\\u258c\\u2584\\u2584\\u258c\\u2593\\u2593 */ digest, signature\\n     /* P  T  G     \\u256b\\u2588\\u2588\\u2593\\u2593\\u256c\\u2584\\u2584\\u2588\\u2588\\u2588\\u2588\\u2588\\u258c\\u2560\\u256b\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u00b5 */ ) == _signer; }\"}","{\"contract\": \"0xca52c16c468624b78bd52431eb1b6856d38e61ff\", \"contract_name\": \"OxStandardV2\", \"sol_function\": \"function getEIP712RecoverAddress(bytes calldata signature)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        // Verify EIP-712 signature by recreating the data structure\\n        // that we signed on the client side, and then using that to recover\\n        // the address that signed the signature for this data.\\n        // Signature begin with \\\\x19\\\\x01, see: https://eips.ethereum.org/EIPS/eip-712\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(MINTER_TYPEHASH, msg.sender))\\n            )\\n        );\\n\\n        // Use the recover method to see what address was used to create\\n        // the signature on this data.\\n        // Note that if the digest doesn't exactly match what was signed we'll\\n        // get a random recovered address.\\n        return digest.recover(signature);\\n    }\"}","{\"contract\": \"0xca52c16c468624b78bd52431eb1b6856d38e61ff\", \"contract_name\": \"EIP712Whitelisting\", \"sol_function\": \"function getEIP712RecoverAddress(bytes calldata signature)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        // Verify EIP-712 signature by recreating the data structure\\n        // that we signed on the client side, and then using that to recover\\n        // the address that signed the signature for this data.\\n        // Signature begin with \\\\x19\\\\x01, see: https://eips.ethereum.org/EIPS/eip-712\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(MINTER_TYPEHASH, msg.sender))\\n            )\\n        );\\n\\n        // Use the recover method to see what address was used to create\\n        // the signature on this data.\\n        // Note that if the digest doesn't exactly match what was signed we'll\\n        // get a random recovered address.\\n        return digest.recover(signature);\\n    }\"}","{\"contract\": \"0xca52c16c468624b78bd52431eb1b6856d38e61ff\", \"contract_name\": \"UglyPeople\", \"sol_function\": \"function getEIP712RecoverAddress(bytes calldata signature)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        // Verify EIP-712 signature by recreating the data structure\\n        // that we signed on the client side, and then using that to recover\\n        // the address that signed the signature for this data.\\n        // Signature begin with \\\\x19\\\\x01, see: https://eips.ethereum.org/EIPS/eip-712\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(MINTER_TYPEHASH, msg.sender))\\n            )\\n        );\\n\\n        // Use the recover method to see what address was used to create\\n        // the signature on this data.\\n        // Note that if the digest doesn't exactly match what was signed we'll\\n        // get a random recovered address.\\n        return digest.recover(signature);\\n    }\"}","{\"contract\": \"0x73e4c6be50eebe486b328c23b1f1e460e3584f2e\", \"contract_name\": \"SignatureChecker\", \"sol_function\": \"function validSignature(\\n        EnumerableSet.AddressSet storage signers,\\n        bytes32 message,\\n        bytes calldata signature\\n    ) internal view returns (bool) {\\n        return signers.contains(ECDSA.recover(message, signature));\\n    }\"}","{\"contract\": \"0xa5a6a988e6cec7ccdf01e96266de1f2b623bbf73\", \"contract_name\": \"BridgeCosignerManager\", \"sol_function\": \"function recover(\\n        bytes32 hash,\\n        bytes calldata signature\\n    ) internal pure returns (address) {\\n        return hash.toEthSignedMessageHash().recover(signature);\\n    }\"}","{\"contract\": \"0x7a655a234ddf076c3530ac847040f8d8c5115021\", \"contract_name\": \"Presale\", \"sol_function\": \"function _verifyLuckySignature(uint256 _maxAmount, bytes calldata _signature) internal view {\\n        bytes32 signedMessageHash = MessageHashUtils.toEthSignedMessageHash(\\n            keccak256(abi.encode(_getDomainSeparator(), _maxAmount, msg.sender))\\n        );\\n        address recoveredOwner = ECDSA.recover(signedMessageHash, _signature);\\n\\n        if (recoveredOwner != luckySigner) {\\n            revert InvalidSignature();\\n        }\\n    }\"}","{\"contract\": \"0x4d73c0a7161898cb54ad93ae01cf3987cd65899f\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x4d73c0a7161898cb54ad93ae01cf3987cd65899f\", \"contract_name\": \"WSTFXtoken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xbdf6edbe467b96b002cf06388c8c0a28016a1d3e\", \"contract_name\": \"TakrutSaleV2\", \"sol_function\": \"function _verify(\\n        uint256 saleId,\\n        bytes32 digest,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        return\\n            _saleConfig[saleId].signerAddress ==\\n            ECDSAUpgradeable.recover(digest, signature);\\n    }\"}","{\"contract\": \"0xbdf6edbe467b96b002cf06388c8c0a28016a1d3e\", \"contract_name\": \"TakrutSaleV2\", \"sol_function\": \"function _verifyFreeMint(bytes32 digest, bytes memory signature)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return\\n            freeMintSignerAddress ==\\n            ECDSAUpgradeable.recover(digest, signature);\\n    }\"}","{\"contract\": \"0xbdf6edbe467b96b002cf06388c8c0a28016a1d3e\", \"contract_name\": \"TakrutV2\", \"sol_function\": \"function _verify(\\n        uint256 saleId,\\n        bytes32 digest,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        return\\n            _saleConfig[saleId].signerAddress ==\\n            ECDSAUpgradeable.recover(digest, signature);\\n    }\"}","{\"contract\": \"0xbdf6edbe467b96b002cf06388c8c0a28016a1d3e\", \"contract_name\": \"TakrutV2\", \"sol_function\": \"function _verifyFreeMint(bytes32 digest, bytes memory signature)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return\\n            freeMintSignerAddress ==\\n            ECDSAUpgradeable.recover(digest, signature);\\n    }\"}","{\"contract\": \"0xf4a554097a4fba414cc71bfd0e2428a9bce22b47\", \"contract_name\": \"PresaleAccessControlHandler\", \"sol_function\": \"function recoverSignerAddress(\\n    uint256 nonce,\\n    address sender,\\n    bytes calldata signature\\n  ) internal pure returns (address) {\\n    bytes32 message = keccak256(abi.encode(nonce, sender));\\n\\n    bytes32 digest = ECDSA.toEthSignedMessageHash(message);\\n    return ECDSA.recover(digest, signature);\\n  }\"}","{\"contract\": \"0x3ffd8b918917727c6f226f4eb88e33e452802294\", \"contract_name\": \"ExecutorV3\", \"sol_function\": \"function execute(\\n        uint16 callerChainId_,\\n        uint16 executionChainId_,\\n        uint256 nonce_,\\n        string calldata txHash_,\\n        address contract_,\\n        bytes calldata callData_,\\n        bytes calldata signature_\\n    ) external whenNotPaused whenInitialized mutex returns (bytes memory) {\\n        require(chainId == executionChainId_, \\\"uncompatible chain\\\");\\n        require(contract_ != address(0), \\\"zero address\\\");\\n\\n        bytes32 data = keccak256(\\n            abi.encodePacked(\\n                callerChainId_,\\n                executionChainId_,\\n                nonce_,\\n                bytes(txHash_).length,\\n                txHash_,\\n                contract_,\\n                callData_.length,\\n                callData_\\n            )\\n        );\\n\\n        require(hashes[data] == 0, \\\"duplicate data\\\");\\n        require(\\n            ECDSA.recover(\\n                keccak256(\\n                    abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", data)\\n                ),\\n                signature_\\n            ) == protocolSigner,\\n            \\\"only protocol signer\\\"\\n        );\\n        hashes[data] = block.number;\\n\\n        (bool success_, bytes memory data_) = contract_.call(callData_);\\n        if (success_) {\\n            emit Executed(callerChainId_, executionChainId_, nonce_, contract_);\\n            return data_;\\n        } else {\\n            if (data_.length > 0) {\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(data_)\\n                    revert(add(32, data_), returndata_size)\\n                }\\n            } else {\\n                revert(\\\"no error\\\");\\n            }\\n        }\\n    }\"}","{\"contract\": \"0x40909204bf1d4ff728700bddd927dffd85252d87\", \"contract_name\": \"MetaZeroCS2Guns\", \"sol_function\": \"function verify(\\r\\n        address _minter,\\r\\n        uint256[] memory tokenIds,\\r\\n        uint256 _nonce,\\r\\n        uint256 _chainId,\\r\\n        bytes memory signature\\r\\n    ) public view returns (bool) {\\r\\n        bytes32 messageHash = getMessageHash(\\r\\n            _minter,\\r\\n            tokenIds,\\r\\n            _nonce,\\r\\n            _chainId\\r\\n        );\\r\\n\\r\\n        return\\r\\n            isMinter[messageHash.toEthSignedMessageHash().recover(signature)];\\r\\n    }\"}","{\"contract\": \"0xc1920908a3785907051929450683e8c0659a742b\", \"contract_name\": \"Sushib\", \"sol_function\": \"function claim(address account, uint256 amount, uint8 v, bytes32 r, bytes32 s, address to) external {\\n        require(!claimed[account], \\\"SUSHIB: ALREADY_CLAIMED\\\");\\n        bytes32 hash = keccak256(abi.encode(account, amount));\\n        require(ECDSA.recover(hash, v, r, s) == signer, \\\"SUSHIB: INVALID_SIGNATURE\\\");\\n        claimed[account] = true;\\n        _mint(to, amount);\\n\\n        emit Claim(account, amount, to);\\n    }\"}","{\"contract\": \"0xf5b9fb36aec4b49de062f700d8ec6c791590a226\", \"contract_name\": \"Multi_Sig\", \"sol_function\": \"function replaceAdmin(address adminToBan, address newAdmin, bytes[] memory _signatures) external onlyAdmin returns(bool){\\r\\n          require(adminMapping[adminToBan] == keccak256(\\\"admin\\\"),\\\"must ban a current admin\\\");\\r\\n            require(adminMapping[newAdmin] != keccak256(\\\"admin\\\"),\\\"New Admin Can't Be Old Admin\\\");\\r\\n          //init an address to be used later\\r\\n        address curr_signer;\\r\\n        uint256 count;\\r\\n        bytes32 hash = keccak256(abi.encodePacked(ballotNumber,adminToBan,newAdmin));\\r\\n        for(uint256 i;i<_signatures.length;i++){\\r\\n           curr_signer  = hash.toEthSignedMessageHash().recover(_signatures[i]);\\r\\n            if(adminMapping[curr_signer] == keccak256(\\\"admin\\\")){\\r\\n                //Prevent Voter Manipulation\\r\\n                if(voteHelper[ballotNumber].hasVoted[curr_signer] == false){\\r\\n                voteHelper[ballotNumber].hasVoted[curr_signer] = true;\\r\\n                count++;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        //at least 3 votes?\\r\\n            if(count>2){\\r\\n                  uint256 indexOfOldAdmin = getIndexOfAdmin(adminToBan);\\r\\n                  payroll[indexOfOldAdmin] = newAdmin;\\r\\n                delete adminMapping[adminToBan];\\r\\n                adminMapping[newAdmin] = keccak256(\\\"admin\\\"); \\r\\n              \\r\\n                ballotNumber++;\\r\\n                return true;\\r\\n            }\\r\\n\\r\\n            //If Not Enough Votes, Reset Storage\\r\\n            revert(\\\"Not Enough Votes\\\");\\r\\n          \\r\\n    }\"}","{\"contract\": \"0xf5b9fb36aec4b49de062f700d8ec6c791590a226\", \"contract_name\": \"Multi_Sig\", \"sol_function\": \"function approveTransferOwnership(address newOwner,bytes[] memory signatures) public  returns(bool){\\r\\n        address curr_signer;\\r\\n        uint256 count;\\r\\n        bytes32 hash = keccak256(abi.encodePacked(ballotNumber,newOwner));\\r\\n        for(uint256 i;i<signatures.length;i++){\\r\\n          curr_signer = hash.toEthSignedMessageHash().recover(signatures[i]);\\r\\n          if(adminMapping[curr_signer] == keccak256(\\\"admin\\\")){\\r\\n\\r\\n              //Prevent Voter Manipulation\\r\\n             \\r\\n              if(voteHelper[ballotNumber].hasVoted[curr_signer] == false){\\r\\n              voteHelper[ballotNumber].hasVoted[curr_signer] = true;\\r\\n              //add to count\\r\\n                count++;\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n            if(count>2){\\r\\n                voteHelper[ballotNumber].isApproved = true;\\r\\n                voteHelper[ballotNumber].newOwner = newOwner;\\r\\n                return true;\\r\\n            }\\r\\n            revert(\\\"Not Enough Votes\\\");\\r\\n    }\"}","{\"contract\": \"0x7b1d45e2cd6b6a8e329c1ad8062d65278aa982ac\", \"contract_name\": \"ERC20PermitUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x7b1d45e2cd6b6a8e329c1ad8062d65278aa982ac\", \"contract_name\": \"LibertiVault\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x38bdb0c4ee1acf66d69d20ec694fa62d988c97bf\", \"contract_name\": \"ERC721AFacet\", \"sol_function\": \"function mint(uint256 allowedStartDate, bytes calldata signature) payable external {\\n        require(\\n            keccak256(abi.encodePacked(msg.sender, allowedStartDate)).toEthSignedMessageHash().recover(signature) ==\\n            s.signingAddress,\\n            \\\"Invalid signature\\\"\\n        );\\n        require(s.mintOpen, \\\"Mint not open\\\");\\n        require(_numberMinted(msg.sender) + 1 <= s.maxMintsPerWallet, \\\"Too many mints\\\");\\n        require(_totalMinted() + 1 <= s.maxSupply, \\\"No more mints\\\");\\n        require(msg.value == s.mintPrice, \\\"Wrong value sent\\\");\\n        require(allowedStartDate <= block.timestamp, \\\"Wrong mint time\\\");\\n        _safeMint(msg.sender, 1);\\n        Address.sendValue(payable(s.royaltiesRecipient), address(this).balance);\\n    }\"}","{\"contract\": \"0xcf7ca3145f46d00961fbe391479c2227c5be4f48\", \"contract_name\": \"SignatureChecker\", \"sol_function\": \"function isValidSignatureNow(\\n        address signer,\\n        bytes32 digest,\\n        bytes memory signature\\n    ) external view returns (bool) {\\n        if (!isContract(signer)) {\\n            return ECRecover.recover(digest, signature) == signer;\\n        }\\n        return isValidERC1271SignatureNow(signer, digest, signature);\\n    }\"}","{\"contract\": \"0x3a2096754df385553c4252e5a82dc862e64169bb\", \"contract_name\": \"ThePossessed\", \"sol_function\": \"function verifySig(address sender, uint256 maxMintable, uint256 valueSent, bytes memory signature) internal view returns(bool) {\\n        bytes32 messageHash = keccak256(abi.encodePacked(sender, maxMintable, valueSent));\\n        return signingAddress == messageHash.toEthSignedMessageHash().recover(signature);\\n    }\"}","{\"contract\": \"0x310e7d93675dc72c5e02796d91d147f1a7023c49\", \"contract_name\": \"PreSale\", \"sol_function\": \"function _verifyMessage(bytes32 encodedMessageHash, uint8 v, bytes32 r, bytes32 s) private view {\\n        if (signerWallet != ECDSA.recover(MessageHashUtils.toEthSignedMessageHash(encodedMessageHash), v, r, s)) {\\n            revert InvalidSignature();\\n        }\\n    }\"}","{\"contract\": \"0x521ad4c2497d7f0e8ddbdd023b8d7d0f7f84f3b3\", \"contract_name\": \"SODLDAO\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x521ad4c2497d7f0e8ddbdd023b8d7d0f7f84f3b3\", \"contract_name\": \"SodlDistributor\", \"sol_function\": \"function claim(\\n    string memory txHash,\\n    uint256 amount,\\n    uint256 blockNumber,\\n    bytes memory signature\\n  ) public {\\n    require(amount > 0, \\\"amount must be greater than 0\\\");\\n    require(claimedMap[txHash] == 0, \\\"Tx hash claimed already\\\");\\n    require(block.number < blockNumber, \\\"Invalid blockNumber\\\");\\n\\n    bytes32 message = keccak256(\\n      abi.encodePacked(txHash, amount, blockNumber, msg.sender)\\n    );\\n\\n    address signer = message.toEthSignedMessageHash().recover(signature);\\n    require(signer == owner(), \\\"Invalid signature\\\");\\n\\n    claimedMap[txHash] = amount;\\n    SODLDAO(token).mint(msg.sender, amount);\\n\\n    emit Claimed(msg.sender, amount, txHash);\\n  }\"}","{\"contract\": \"0x521ad4c2497d7f0e8ddbdd023b8d7d0f7f84f3b3\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x521ad4c2497d7f0e8ddbdd023b8d7d0f7f84f3b3\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x0df39fcaf8183ef3fc412441adaafd3f10c12360\", \"contract_name\": \"Tooney\", \"sol_function\": \"function recoverSigner(bytes32 hash, bytes memory signature)\\n        public\\n        pure\\n        returns (address)\\n    {\\n        bytes32 messageDigest = keccak256(\\n            abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)\\n        );\\n        return ECDSA.recover(messageDigest, signature);\\n    }\"}","{\"contract\": \"0x02b8ee5928af27c16134d58e014d434a9ed81d10\", \"contract_name\": \"FairXYZDeployer\", \"sol_function\": \"function overrideVariables(bytes memory signature, string memory newURI, string memory newPathURI, \\n        uint256 newPrice, uint256 newMaxMintsPerWallet, uint256 newRoyaltyPercentage)\\n        onlyOwner\\n        external\\n    {\\n        bytes32 messageHash = hashVariableChanges(msg.sender, newURI, newPathURI, \\n                                                  newPrice, newMaxMintsPerWallet, newRoyaltyPercentage);\\n        address signAdd = viewSigner();\\n        require(messageHash.recover(signature) == signAdd, \\\"Unrecognizable Hash\\\");\\n\\n        if(!lockURI)\\n        {\\n            if (bytes(newPathURI).length != 0)       \\n                pathURI = newPathURI;\\n                emit NewPathURI(pathURI);\\n\\n            if(bytes(newURI).length != 0)\\n            {\\n                _overrideURI = newURI;\\n                baseURI = \\\"\\\";\\n                emit NewTokenURI(_overrideURI);\\n            }\\n        }\\n\\n        if(newPrice!=nftPrice)\\n        {\\n            nftPrice = newPrice;\\n            emit NewPriceSet(nftPrice);\\n        }\\n\\n        if(newMaxMintsPerWallet!=maxMintsPerWallet)\\n        {\\n            maxMintsPerWallet = newMaxMintsPerWallet;\\n            emit NewMaxMintsPerWalletSet(maxMintsPerWallet);\\n        }\\n\\n        if(newRoyaltyPercentage != royaltyPercentage)\\n        {      \\n            royaltyPercentage = newRoyaltyPercentage;\\n            emit NewTokenRoyaltySet(royaltyPercentage);\\n        }\\n    }\"}","{\"contract\": \"0x02b8ee5928af27c16134d58e014d434a9ed81d10\", \"contract_name\": \"FairXYZDeployer\", \"sol_function\": \"function mint(bytes memory signature, uint256 nonce, uint256 numberOfTokens)\\n        payable\\n        external\\n        whenNotPaused\\n        saleIsOpen\\n        returns (uint256)\\n    {\\n        bytes32 messageHash = hashTransaction(msg.sender, numberOfTokens, nonce, address(this));\\n        address signAdd = viewSigner();\\n        require(messageHash.recover(signature) == signAdd, \\\"Unrecognizable Hash\\\");\\n        require(!usedHashes[messageHash], \\\"Reused Hash\\\");\\n        require(msg.value  >= nftPrice * numberOfTokens, \\\"You have not sent the required amount of ETH\\\");\\n        require(numberOfTokens <= 20, \\\"Token minting limit per transaction exceeded\\\");\\n        require(block.number <= nonce  + 20, \\\"Time limit has passed\\\");\\n        require(msg.sender == tx.origin, \\\"Cannot mint from contract\\\");\\n\\n        usedHashes[messageHash] = true;\\n\\n        uint256 origMintCount = numberOfTokens;\\n\\n        // If trying to mint more tokens than available -> reimburse for excess mints and allow for lower mint count\\n        // to avoid a failed tx\\n\\n        if(maxMintsPerWallet > 0)\\n        {\\n            require(mintsPerWallet[msg.sender] < maxMintsPerWallet, \\\"Exceeds number of mints per wallet\\\");\\n            \\n            if(mintsPerWallet[msg.sender] + numberOfTokens > maxMintsPerWallet)\\n            {\\n                numberOfTokens = maxMintsPerWallet - mintsPerWallet[msg.sender];\\n            }            \\n        }\\n \\n        if( (viewMinted() + numberOfTokens > maxTokens) )\\n        {\\n            numberOfTokens = maxTokens - viewMinted();\\n        }\\n\\n        uint256 reimbursement = origMintCount - numberOfTokens; \\n\\n        uint256 reimbursementPrice = reimbursement * nftPrice;\\n\\n        mintsPerWallet[msg.sender] += numberOfTokens;\\n\\n        _mint(msg.sender, numberOfTokens);\\n        \\n        // cap reimbursement at msg.value in case something goes wrong\\n        if( 0 < reimbursementPrice && reimbursementPrice < msg.value)\\n        {\\n            (bool sent, ) = msg.sender.call{value: reimbursementPrice}(\\\"\\\");\\n            require(sent, \\\"Failed to send Ether\\\");\\n        }\\n        \\n        return viewMinted();\\n    }\"}","{\"contract\": \"0xd6b03046a02b0dc26cac0903631fb08aec3d1750\", \"contract_name\": \"ERC20PermitUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xd6b03046a02b0dc26cac0903631fb08aec3d1750\", \"contract_name\": \"Pip\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xe4af56a674df3da83b22a04eeeaf983d40a9e1ab\", \"contract_name\": \"LavaWallet\", \"sol_function\": \"function tokenApprovalWithSignature(bool requiresKing, address from, address to, address token, uint256 tokens, uint256 relayerReward,\\r\\n                                     uint256 expires, bytes32 sigHash, bytes signature) internal returns (bool success)\\r\\n   {\\r\\n\\r\\n       address recoveredSignatureSigner = ECRecovery.recover(sigHash,signature);\\r\\n\\r\\n       //make sure the signer is the depositor of the tokens\\r\\n       if(from != recoveredSignatureSigner) revert();\\r\\n\\r\\n       if(msg.sender != getRelayingKing() && requiresKing ) revert();  // you must be the 'king of the hill' to relay\\r\\n\\r\\n       //make sure the signature has not expired\\r\\n       if(block.number > expires) revert();\\r\\n\\r\\n       uint burnedSignature = burnedSignatures[sigHash];\\r\\n       burnedSignatures[sigHash] = 0x1; //spent\\r\\n       if(burnedSignature != 0x0 ) revert();\\r\\n\\r\\n       //approve the relayer reward\\r\\n       allowed[token][from][msg.sender] = relayerReward;\\r\\n       Approval(from, token, msg.sender, relayerReward);\\r\\n\\r\\n       //transferRelayerReward\\r\\n       if(!transferTokensFrom(from, msg.sender, token, relayerReward)) revert();\\r\\n\\r\\n       //approve transfer of tokens\\r\\n       allowed[token][from][to] = tokens;\\r\\n       Approval(from, token, to, tokens);\\r\\n\\r\\n\\r\\n       return true;\\r\\n   }\"}","{\"contract\": \"0xe4af56a674df3da83b22a04eeeaf983d40a9e1ab\", \"contract_name\": \"LavaWallet\", \"sol_function\": \"function burnSignature(bytes methodname, address from, address to, address token, uint256 tokens, uint256 relayerReward, uint256 expires, uint256 nonce,  bytes signature) public returns (bool success)\\r\\n     {\\r\\n\\r\\n        bytes32 sigHash = getLavaTypedDataHash(methodname,from,to,token,tokens,relayerReward,expires,nonce);\\r\\n\\r\\n\\r\\n         address recoveredSignatureSigner = ECRecovery.recover(sigHash,signature);\\r\\n\\r\\n         //make sure the invalidator is the signer\\r\\n         if(recoveredSignatureSigner != from) revert();\\r\\n\\r\\n         //only the original packet owner can burn signature, not a relay\\r\\n         if(from != msg.sender) revert();\\r\\n\\r\\n         //make sure this signature has never been used\\r\\n         uint burnedSignature = burnedSignatures[sigHash];\\r\\n         burnedSignatures[sigHash] = 0x2; //invalidated\\r\\n         if(burnedSignature != 0x0 ) revert();\\r\\n\\r\\n         return true;\\r\\n     }\"}","{\"contract\": \"0xd6c21f24a63ce17241dee686cb4e4f8be72cdb55\", \"contract_name\": \"TRLabBuyNowV1\", \"sol_function\": \"function _verifySignedMessage(\\n        bytes32 messageHash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (bool) {\\n        address recoveredSigner = ECDSA.recover(ECDSA.toEthSignedMessageHash(messageHash), v, r, s);\\n        return isSigner(recoveredSigner);\\n    }\"}","{\"contract\": \"0xd6c21f24a63ce17241dee686cb4e4f8be72cdb55\", \"contract_name\": \"SignerRole\", \"sol_function\": \"function _verifySignedMessage(\\n        bytes32 messageHash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (bool) {\\n        address recoveredSigner = ECDSA.recover(ECDSA.toEthSignedMessageHash(messageHash), v, r, s);\\n        return isSigner(recoveredSigner);\\n    }\"}","{\"contract\": \"0x6c8a75d574809cdc81643374689cb751abb0a61c\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x6c8a75d574809cdc81643374689cb751abb0a61c\", \"contract_name\": \"AIRobot\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xa2833c0fdeacfd2510243222f6fea7881e8e6c68\", \"contract_name\": \"LaunchpadV2\", \"sol_function\": \"function mintWhitelisted(\\n        address contractAddress,\\n        uint256 batchSize,\\n        bytes memory signature\\n    ) external payable nonReentrant {\\n\\n        //  Check whitelist validator signature\\n        Campaign memory campaign = getCampaign(contractAddress, CampaignMode.whitelisted);\\n        require(campaign.contractAddress != address(0), \\\"contract not register\\\");\\n\\n        bytes32 messageHash = keccak256(abi.encodePacked(block.chainid, address(this), contractAddress, msg.sender));\\n        bytes32 proof = ECDSA.toEthSignedMessageHash(messageHash);\\n        require(ECDSA.recover(proof, signature) == campaign.validator, \\\"whitelist verification failed\\\");\\n\\n        // activity check\\n        mint_(contractAddress, batchSize, CampaignMode.whitelisted);\\n\\n    }\"}","{\"contract\": \"0x64d17beae666cc435b9d40a21f058b379b2a0194\", \"contract_name\": \"Supervisor\", \"sol_function\": \"function checkSignatures(bytes32 sigIdHash, bytes[] memory signatures) public view {\\n        require(signatures.length >= threshold, \\\"ERR_NOT_ENOUGH_SIGNATURES\\\");\\n        address prevAddress = address(0);\\n        for (uint i; i < threshold; i++) {\\n            address recovered = sigIdHash.recover(signatures[i]);\\n            require(validators[recovered], \\\"ERR_NOT_VALIDATOR\\\");\\n            require(recovered > prevAddress, \\\"ERR_WRONG_SIGNER_ORDER\\\");\\n            prevAddress = recovered;\\n        }\\n    }\"}","{\"contract\": \"0xed911640fd86f92fd1337526010adda8f3eb8344\", \"contract_name\": \"LibChannelCrypto\", \"sol_function\": \"function recoverChannelMessageSigner(bytes32 hash, bytes memory signature)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        bytes32 digest = toChannelSignedMessage(hash);\\n        return ECDSA.recover(digest, signature);\\n    }\"}","{\"contract\": \"0xed911640fd86f92fd1337526010adda8f3eb8344\", \"contract_name\": \"LibChannelCrypto\", \"sol_function\": \"function recoverUtilityMessageSigner(bytes32 hash, bytes memory signature)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        bytes32 digest = toUtilitySignedMessage(hash);\\n        return ECDSA.recover(digest, signature);\\n    }\"}","{\"contract\": \"0xc0ddb231649b764911bdd2dda49c84f978f8019a\", \"contract_name\": \"ForeverPunks\", \"sol_function\": \"function validSignature(\\n    bytes memory signature,\\n    bytes32 msgHash\\n  ) public view returns (bool) {\\n    return msgHash.toEthSignedMessageHash().recover(signature) == SIGNER;\\n  }\"}","{\"contract\": \"0x739682ef459f2288d64d15a16890804b715c058e\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x739682ef459f2288d64d15a16890804b715c058e\", \"contract_name\": \"PoolToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xf84c7565e8646429ed5524ebfbd1a611d9a5d335\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xf84c7565e8646429ed5524ebfbd1a611d9a5d335\", \"contract_name\": \"DecentralizedIndex\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xf84c7565e8646429ed5524ebfbd1a611d9a5d335\", \"contract_name\": \"WeightedIndex\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x578c55fa6890b30ef74ccd3af52f455bbcca4d3e\", \"contract_name\": \"SigVerifier\", \"sol_function\": \"function verifySig(bytes32 _hash, bytes memory _feeSig) internal view {\\n        address _signer = _hash.recover(_feeSig);\\n        require(_signer == signer, \\\"invalid signer\\\");\\n    }\"}","{\"contract\": \"0x578c55fa6890b30ef74ccd3af52f455bbcca4d3e\", \"contract_name\": \"TransferSwapper\", \"sol_function\": \"function verifySig(bytes32 _hash, bytes memory _feeSig) internal view {\\n        address _signer = _hash.recover(_feeSig);\\n        require(_signer == signer, \\\"invalid signer\\\");\\n    }\"}","{\"contract\": \"0x16b68e1c5d3b9b3028978d96e106d3a5c3b42093\", \"contract_name\": \"TokenVestingLinear\", \"sol_function\": \"function _validateSignature(bytes32 user, address recepientWallet, bytes calldata signature) internal view returns (bool) {\\n      bytes32 dataHash = keccak256(abi.encode(user, recepientWallet));\\n      bytes32 message = ECDSA.toEthSignedMessageHash(dataHash);\\n\\n      address receivedAddress = ECDSA.recover(message, signature);\\n      return (receivedAddress != address(0) && receivedAddress == signerAddress);\\n    }\"}","{\"contract\": \"0xe9f5cd35e6d87ffadf8459795b6c28d437772628\", \"contract_name\": \"BOBLCarePackage\", \"sol_function\": \"function recoverSigner(bytes32 _hash, bytes memory _signature) public pure returns (address) {\\n        bytes32 messageDigest = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _hash));\\n        return ECDSA.recover(messageDigest, _signature);\\n    }\"}","{\"contract\": \"0x49d438246de154e48c74b2d47aa0d60ca7584cee\", \"contract_name\": \"StructOffsetManager\", \"sol_function\": \"function offsetWithVRF(Offsetable offsetable, bytes memory signature) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        if (Ownable(address(offsetable)).owner() != ECDSA.recover(\\n            ECDSA.toEthSignedMessageHash(\\n                keccak256(abi.encodePacked(\\\"VRF_OFFSET\\\", address(offsetable)))\\n            ),\\n            signature\\n        )) revert StructOffsetManager_SignerNotContractOwner();\\n\\n        _requests[_COORDINATOR.requestRandomWords(\\n            _VRF_REQUEST_CONFIG.keyHash,\\n            _VRF_REQUEST_CONFIG.subId,\\n            _VRF_REQUEST_CONFIG.requestConfirmations,\\n            _VRF_REQUEST_CONFIG.callbackGasLimit,\\n            1 // number of random words\\n        )] = offsetable;\\n    }\"}","{\"contract\": \"0x7fb439601528b63aa85bc559d410cbffd63796de\", \"contract_name\": \"MBLKVesting\", \"sol_function\": \"function recover(bytes32 hash, bytes memory signature_) private pure returns(address) {\\r\\n        return hash.recover(signature_);\\r\\n    }\"}","{\"contract\": \"0xb8cdbceb2a3d31048ddbc7ffde6ad112828be898\", \"contract_name\": \"ERC20Base\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = ECDSA.toTypedDataHash(DOMAIN_SEPARATOR(), structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xb8cdbceb2a3d31048ddbc7ffde6ad112828be898\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = ECDSA.toTypedDataHash(DOMAIN_SEPARATOR(), structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x0abd5db5b817100c386047fc3e393713fcd7c3ae\", \"contract_name\": \"MenaceWarriors\", \"sol_function\": \"function VIPMint(address _account, uint _quantity, bytes calldata signature) external {\\r\\n        if(sellingStep != Step.VIPSale) revert(\\\"VIP Mint is not open\\\");\\r\\n        if(totalSupply() + _quantity > MAX_SUPPLY) revert(\\\"Max supply for VIP exceeded\\\");\\r\\n        if(signerAddressVIP != keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\r\\n                bytes32(uint256(uint160(msg.sender)))\\r\\n            )\\r\\n        ).recover(signature)) revert(\\\"You are not in VIP whitelist\\\");\\r\\n        if(mintedAmountNFTsperWalletVIPSale[msg.sender] + _quantity > maxMintAmountPerVIP) revert(\\\"You can only get 1 NFT on the VIP Sale\\\");\\r\\n            \\r\\n        mintedAmountNFTsperWalletVIPSale[msg.sender] += _quantity;\\r\\n        \\r\\n        // The _numberMinted is incremented internally\\r\\n        _mint(_account, _quantity);\\r\\n    }\"}","{\"contract\": \"0x0abd5db5b817100c386047fc3e393713fcd7c3ae\", \"contract_name\": \"MenaceWarriors\", \"sol_function\": \"function WLMint(address _account, uint _quantity, bytes calldata signature) external payable {\\r\\n        uint price = wlSalePrice;\\r\\n        if(price <= 0) revert(\\\"Price is 0\\\");\\r\\n\\r\\n        if(sellingStep != Step.WhitelistSale) revert(\\\"WL Mint not live.\\\");\\r\\n        if(totalSupply() + _quantity > (MAX_SUPPLY - MAX_VIP)) revert(\\\"Max supply exceeded for WL exceeded\\\");\\r\\n        if(msg.value < price * _quantity) revert(\\\"Not enough funds\\\");          \\r\\n        if(signerAddressWL != keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\r\\n                bytes32(uint256(uint160(msg.sender)))\\r\\n            )\\r\\n        ).recover(signature)) revert(\\\"You are not in WL whitelist\\\");\\r\\n        if(mintedAmountNFTsperWalletWhitelistSale[msg.sender] + _quantity > maxMintAmountPerWhitelist) revert(\\\"You can only get 3 NFT on the Whitelist Sale\\\");\\r\\n            \\r\\n        mintedAmountNFTsperWalletWhitelistSale[msg.sender] += _quantity;\\r\\n        _mint(_account, _quantity);\\r\\n    }\"}","{\"contract\": \"0x0abd5db5b817100c386047fc3e393713fcd7c3ae\", \"contract_name\": \"MenaceWarriors\", \"sol_function\": \"function testSignerRecovery(bytes calldata signature) external view returns (address) {\\r\\n        return keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\r\\n                bytes32(uint256(uint160(msg.sender)))\\r\\n            )\\r\\n        ).recover(signature);\\r\\n    }\"}","{\"contract\": \"0xd3189e0e42896ab5743ff9f01de9e86be0bdc5c4\", \"contract_name\": \"SigningTools\", \"sol_function\": \"function _verifySignature(bytes32 messageHash, bytes memory signature ) internal pure returns (bool)\\n    \\t{\\n\\t\\tbytes32 r;\\n\\t\\tbytes32 s;\\n\\t\\tuint8 v;\\n\\n\\t\\tassembly\\n\\t\\t\\t{\\n\\t\\t\\tr := mload (add (signature, 0x20))\\n\\t\\t\\ts := mload (add (signature, 0x40))\\n\\t\\t\\tv := mload (add (signature, 0x41))\\n\\t\\t\\t}\\n\\n\\t\\taddress recoveredAddress = ECDSA.recover(messageHash, v, r, s);\\n\\n        return (recoveredAddress == EXPECTED_SIGNER);\\n    \\t}\"}","{\"contract\": \"0xe0901883d567f50bdc0f090ebe7d0bb6d1dfe61f\", \"contract_name\": \"Smilies\", \"sol_function\": \"function getAllowlistTier(address addr, bytes memory signature)\\n        internal\\n        view\\n        returns (Tier)\\n    {\\n        address tempAddr = ECDSA.recover(\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n40\\\", this, addr)\\n            ),\\n            signature\\n        );\\n        if (tempAddr == allowlistTierConfig[Tier.OG].verificationAddr) {\\n            return Tier.OG;\\n        } else if (\\n            tempAddr == allowlistTierConfig[Tier.GOLD].verificationAddr\\n        ) {\\n            return Tier.GOLD;\\n        } else if (\\n            tempAddr == allowlistTierConfig[Tier.SILVER].verificationAddr\\n        ) {\\n            return Tier.SILVER;\\n        } else {\\n            revert AddressNotAllowlistVerified();\\n        }\\n    }\"}","{\"contract\": \"0xa0cc2fd5cc234a475b0788a62436d5633985219b\", \"contract_name\": \"ZeroMoney\", \"sol_function\": \"function claim(\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        require(!claimed[msg.sender], \\\"ZERO: CLAIMED\\\");\\n\\n        bytes32 message = keccak256(abi.encodePacked(msg.sender));\\n        require(ECDSA.recover(ECDSA.toEthSignedMessageHash(message), v, r, s) == signer, \\\"ZERO: UNAUTHORIZED\\\");\\n\\n        claimed[msg.sender] = true;\\n\\n        _mint(msg.sender, 1 ether);\\n    }\"}","{\"contract\": \"0x743190eac57cc6f16e4c50290e1181ab91df5f1a\", \"contract_name\": \"ERC2771_Trusted_Forwarder\", \"sol_function\": \"function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) {\\n    address signer = _hashTypedDataV4(\\n      keccak256(abi.encode(_TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))\\n    ).recover(signature);\\n\\n    return !_nonces[req.from][req.nonce] && (signer == req.from || systemDelegateApprover.isDelegateApprovedForSystem(req.from, 0x4168694de04c1b4d3bb81d9503f3f00c21c34bafce952643bcc05f16e2b7acef, signer));\\n  }\"}","{\"contract\": \"0x34280882267ffa6383b363e278b027be083bbe3b\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x34280882267ffa6383b363e278b027be083bbe3b\", \"contract_name\": \"PendleMarket\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x34280882267ffa6383b363e278b027be083bbe3b\", \"contract_name\": \"PendleERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x3b4cbe8e52e40195d7f253d0b90904b9eb9e9107\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xca566376e5e3ec9a08336b3eadaac23c675e0091\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xca566376e5e3ec9a08336b3eadaac23c675e0091\", \"contract_name\": \"Rebase\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x16a3a9427863c6d3fb46196f1dc0894564556066\", \"contract_name\": \"MissionsManager\", \"sol_function\": \"function verifySigner(bytes memory _data, bytes memory _signature) public view returns (bool) {\\r\\n\\t\\tbytes32 _hash = _data.toEthSignedMessageHash();\\r\\n\\t\\tif (ECDSA.recover(_hash, _signature) != signer) return false;\\r\\n\\t\\treturn true;\\r\\n\\t}\"}","{\"contract\": \"0x8254e26e453eb5abd29b3c37ac9e8da32e5d3299\", \"contract_name\": \"RBX\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x8254e26e453eb5abd29b3c37ac9e8da32e5d3299\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x8254e26e453eb5abd29b3c37ac9e8da32e5d3299\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xe62d2ac074037505340c077fe8097d400f0df6a6\", \"contract_name\": \"SignatureMintERC721Upgradeable\", \"sol_function\": \"function _recoverAddress(MintRequest calldata _req, bytes calldata _signature) internal view returns (address) {\\n        return _hashTypedDataV4(keccak256(_encodeRequest(_req))).recover(_signature);\\n    }\"}","{\"contract\": \"0xe62d2ac074037505340c077fe8097d400f0df6a6\", \"contract_name\": \"LoyaltyCardM\", \"sol_function\": \"function _recoverAddress(MintRequest calldata _req, bytes calldata _signature) internal view returns (address) {\\n        return _hashTypedDataV4(keccak256(_encodeRequest(_req))).recover(_signature);\\n    }\"}","{\"contract\": \"0xa9fb245f83563e5fbdd0d4727eecc225a3130a37\", \"contract_name\": \"ArchetypeLogic\", \"sol_function\": \"function validateAffiliate(\\n    address affiliate,\\n    bytes calldata signature,\\n    address affiliateSigner\\n  ) public view {\\n    bytes32 signedMessagehash = ECDSA.toEthSignedMessageHash(\\n      keccak256(abi.encodePacked(affiliate))\\n    );\\n    address signer = ECDSA.recover(signedMessagehash, signature);\\n\\n    if (signer != affiliateSigner) {\\n      revert InvalidSignature();\\n    }\\n  }\"}","{\"contract\": \"0x075cadd4715cf353fd316507582d0cb9712adf09\", \"contract_name\": \"BNPLKYCStore\", \"sol_function\": \"function _verifyProof(\\n        uint32 domain,\\n        address user,\\n        uint32 status,\\n        uint256 nonce,\\n        bytes calldata signature\\n    ) internal {\\n        require(domain != 0 && domain <= domainCount, \\\"invalid domain\\\");\\n        require(publicKeys[domain] != address(0), \\\"this domain is disabled\\\");\\n        bytes32 proofHash = getKYCSignatureHash(domain, user, status, nonce);\\n        require(proofHash.toEthSignedMessageHash().recover(signature) == publicKeys[domain], \\\"invalid signature\\\");\\n        require(proofUsed[proofHash] == 0, \\\"proof already used\\\");\\n        proofUsed[proofHash] = 1;\\n    }\"}","{\"contract\": \"0xfe0be41f95a98cfa9d3fd4ccc57fb99b75545ced\", \"contract_name\": \"GenesisProtocol\", \"sol_function\": \"function stakeWithSignature(\\r\\n        bytes32 _proposalId,\\r\\n        uint256 _vote,\\r\\n        uint256 _amount,\\r\\n        uint256 _nonce,\\r\\n        uint256 _signatureType,\\r\\n        bytes calldata _signature\\r\\n        )\\r\\n        external\\r\\n        returns(bool)\\r\\n        {\\r\\n        // Recreate the digest the user signed\\r\\n        bytes32 delegationDigest;\\r\\n        if (_signatureType == 2) {\\r\\n            delegationDigest = keccak256(\\r\\n                abi.encodePacked(\\r\\n                    DELEGATION_HASH_EIP712, keccak256(\\r\\n                        abi.encodePacked(\\r\\n                        address(this),\\r\\n                        _proposalId,\\r\\n                        _vote,\\r\\n                        _amount,\\r\\n                        _nonce)\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n        } else {\\r\\n            delegationDigest = keccak256(\\r\\n                        abi.encodePacked(\\r\\n                        address(this),\\r\\n                        _proposalId,\\r\\n                        _vote,\\r\\n                        _amount,\\r\\n                        _nonce)\\r\\n                    ).toEthSignedMessageHash();\\r\\n        }\\r\\n        address staker = delegationDigest.recover(_signature);\\r\\n        //a garbage staker address due to wrong signature will revert due to lack of approval and funds.\\r\\n        require(staker != address(0), \\\"staker address cannot be 0\\\");\\r\\n        require(stakesNonce[staker] == _nonce);\\r\\n        stakesNonce[staker] = stakesNonce[staker].add(1);\\r\\n        return _stake(_proposalId, _vote, _amount, staker);\\r\\n    }\"}","{\"contract\": \"0x67e5c7e4aa2c05d9ffd6b4b40d284989b4cb2be9\", \"contract_name\": \"Wallet\", \"sol_function\": \"function isValidSignature(bytes32 _hashedData, bytes memory _signature) public view returns (bytes4) {\\n        address from = _hashedData.recover(_signature);\\n        require(_isOwner(from), \\\"invalid signature\\\");\\n        return _EIP_1654;\\n    }\"}","{\"contract\": \"0x6313d6d1330544358c5982b00a122f716098782e\", \"contract_name\": \"Signed\", \"sol_function\": \"function getSigner( bytes32 hash, bytes memory signature ) internal pure returns( address ){\\r\\n    return hash.toEthSignedMessageHash().recover( signature );\\r\\n  }\"}","{\"contract\": \"0x6313d6d1330544358c5982b00a122f716098782e\", \"contract_name\": \"FoundersCoin\", \"sol_function\": \"function getSigner( bytes32 hash, bytes memory signature ) internal pure returns( address ){\\r\\n    return hash.toEthSignedMessageHash().recover( signature );\\r\\n  }\"}","{\"contract\": \"0x9e733e5ce6406399ce072d427069a66f706b4374\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x9e733e5ce6406399ce072d427069a66f706b4374\", \"contract_name\": \"BToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xa9b584ec492cf6f641c9d37ea23bf5229139b419\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xa9b584ec492cf6f641c9d37ea23bf5229139b419\", \"contract_name\": \"GenesisERC20Token\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xfb9c99fa97974d99c5ff00e123d9c5f5e3f0d38e\", \"contract_name\": \"ERC20VotesUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xfb9c99fa97974d99c5ff00e123d9c5f5e3f0d38e\", \"contract_name\": \"ERC20PermitUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xfb9c99fa97974d99c5ff00e123d9c5f5e3f0d38e\", \"contract_name\": \"DropERC20\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x7655ee1bd794b0fe4b9b4d477b0f5ccabd78137c\", \"contract_name\": \"SigCheckable\", \"sol_function\": \"function signer(\\n        bytes32 message,\\n        bytes memory signature) internal view returns (bytes32 digest, address _signer) {\\n        digest = _hashTypedDataV4(message);\\n        _signer = ECDSA.recover(digest, signature);\\n    }\"}","{\"contract\": \"0x7655ee1bd794b0fe4b9b4d477b0f5ccabd78137c\", \"contract_name\": \"ForgeFundManager\", \"sol_function\": \"function signer(\\n        bytes32 message,\\n        bytes memory signature) internal view returns (bytes32 digest, address _signer) {\\n        digest = _hashTypedDataV4(message);\\n        _signer = ECDSA.recover(digest, signature);\\n    }\"}","{\"contract\": \"0x7655ee1bd794b0fe4b9b4d477b0f5ccabd78137c\", \"contract_name\": \"FundManager\", \"sol_function\": \"function signer(\\n        bytes32 message,\\n        bytes memory signature) internal view returns (bytes32 digest, address _signer) {\\n        digest = _hashTypedDataV4(message);\\n        _signer = ECDSA.recover(digest, signature);\\n    }\"}","{\"contract\": \"0x5ff0ef859dea265946b8834533908d3346ed0a6f\", \"contract_name\": \"DelegatePermit\", \"sol_function\": \"function _verifyDelegatePermit(\\n        address delegator,\\n        address delegatee,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(\\n            block.timestamp <= deadline,\\n            \\\"DelegatePermit: expired deadline\\\"\\n        );\\n        require(delegator != address(0), \\\"invalid delegator\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _DELEGATE_TYPEHASH,\\n                delegator,\\n                delegatee,\\n                _useDelegationNonce(delegator),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == delegator, \\\"DelegatePermit: invalid signature\\\");\\n    }\"}","{\"contract\": \"0x5ff0ef859dea265946b8834533908d3346ed0a6f\", \"contract_name\": \"ECO\", \"sol_function\": \"function _verifyDelegatePermit(\\n        address delegator,\\n        address delegatee,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(\\n            block.timestamp <= deadline,\\n            \\\"DelegatePermit: expired deadline\\\"\\n        );\\n        require(delegator != address(0), \\\"invalid delegator\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _DELEGATE_TYPEHASH,\\n                delegator,\\n                delegatee,\\n                _useDelegationNonce(delegator),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == delegator, \\\"DelegatePermit: invalid signature\\\");\\n    }\"}","{\"contract\": \"0x5ff0ef859dea265946b8834533908d3346ed0a6f\", \"contract_name\": \"ECO\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x5ff0ef859dea265946b8834533908d3346ed0a6f\", \"contract_name\": \"ECOx\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x5ff0ef859dea265946b8834533908d3346ed0a6f\", \"contract_name\": \"ERC20\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x5ff0ef859dea265946b8834533908d3346ed0a6f\", \"contract_name\": \"ERC20Pausable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x5ff0ef859dea265946b8834533908d3346ed0a6f\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x5ff0ef859dea265946b8834533908d3346ed0a6f\", \"contract_name\": \"InflationCheckpoints\", \"sol_function\": \"function _verifyDelegatePermit(\\n        address delegator,\\n        address delegatee,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(\\n            block.timestamp <= deadline,\\n            \\\"DelegatePermit: expired deadline\\\"\\n        );\\n        require(delegator != address(0), \\\"invalid delegator\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _DELEGATE_TYPEHASH,\\n                delegator,\\n                delegatee,\\n                _useDelegationNonce(delegator),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == delegator, \\\"DelegatePermit: invalid signature\\\");\\n    }\"}","{\"contract\": \"0x5ff0ef859dea265946b8834533908d3346ed0a6f\", \"contract_name\": \"InflationCheckpoints\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x5ff0ef859dea265946b8834533908d3346ed0a6f\", \"contract_name\": \"VoteCheckpoints\", \"sol_function\": \"function _verifyDelegatePermit(\\n        address delegator,\\n        address delegatee,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(\\n            block.timestamp <= deadline,\\n            \\\"DelegatePermit: expired deadline\\\"\\n        );\\n        require(delegator != address(0), \\\"invalid delegator\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _DELEGATE_TYPEHASH,\\n                delegator,\\n                delegatee,\\n                _useDelegationNonce(delegator),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == delegator, \\\"DelegatePermit: invalid signature\\\");\\n    }\"}","{\"contract\": \"0x5ff0ef859dea265946b8834533908d3346ed0a6f\", \"contract_name\": \"VoteCheckpoints\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x5ff0ef859dea265946b8834533908d3346ed0a6f\", \"contract_name\": \"ECOxStaking\", \"sol_function\": \"function _verifyDelegatePermit(\\n        address delegator,\\n        address delegatee,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(\\n            block.timestamp <= deadline,\\n            \\\"DelegatePermit: expired deadline\\\"\\n        );\\n        require(delegator != address(0), \\\"invalid delegator\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _DELEGATE_TYPEHASH,\\n                delegator,\\n                delegatee,\\n                _useDelegationNonce(delegator),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == delegator, \\\"DelegatePermit: invalid signature\\\");\\n    }\"}","{\"contract\": \"0x5ff0ef859dea265946b8834533908d3346ed0a6f\", \"contract_name\": \"ECOxStaking\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xca72a9ffc31b21ed0a5f295a2cfc5d24a177d68f\", \"contract_name\": \"TokenVestingLinear\", \"sol_function\": \"function _validateSignature(bytes32 user, address recepientWallet, bytes calldata signature) internal view returns (bool) {\\n      bytes32 dataHash = keccak256(abi.encode(user, recepientWallet));\\n      bytes32 message = ECDSA.toEthSignedMessageHash(dataHash);\\n\\n      address receivedAddress = ECDSA.recover(message, signature);\\n      return (receivedAddress != address(0) && receivedAddress == signerAddress);\\n    }\"}","{\"contract\": \"0xcce1da6b79f8802129e1dc9a04fdc262aec6b254\", \"contract_name\": \"CSBaseToken\", \"sol_function\": \"function signedTransfer(\\r\\n        address _to,\\r\\n        uint256 _tokenId,\\r\\n        bytes memory transferData,\\r\\n        bytes memory _signature\\r\\n    ) public {\\r\\n        address currentOwner = ownerOf(_tokenId);\\r\\n        bytes32 data = keccak256(\\r\\n            abi.encode(\\r\\n                address(this),\\r\\n                block.chainid,\\r\\n                _to,\\r\\n                _tokenId,\\r\\n                signedTransferNonce[currentOwner],\\r\\n                transferData\\r\\n            )\\r\\n        );\\r\\n        require(\\r\\n            ECDSA.recover(ECDSA.toEthSignedMessageHash(data), _signature) ==\\r\\n                currentOwner,\\r\\n            \\\"invalid signature\\\"\\r\\n        );\\r\\n        signedTransferNonce[currentOwner]++;\\r\\n        _safeTransfer(currentOwner, _to, _tokenId, transferData);\\r\\n    }\"}","{\"contract\": \"0x59dca7b3b82fa3ae0ba97cff205faf5640f92778\", \"contract_name\": \"NftExchangeV4\", \"sol_function\": \"function _verify(BuyerVoucherV3 calldata voucher) internal view returns (address) {\\r\\n        bytes32 digest = _hash(voucher);\\r\\n        return ECDSAUpgradeable.recover(digest, voucher.signature);\\r\\n    }\"}","{\"contract\": \"0x59dca7b3b82fa3ae0ba97cff205faf5640f92778\", \"contract_name\": \"NftExchangeV4\", \"sol_function\": \"function _verify(SellerVoucherV3 calldata voucher) internal view returns (address) {\\r\\n        bytes32 digest = _hash(voucher);\\r\\n        return ECDSAUpgradeable.recover(digest, voucher.signature);\\r\\n    }\"}","{\"contract\": \"0x59dca7b3b82fa3ae0ba97cff205faf5640f92778\", \"contract_name\": \"NftExchangeV4\", \"sol_function\": \"function _verify(ExchangeVoucherV3 calldata voucher) internal view returns (address) {\\r\\n        bytes32 digest = _hash(voucher);\\r\\n        return ECDSAUpgradeable.recover(digest, voucher.signature);\\r\\n    }\"}","{\"contract\": \"0x8408baccc231a6bba766ed15571403468b32bfa5\", \"contract_name\": \"NowPass\", \"sol_function\": \"function _verify(uint256 qty, uint256 nonce, address addr, bytes memory signature) internal view returns (address) \\r\\n        {\\r\\n            bytes32 digest = _hash(qty, nonce, addr);\\r\\n            return ECDSA.recover(digest, signature);\\r\\n        }\"}","{\"contract\": \"0xfc23f958c86d944418d7965a5f6582d1e96db1be\", \"contract_name\": \"WhimsySisters\", \"sol_function\": \"function recoverSignerAddress(address minter, bytes calldata signature) internal pure returns (address) {\\n        bytes32 hash = hashTransaction(minter);\\n        return hash.recover(signature);\\n    }\"}","{\"contract\": \"0x863ad391091ae0e87b850c2bb7bfc7597c79c93f\", \"contract_name\": \"CanvasToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x863ad391091ae0e87b850c2bb7bfc7597c79c93f\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xf3c82a13ed736324a6837775360622b7fcc970a5\", \"contract_name\": \"SBII721\", \"sol_function\": \"function _verifySig(bytes32 data, bytes memory signature)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return\\r\\n            hasRole(MINTER_ROLE, ECDSA.recover(_toSignedHash(data), signature));\\r\\n    }\"}","{\"contract\": \"0xfbb2eaa7efedf5e35d7847c3f19850f97366126b\", \"contract_name\": \"FixedPriceAuction\", \"sol_function\": \"function buy(\\n        Lot memory lot_,\\n        bytes memory signature_,\\n        address buyer_\\n    ) external payable whenNotPaused nonReentrant {\\n        // CHECKS\\n        require(msg.value == lot_.price, \\\"FPA: incorrect amount sent\\\");\\n\\n        require(lot_.notBefore <= block.timestamp, \\\"FPA: auction not yet started\\\");\\n        require(lot_.deadline == 0 || lot_.deadline >= block.timestamp, \\\"FPA: auction already ended\\\");\\n\\n        bytes32 digest = _getLotDigest(lot_);\\n        require(_lotDigestNonce[digest] == false, \\\"FPA: lot already sold\\\");\\n        require(ECDSA.recover(digest, signature_) == lot_.seller, \\\"FPA: invalid signature\\\");\\n\\n        // PRE-EFFECTS\\n        // Get amounts\\n        uint256 auctionFee = (lot_.price * _auctionFeeBps) / 10000;\\n\\n        // Get royalty amount\\n        (address royaltyReceiver, uint256 royaltyAmount) = _getRoyaltyInfo(\\n            lot_.tokenAddress,\\n            lot_.tokenId,\\n            lot_.price - auctionFee\\n        );\\n\\n        if (royaltyReceiver == address(0) || royaltyReceiver == lot_.seller) {\\n            // No royalty, or royalty goes to seller\\n            royaltyAmount = 0;\\n        }\\n\\n        uint256 sellerShare = lot_.price - (auctionFee + royaltyAmount);\\n        assert(sellerShare + auctionFee + royaltyAmount <= lot_.price);\\n\\n        // EFFECTS\\n        _lotDigestNonce[digest] = true;\\n\\n        // INTERACTIONS\\n        // Transfer the token and ensure delivery of the token\\n        IERC721(lot_.tokenAddress).safeTransferFrom(lot_.seller, buyer_, lot_.tokenId);\\n        require(IERC721(lot_.tokenAddress).ownerOf(lot_.tokenId) == buyer_, \\\"FixedPriceAuction: token transfer failed\\\"); // ensure delivery\\n\\n        // Ensure delivery of the payment\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool paymentSent, ) = lot_.seller.call{value: sellerShare}(\\\"\\\");\\n        require(paymentSent, \\\"FixedPriceAuction: payment failed\\\");\\n    }\"}","{\"contract\": \"0x52b5d77df8a48a24a952299e927da29723e1a89f\", \"contract_name\": \"MetaVisa\", \"sol_function\": \"function getAddress(bytes memory m,uint8 v,bytes32 r,bytes32 s) internal pure returns (address){\\r\\n        bytes32 hash = ECDSA.toEthSignedMessageHash(m);\\r\\n        address signAddress = ECDSA.recover(hash,v,r,s);\\r\\n        return signAddress;\\r\\n    }\"}","{\"contract\": \"0x5b7036ba5bf4fd63823563aca9d468963e7463d4\", \"contract_name\": \"CloudyMe\", \"sol_function\": \"function wlMint(address to,uint256 amount,bytes memory _singature)external payable{\\r\\n        require(ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(abi.encodePacked(to, amount))),_singature) == signAddress,\\\"You're not on the whitelist\\\");\\r\\n        require(totalSupply() + amount <= Max_SUPPLY,\\\"Minted out\\\");\\r\\n        require(mintedAmount[to] + amount <= MINT_LIMIT,\\\"Limit exceeded\\\");\\r\\n        if(mintedAmount[to] >= FREE_MINT){\\r\\n            require(msg.value >= amount * MINT_PRICE,\\\"Not paying enough fees\\\");\\r\\n        }else if(mintedAmount[to] + amount > FREE_MINT){\\r\\n            require(msg.value >= (mintedAmount[to] + amount - FREE_MINT) * MINT_PRICE,\\\"Not paying enough fees\\\");\\r\\n        }\\r\\n        mintedAmount[to]+=amount;\\r\\n        _mint(to,amount);\\r\\n    }\"}","{\"contract\": \"0x2305a9149c625756fb77456612a5d3f812ce81cd\", \"contract_name\": \"Vesting\", \"sol_function\": \"function _verify(\\n        address singerAddress,\\n        bytes32 hash,\\n        bytes calldata signature\\n    ) private pure returns (bool) {\\n        return singerAddress == ECDSA.recover(hash, signature);\\n    }\"}","{\"contract\": \"0x2305a9149c625756fb77456612a5d3f812ce81cd\", \"contract_name\": \"SignatureVerify\", \"sol_function\": \"function _verify(\\n        address singerAddress,\\n        bytes32 hash,\\n        bytes calldata signature\\n    ) private pure returns (bool) {\\n        return singerAddress == ECDSA.recover(hash, signature);\\n    }\"}","{\"contract\": \"0x5ce9c2e3e803712e6fec5368968b61a55d851cdf\", \"contract_name\": \"SickleGovernor\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x5ce9c2e3e803712e6fec5368968b61a55d851cdf\", \"contract_name\": \"SickleGovernor\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x5ce9c2e3e803712e6fec5368968b61a55d851cdf\", \"contract_name\": \"Governor\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x5ce9c2e3e803712e6fec5368968b61a55d851cdf\", \"contract_name\": \"Governor\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x5ce9c2e3e803712e6fec5368968b61a55d851cdf\", \"contract_name\": \"GovernorCountingSimple\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x5ce9c2e3e803712e6fec5368968b61a55d851cdf\", \"contract_name\": \"GovernorCountingSimple\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x5ce9c2e3e803712e6fec5368968b61a55d851cdf\", \"contract_name\": \"GovernorSettings\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x5ce9c2e3e803712e6fec5368968b61a55d851cdf\", \"contract_name\": \"GovernorSettings\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x5ce9c2e3e803712e6fec5368968b61a55d851cdf\", \"contract_name\": \"GovernorVotes\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x5ce9c2e3e803712e6fec5368968b61a55d851cdf\", \"contract_name\": \"GovernorVotes\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x5ce9c2e3e803712e6fec5368968b61a55d851cdf\", \"contract_name\": \"GovernorVotesQuorumFraction\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x5ce9c2e3e803712e6fec5368968b61a55d851cdf\", \"contract_name\": \"GovernorVotesQuorumFraction\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x8f512205ad7a5d1d6698f35993ea7a5bba93d3f7\", \"contract_name\": \"IDOServiceImmutable\", \"sol_function\": \"function _signatureVerification(\\n        bytes32 _messageHashed,\\n        bytes memory _signature\\n    ) internal view returns (address) {\\n        address signer = _messageHashed.toEthSignedMessageHash().recover(\\n            _signature\\n        );\\n        require(\\n            signer == IRegistry(registry).getVerifier(),\\n            \\\"Invalid signature\\\"\\n        );\\n        return signer;\\n    }\"}","{\"contract\": \"0x2b0bfa93beb22f44e7c1be88efd80396f8d9f1d4\", \"contract_name\": \"StateOfTheArt\", \"sol_function\": \"function merge(uint256[] calldata tokens, string calldata uri, bytes calldata sig) external nonReentrant {\\n        require(mergeOpen, \\\"Merge not open\\\");\\n        bytes32 msgHash = _generateHash(tokens, uri, msg.sender);\\n        require(ECDSA.recover(msgHash, sig) == mergeSigner, \\\"Invalid signature\\\");\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            require(ownerOf(tokens[i]) == msg.sender, \\\"Sender does not own all tokens\\\");\\n            _burn(tokens[i]);\\n        }\\n        _counter++;\\n        _tokenUriOverrides[_counter] = uri;\\n        _safeMint(msg.sender, _counter);\\n\\n        emit Merge(msg.sender, _counter, uri, tokens);\\n    }\"}","{\"contract\": \"0x5e1c754f28b7e8458ec4e440f9187856bfeb048c\", \"contract_name\": \"ERC20VotesUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x5e1c754f28b7e8458ec4e440f9187856bfeb048c\", \"contract_name\": \"ERC20PermitUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x5e1c754f28b7e8458ec4e440f9187856bfeb048c\", \"contract_name\": \"DropERC20\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x618484f6b11649b97d8d291cd91461c0cb1b0f8c\", \"contract_name\": \"SwampFrogs\", \"sol_function\": \"function presaleMint(uint16 _tokenCount, uint16 _purchaseLimit, bytes memory _signature) external nonReentrant payable {\\r\\n    require(_isActive, \\\"Sale must be active\\\");\\r\\n    require(_presaleActive, \\\"Presale must be active\\\");\\r\\n    require(_tokenCount > 0, \\\"Token count must be at least 0\\\");\\r\\n    require(_tokenCount <= MAX_PRESALE_AMOUNT, \\\"Token count exceeds purchase limit\\\");\\r\\n    require((MINT_COST * _tokenCount) == msg.value, \\\"Incorrect ETH value sent\\\");\\r\\n    require(!_claimedPresale[msg.sender], \\\"User has already claimed from presale\\\");\\r\\n\\r\\n    bytes32 message = keccak256(abi.encodePacked(msg.sender, _tokenCount, _purchaseLimit, PRESALE_ID));\\r\\n    require(message.toEthSignedMessageHash().recover(_signature) == PRESALE_SIGNER, \\\"whitelist is not signed\\\");\\r\\n\\r\\n    _claimedPresale[msg.sender] = true;\\r\\n\\r\\n    _mintFrogs(_tokenCount, msg.sender);\\r\\n  }\"}","{\"contract\": \"0x78ba637923b4e9e5526c3d83969731d327664bad\", \"contract_name\": \"PaymentPlanV2Logic\", \"sol_function\": \"function verifySignature(\\n        Item calldata item,\\n        Plan calldata plan,\\n        uint256 planId,\\n        uint256 signedBlockNum,\\n        address signer,\\n        bytes memory signature\\n    ) external pure {\\n        bytes32 itemHash = keccak256(\\n            abi.encodePacked(item.cyanVaultAddress, item.contractAddress, item.tokenId, item.amount, item.itemType)\\n        );\\n        bytes32 planHash = keccak256(\\n            abi.encodePacked(\\n                plan.amount,\\n                plan.downPaymentPercent,\\n                plan.interestRate,\\n                plan.serviceFeeRate,\\n                plan.term,\\n                plan.totalNumberOfPayments,\\n                plan.counterPaidPayments,\\n                plan.autoRepayStatus\\n            )\\n        );\\n        bytes32 msgHash = keccak256(abi.encodePacked(itemHash, planHash, planId, signedBlockNum));\\n        bytes32 signedHash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", msgHash));\\n        if (signedHash.recover(signature) != signer) revert InvalidSignature();\\n    }\"}","{\"contract\": \"0x78ba637923b4e9e5526c3d83969731d327664bad\", \"contract_name\": \"PaymentPlanV2Logic\", \"sol_function\": \"function verifyRevivalSignature(\\n        uint256 planId,\\n        uint256 penaltyAmount,\\n        uint256 signatureExpiryDate,\\n        uint8 counterPaidPayments,\\n        address signer,\\n        bytes memory signature\\n    ) external pure {\\n        bytes32 msgHash = keccak256(abi.encodePacked(planId, penaltyAmount, signatureExpiryDate, counterPaidPayments));\\n        bytes32 signedHash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", msgHash));\\n        if (signedHash.recover(signature) != signer) revert InvalidSignature();\\n    }\"}","{\"contract\": \"0xe45d47ca65982dd43a8d29fe35cd67de4629493c\", \"contract_name\": \"Sushib\", \"sol_function\": \"function claim(address account, uint256 amount, uint8 v, bytes32 r, bytes32 s, address to) external {\\n        require(!claimed[account], \\\"SUSHIB: ALREADY_CLAIMED\\\");\\n        bytes32 hash = keccak256(abi.encode(account, amount));\\n        require(ECDSA.recover(ECDSA.toEthSignedMessageHash(hash), v, r, s) == signer, \\\"SUSHIB: INVALID_SIGNATURE\\\");\\n        claimed[account] = true;\\n        _mint(to, amount);\\n\\n        emit Claim(account, amount, to);\\n    }\"}","{\"contract\": \"0x762e7b393a92f75491e7e4c6cad7219c2b3b9de1\", \"contract_name\": \"BToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x762e7b393a92f75491e7e4c6cad7219c2b3b9de1\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xc65dc5d5ac5856d7b498543d168f2f54c218e44e\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xc65dc5d5ac5856d7b498543d168f2f54c218e44e\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xc65dc5d5ac5856d7b498543d168f2f54c218e44e\", \"contract_name\": \"BotFi\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xb20e024da94fef84b5dbde3a639048952de58169\", \"contract_name\": \"Humankind\", \"sol_function\": \"function _verify(\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        bytes32 signedHash = hash.toEthSignedMessageHash();\\n\\n        return signedHash.recover(signature) == signer;\\n    }\"}","{\"contract\": \"0xa4537a9ae61444ef4d71df79ea35edcfb704f377\", \"contract_name\": \"Common\", \"sol_function\": \"function _isUpdaterSignature(\\n        bytes32 _oldRoot,\\n        bytes32 _newRoot,\\n        bytes memory _signature\\n    ) internal view returns (bool) {\\n        bytes32 _digest = keccak256(\\n            abi.encodePacked(homeDomainHash(), _oldRoot, _newRoot)\\n        );\\n        _digest = ECDSA.toEthSignedMessageHash(_digest);\\n        return (ECDSA.recover(_digest, _signature) == updater);\\n    }\"}","{\"contract\": \"0xa4537a9ae61444ef4d71df79ea35edcfb704f377\", \"contract_name\": \"Home\", \"sol_function\": \"function _isUpdaterSignature(\\n        bytes32 _oldRoot,\\n        bytes32 _newRoot,\\n        bytes memory _signature\\n    ) internal view returns (bool) {\\n        bytes32 _digest = keccak256(\\n            abi.encodePacked(homeDomainHash(), _oldRoot, _newRoot)\\n        );\\n        _digest = ECDSA.toEthSignedMessageHash(_digest);\\n        return (ECDSA.recover(_digest, _signature) == updater);\\n    }\"}","{\"contract\": \"0xa4537a9ae61444ef4d71df79ea35edcfb704f377\", \"contract_name\": \"Replica\", \"sol_function\": \"function _isUpdaterSignature(\\n        bytes32 _oldRoot,\\n        bytes32 _newRoot,\\n        bytes memory _signature\\n    ) internal view returns (bool) {\\n        bytes32 _digest = keccak256(\\n            abi.encodePacked(homeDomainHash(), _oldRoot, _newRoot)\\n        );\\n        _digest = ECDSA.toEthSignedMessageHash(_digest);\\n        return (ECDSA.recover(_digest, _signature) == updater);\\n    }\"}","{\"contract\": \"0xa4537a9ae61444ef4d71df79ea35edcfb704f377\", \"contract_name\": \"XAppConnectionManager\", \"sol_function\": \"function _recoverWatcherFromSig(\\n        uint32 _domain,\\n        bytes32 _replica,\\n        bytes32 _updater,\\n        bytes memory _signature\\n    ) internal view returns (address) {\\n        bytes32 _homeDomainHash = Replica(TypeCasts.bytes32ToAddress(_replica))\\n            .homeDomainHash();\\n        bytes32 _digest = keccak256(\\n            abi.encodePacked(_homeDomainHash, _domain, _updater)\\n        );\\n        _digest = ECDSA.toEthSignedMessageHash(_digest);\\n        return ECDSA.recover(_digest, _signature);\\n    }\"}","{\"contract\": \"0x30e0b588eef717278bfa8d812fb4f94ae72b50ed\", \"contract_name\": \"Breeding\", \"sol_function\": \"function getSigner(bytes32 hash, bytes memory signature)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        return hash.toEthSignedMessageHash().recover(signature);\\n    }\"}","{\"contract\": \"0x30e0b588eef717278bfa8d812fb4f94ae72b50ed\", \"contract_name\": \"SignedUpgradable\", \"sol_function\": \"function getSigner(bytes32 hash, bytes memory signature)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        return hash.toEthSignedMessageHash().recover(signature);\\n    }\"}","{\"contract\": \"0x466024a7af6463c0a0104a58133a674b685a0c74\", \"contract_name\": \"SignatureCheckerUpgradeable\", \"sol_function\": \"function isValidSignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        if (AddressUpgradeable.isContract(signer)) {\\n            try IERC1271Upgradeable(signer).isValidSignature(hash, signature) returns (bytes4 magicValue) {\\n                return magicValue == IERC1271Upgradeable(signer).isValidSignature.selector;\\n            } catch {\\n                return false;\\n            }\\n        } else {\\n            return ECDSAUpgradeable.recover(hash, signature) == signer;\\n        }\\n    }\"}","{\"contract\": \"0x56d5b9aa337c0a57598e9d4004584805cf8271b8\", \"contract_name\": \"Chibimon\", \"sol_function\": \"function _verifySig(address sender, uint256 valueSent, uint256 maxMintable, bytes memory signature) internal view returns(bool) {\\r\\n        bytes32 messageHash = keccak256(abi.encodePacked(sender, valueSent, maxMintable));\\r\\n        return _signerAddress == messageHash.toEthSignedMessageHash().recover(signature);\\r\\n    }\"}","{\"contract\": \"0xece4504bbc107b650579f8d961837e8672dc9527\", \"contract_name\": \"VoteExecutorMaster\", \"sol_function\": \"function _verify(bytes32 data, bytes memory signature, address account) internal pure returns (bool) {\\r\\n        return data\\r\\n            .toEthSignedMessageHash()\\r\\n            .recover(signature) == account;\\r\\n    }\"}","{\"contract\": \"0xece4504bbc107b650579f8d961837e8672dc9527\", \"contract_name\": \"VoteExecutorMaster\", \"sol_function\": \"function _getSignerAddress(bytes32 data, bytes memory signature) internal pure returns (address) {\\r\\n        return data\\r\\n            .toEthSignedMessageHash()\\r\\n            .recover(signature);\\r\\n    }\"}","{\"contract\": \"0xf0c90f41aefe1b17c9d1bbf227c6ff95fb5e53d4\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xf0c90f41aefe1b17c9d1bbf227c6ff95fb5e53d4\", \"contract_name\": \"PatriotCoin\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x3312507bc3f22430b34d5841a472c767dc5c36e4\", \"contract_name\": \"Governor\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x3312507bc3f22430b34d5841a472c767dc5c36e4\", \"contract_name\": \"Governor\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x3312507bc3f22430b34d5841a472c767dc5c36e4\", \"contract_name\": \"GovernorCountingSimple\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x3312507bc3f22430b34d5841a472c767dc5c36e4\", \"contract_name\": \"GovernorCountingSimple\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x3312507bc3f22430b34d5841a472c767dc5c36e4\", \"contract_name\": \"GovernorSettings\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x3312507bc3f22430b34d5841a472c767dc5c36e4\", \"contract_name\": \"GovernorSettings\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x3312507bc3f22430b34d5841a472c767dc5c36e4\", \"contract_name\": \"GovernorTimelockControl\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x3312507bc3f22430b34d5841a472c767dc5c36e4\", \"contract_name\": \"GovernorTimelockControl\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x3312507bc3f22430b34d5841a472c767dc5c36e4\", \"contract_name\": \"GovernorVotes\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x3312507bc3f22430b34d5841a472c767dc5c36e4\", \"contract_name\": \"GovernorVotes\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x3312507bc3f22430b34d5841a472c767dc5c36e4\", \"contract_name\": \"GovernorVotesQuorumFraction\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x3312507bc3f22430b34d5841a472c767dc5c36e4\", \"contract_name\": \"GovernorVotesQuorumFraction\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x3312507bc3f22430b34d5841a472c767dc5c36e4\", \"contract_name\": \"Governance\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x3312507bc3f22430b34d5841a472c767dc5c36e4\", \"contract_name\": \"Governance\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x6b64e6dff3e00e5756dc2c17c0a75c2621c0dfee\", \"contract_name\": \"KarmaOneQuestions\", \"sol_function\": \"function verifySignerAddress(\\n        bytes32 _messageHash,\\n        bytes calldata _signature\\n    ) private view returns (bool) {\\n        return\\n            presaleSignerAddress ==\\n            _messageHash.toEthSignedMessageHash().recover(_signature);\\n    }\"}","{\"contract\": \"0x51c1a890a3c23f898525f591c26139be0a021334\", \"contract_name\": \"LinkdropCommon\", \"sol_function\": \"function verifyReceiverSignature\\r\\n    (\\r\\n        address _linkId,\\r\\n        address _receiver,\\r\\n        bytes memory _signature\\r\\n    )\\r\\n    public view\\r\\n    override       \\r\\n    returns (bool)\\r\\n    {\\r\\n        bytes32 prefixedHash = ECDSA.toEthSignedMessageHash(keccak256(abi.encodePacked(_receiver)));\\r\\n        address signer = ECDSA.recover(prefixedHash, _signature);\\r\\n        return signer == _linkId;\\r\\n    }\"}","{\"contract\": \"0x51c1a890a3c23f898525f591c26139be0a021334\", \"contract_name\": \"LinkdropERC20\", \"sol_function\": \"function verifyReceiverSignature\\r\\n    (\\r\\n        address _linkId,\\r\\n        address _receiver,\\r\\n        bytes memory _signature\\r\\n    )\\r\\n    public view\\r\\n    override       \\r\\n    returns (bool)\\r\\n    {\\r\\n        bytes32 prefixedHash = ECDSA.toEthSignedMessageHash(keccak256(abi.encodePacked(_receiver)));\\r\\n        address signer = ECDSA.recover(prefixedHash, _signature);\\r\\n        return signer == _linkId;\\r\\n    }\"}","{\"contract\": \"0x51c1a890a3c23f898525f591c26139be0a021334\", \"contract_name\": \"LinkdropERC20\", \"sol_function\": \"function verifyLinkdropSignerSignature\\r\\n    (\\r\\n        uint _weiAmount,\\r\\n        address _tokenAddress,\\r\\n        uint _tokenAmount,\\r\\n        uint _expiration,\\r\\n        address _linkId,\\r\\n        bytes memory _signature\\r\\n    )\\r\\n    public view\\r\\n      override \\r\\n    returns (bool)\\r\\n    {\\r\\n        bytes32 prefixedHash = ECDSA.toEthSignedMessageHash\\r\\n        (\\r\\n            keccak256\\r\\n            (\\r\\n                abi.encodePacked\\r\\n                (\\r\\n                    _weiAmount,\\r\\n                    _tokenAddress,\\r\\n                    _tokenAmount,\\r\\n                    _expiration,\\r\\n                    version,\\r\\n                    chainId,\\r\\n                    _linkId,\\r\\n                    address(this)\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n        address signer = ECDSA.recover(prefixedHash, _signature);\\r\\n        return isLinkdropSigner[signer];\\r\\n    }\"}","{\"contract\": \"0x51c1a890a3c23f898525f591c26139be0a021334\", \"contract_name\": \"LinkdropERC721\", \"sol_function\": \"function verifyReceiverSignature\\r\\n    (\\r\\n        address _linkId,\\r\\n        address _receiver,\\r\\n        bytes memory _signature\\r\\n    )\\r\\n    public view\\r\\n    override       \\r\\n    returns (bool)\\r\\n    {\\r\\n        bytes32 prefixedHash = ECDSA.toEthSignedMessageHash(keccak256(abi.encodePacked(_receiver)));\\r\\n        address signer = ECDSA.recover(prefixedHash, _signature);\\r\\n        return signer == _linkId;\\r\\n    }\"}","{\"contract\": \"0x51c1a890a3c23f898525f591c26139be0a021334\", \"contract_name\": \"LinkdropERC721\", \"sol_function\": \"function verifyLinkdropSignerSignatureERC721\\r\\n    (\\r\\n        uint _weiAmount,\\r\\n        address _nftAddress,\\r\\n        uint _tokenId,\\r\\n        uint _expiration,\\r\\n        address _linkId,\\r\\n        bytes memory _signature\\r\\n    )\\r\\n    public view\\r\\n    override       \\r\\n    returns (bool)\\r\\n    {\\r\\n        bytes32 prefixedHash = ECDSA.toEthSignedMessageHash\\r\\n        (\\r\\n            keccak256\\r\\n            (\\r\\n                abi.encodePacked\\r\\n                (\\r\\n                    _weiAmount,\\r\\n                    _nftAddress,\\r\\n                    _tokenId,\\r\\n                    _expiration,\\r\\n                    version,\\r\\n                    chainId,\\r\\n                    _linkId,\\r\\n                    address(this)\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n        address signer = ECDSA.recover(prefixedHash, _signature);\\r\\n        return isLinkdropSigner[signer];\\r\\n    }\"}","{\"contract\": \"0x51c1a890a3c23f898525f591c26139be0a021334\", \"contract_name\": \"LinkdropERC721\", \"sol_function\": \"function verifyReceiverSignatureERC721\\r\\n    (\\r\\n        address _linkId,\\r\\n        address _receiver,\\r\\n        bytes memory _signature\\r\\n    )\\r\\n    public view\\r\\n    override       \\r\\n    returns (bool)\\r\\n    {\\r\\n        bytes32 prefixedHash = ECDSA.toEthSignedMessageHash(keccak256(abi.encodePacked(_receiver)));\\r\\n        address signer = ECDSA.recover(prefixedHash, _signature);\\r\\n        return signer == _linkId;\\r\\n    }\"}","{\"contract\": \"0x51c1a890a3c23f898525f591c26139be0a021334\", \"contract_name\": \"LinkdropERC1155\", \"sol_function\": \"function verifyReceiverSignature\\r\\n    (\\r\\n        address _linkId,\\r\\n        address _receiver,\\r\\n        bytes memory _signature\\r\\n    )\\r\\n    public view\\r\\n    override       \\r\\n    returns (bool)\\r\\n    {\\r\\n        bytes32 prefixedHash = ECDSA.toEthSignedMessageHash(keccak256(abi.encodePacked(_receiver)));\\r\\n        address signer = ECDSA.recover(prefixedHash, _signature);\\r\\n        return signer == _linkId;\\r\\n    }\"}","{\"contract\": \"0x51c1a890a3c23f898525f591c26139be0a021334\", \"contract_name\": \"LinkdropERC1155\", \"sol_function\": \"function verifyLinkdropSignerSignatureERC1155\\r\\n    (\\r\\n        uint _weiAmount,\\r\\n        address _nftAddress,\\r\\n        uint _tokenId,\\r\\n        uint _tokenAmount,\\r\\n        uint _expiration,\\r\\n        address _linkId,\\r\\n        bytes memory _signature\\r\\n    )\\r\\n    public view\\r\\n    override       \\r\\n    returns (bool)\\r\\n    {\\r\\n        bytes32 prefixedHash = ECDSA.toEthSignedMessageHash\\r\\n        (\\r\\n            keccak256\\r\\n            (\\r\\n                abi.encodePacked\\r\\n                (\\r\\n                    _weiAmount,\\r\\n                    _nftAddress,\\r\\n                    _tokenId,\\r\\n                    _tokenAmount,\\r\\n                    _expiration,\\r\\n                    version,\\r\\n                    chainId,\\r\\n                    _linkId,\\r\\n                    address(this)\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n        address signer = ECDSA.recover(prefixedHash, _signature);\\r\\n        return isLinkdropSigner[signer];\\r\\n    }\"}","{\"contract\": \"0x51c1a890a3c23f898525f591c26139be0a021334\", \"contract_name\": \"LinkdropMastercopy\", \"sol_function\": \"function verifyLinkdropSignerSignatureERC1155\\r\\n    (\\r\\n        uint _weiAmount,\\r\\n        address _nftAddress,\\r\\n        uint _tokenId,\\r\\n        uint _tokenAmount,\\r\\n        uint _expiration,\\r\\n        address _linkId,\\r\\n        bytes memory _signature\\r\\n    )\\r\\n    public view\\r\\n    override       \\r\\n    returns (bool)\\r\\n    {\\r\\n        bytes32 prefixedHash = ECDSA.toEthSignedMessageHash\\r\\n        (\\r\\n            keccak256\\r\\n            (\\r\\n                abi.encodePacked\\r\\n                (\\r\\n                    _weiAmount,\\r\\n                    _nftAddress,\\r\\n                    _tokenId,\\r\\n                    _tokenAmount,\\r\\n                    _expiration,\\r\\n                    version,\\r\\n                    chainId,\\r\\n                    _linkId,\\r\\n                    address(this)\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n        address signer = ECDSA.recover(prefixedHash, _signature);\\r\\n        return isLinkdropSigner[signer];\\r\\n    }\"}","{\"contract\": \"0x51c1a890a3c23f898525f591c26139be0a021334\", \"contract_name\": \"LinkdropMastercopy\", \"sol_function\": \"function verifyReceiverSignature\\r\\n    (\\r\\n        address _linkId,\\r\\n        address _receiver,\\r\\n        bytes memory _signature\\r\\n    )\\r\\n    public view\\r\\n    override       \\r\\n    returns (bool)\\r\\n    {\\r\\n        bytes32 prefixedHash = ECDSA.toEthSignedMessageHash(keccak256(abi.encodePacked(_receiver)));\\r\\n        address signer = ECDSA.recover(prefixedHash, _signature);\\r\\n        return signer == _linkId;\\r\\n    }\"}","{\"contract\": \"0x51c1a890a3c23f898525f591c26139be0a021334\", \"contract_name\": \"LinkdropMastercopy\", \"sol_function\": \"function verifyLinkdropSignerSignatureERC721\\r\\n    (\\r\\n        uint _weiAmount,\\r\\n        address _nftAddress,\\r\\n        uint _tokenId,\\r\\n        uint _expiration,\\r\\n        address _linkId,\\r\\n        bytes memory _signature\\r\\n    )\\r\\n    public view\\r\\n    override       \\r\\n    returns (bool)\\r\\n    {\\r\\n        bytes32 prefixedHash = ECDSA.toEthSignedMessageHash\\r\\n        (\\r\\n            keccak256\\r\\n            (\\r\\n                abi.encodePacked\\r\\n                (\\r\\n                    _weiAmount,\\r\\n                    _nftAddress,\\r\\n                    _tokenId,\\r\\n                    _expiration,\\r\\n                    version,\\r\\n                    chainId,\\r\\n                    _linkId,\\r\\n                    address(this)\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n        address signer = ECDSA.recover(prefixedHash, _signature);\\r\\n        return isLinkdropSigner[signer];\\r\\n    }\"}","{\"contract\": \"0x51c1a890a3c23f898525f591c26139be0a021334\", \"contract_name\": \"LinkdropMastercopy\", \"sol_function\": \"function verifyReceiverSignatureERC721\\r\\n    (\\r\\n        address _linkId,\\r\\n        address _receiver,\\r\\n        bytes memory _signature\\r\\n    )\\r\\n    public view\\r\\n    override       \\r\\n    returns (bool)\\r\\n    {\\r\\n        bytes32 prefixedHash = ECDSA.toEthSignedMessageHash(keccak256(abi.encodePacked(_receiver)));\\r\\n        address signer = ECDSA.recover(prefixedHash, _signature);\\r\\n        return signer == _linkId;\\r\\n    }\"}","{\"contract\": \"0x51c1a890a3c23f898525f591c26139be0a021334\", \"contract_name\": \"LinkdropMastercopy\", \"sol_function\": \"function verifyLinkdropSignerSignature\\r\\n    (\\r\\n        uint _weiAmount,\\r\\n        address _tokenAddress,\\r\\n        uint _tokenAmount,\\r\\n        uint _expiration,\\r\\n        address _linkId,\\r\\n        bytes memory _signature\\r\\n    )\\r\\n    public view\\r\\n      override \\r\\n    returns (bool)\\r\\n    {\\r\\n        bytes32 prefixedHash = ECDSA.toEthSignedMessageHash\\r\\n        (\\r\\n            keccak256\\r\\n            (\\r\\n                abi.encodePacked\\r\\n                (\\r\\n                    _weiAmount,\\r\\n                    _tokenAddress,\\r\\n                    _tokenAmount,\\r\\n                    _expiration,\\r\\n                    version,\\r\\n                    chainId,\\r\\n                    _linkId,\\r\\n                    address(this)\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n        address signer = ECDSA.recover(prefixedHash, _signature);\\r\\n        return isLinkdropSigner[signer];\\r\\n    }\"}","{\"contract\": \"0x648de0cc2964d77d2441f7f8f4bb69083869d3fb\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xe570ed5e3efff7bd706a8057b4dc37a3f0db6798\", \"contract_name\": \"SignatureMerkleDrop128\", \"sol_function\": \"function claim(address receiver, uint256 amount, bytes calldata merkleProof, bytes calldata signature) external override {\\n        bytes32 signedHash = ECDSA.toEthSignedMessageHash(keccak256(abi.encodePacked(receiver)));\\n        address account = ECDSA.recover(signedHash, signature);\\n        // Verify the merkle proof.\\n        bytes16 node = bytes16(keccak256(abi.encodePacked(account, amount)));\\n        (bool valid, uint256 index) = _verifyAsm(merkleProof, merkleRoot, node);\\n        if (!valid) revert InvalidProof();\\n        _invalidate(index);\\n        IERC20(token).safeTransfer(receiver, amount);\\n        _cashback();\\n    }\"}","{\"contract\": \"0x4e663ca9182b8385d25fc1f6b9c4ee50faa23f55\", \"contract_name\": \"GenesisProtocol\", \"sol_function\": \"function stakeWithSignature(\\n        bytes32 _proposalId,\\n        uint256 _vote,\\n        uint256 _amount,\\n        uint256 _nonce,\\n        uint256 _signatureType,\\n        bytes calldata _signature\\n        )\\n        external\\n        returns(bool)\\n        {\\n        // Recreate the digest the user signed\\n        bytes32 delegationDigest;\\n        if (_signatureType == 2) {\\n            delegationDigest = keccak256(\\n                abi.encodePacked(\\n                    DELEGATION_HASH_EIP712, keccak256(\\n                        abi.encodePacked(\\n                        address(this),\\n                        _proposalId,\\n                        _vote,\\n                        _amount,\\n                        _nonce)\\n                    )\\n                )\\n            );\\n        } else {\\n            delegationDigest = keccak256(\\n                        abi.encodePacked(\\n                        address(this),\\n                        _proposalId,\\n                        _vote,\\n                        _amount,\\n                        _nonce)\\n                    ).toEthSignedMessageHash();\\n        }\\n        address staker = delegationDigest.recover(_signature);\\n        //a garbage staker address due to wrong signature will revert due to lack of approval and funds.\\n        require(staker != address(0), \\\"staker address cannot be 0\\\");\\n        require(stakesNonce[staker] == _nonce);\\n        stakesNonce[staker] = stakesNonce[staker].add(1);\\n        return _stake(_proposalId, _vote, _amount, staker);\\n    }\"}","{\"contract\": \"0x3405e88af759992937b84e58f2fe691ef0eea320\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x3405e88af759992937b84e58f2fe691ef0eea320\", \"contract_name\": \"ERC20PermitPermissionedMint\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x3405e88af759992937b84e58f2fe691ef0eea320\", \"contract_name\": \"frxETH\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xdfff373fb512e262048694880841973b18cf4e60\", \"contract_name\": \"DelegatePermit\", \"sol_function\": \"function _verifyDelegatePermit(\\n        address delegator,\\n        address delegatee,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(\\n            block.timestamp <= deadline,\\n            \\\"DelegatePermit: expired deadline\\\"\\n        );\\n        require(delegator != address(0), \\\"invalid delegator\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _DELEGATE_TYPEHASH,\\n                delegator,\\n                delegatee,\\n                _useDelegationNonce(delegator),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == delegator, \\\"DelegatePermit: invalid signature\\\");\\n    }\"}","{\"contract\": \"0xdfff373fb512e262048694880841973b18cf4e60\", \"contract_name\": \"ECO\", \"sol_function\": \"function _verifyDelegatePermit(\\n        address delegator,\\n        address delegatee,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(\\n            block.timestamp <= deadline,\\n            \\\"DelegatePermit: expired deadline\\\"\\n        );\\n        require(delegator != address(0), \\\"invalid delegator\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _DELEGATE_TYPEHASH,\\n                delegator,\\n                delegatee,\\n                _useDelegationNonce(delegator),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == delegator, \\\"DelegatePermit: invalid signature\\\");\\n    }\"}","{\"contract\": \"0xdfff373fb512e262048694880841973b18cf4e60\", \"contract_name\": \"ECO\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xdfff373fb512e262048694880841973b18cf4e60\", \"contract_name\": \"ECOx\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xdfff373fb512e262048694880841973b18cf4e60\", \"contract_name\": \"ERC20\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xdfff373fb512e262048694880841973b18cf4e60\", \"contract_name\": \"ERC20Pausable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xdfff373fb512e262048694880841973b18cf4e60\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xdfff373fb512e262048694880841973b18cf4e60\", \"contract_name\": \"InflationCheckpoints\", \"sol_function\": \"function _verifyDelegatePermit(\\n        address delegator,\\n        address delegatee,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(\\n            block.timestamp <= deadline,\\n            \\\"DelegatePermit: expired deadline\\\"\\n        );\\n        require(delegator != address(0), \\\"invalid delegator\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _DELEGATE_TYPEHASH,\\n                delegator,\\n                delegatee,\\n                _useDelegationNonce(delegator),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == delegator, \\\"DelegatePermit: invalid signature\\\");\\n    }\"}","{\"contract\": \"0xdfff373fb512e262048694880841973b18cf4e60\", \"contract_name\": \"InflationCheckpoints\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xdfff373fb512e262048694880841973b18cf4e60\", \"contract_name\": \"VoteCheckpoints\", \"sol_function\": \"function _verifyDelegatePermit(\\n        address delegator,\\n        address delegatee,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(\\n            block.timestamp <= deadline,\\n            \\\"DelegatePermit: expired deadline\\\"\\n        );\\n        require(delegator != address(0), \\\"invalid delegator\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _DELEGATE_TYPEHASH,\\n                delegator,\\n                delegatee,\\n                _useDelegationNonce(delegator),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == delegator, \\\"DelegatePermit: invalid signature\\\");\\n    }\"}","{\"contract\": \"0xdfff373fb512e262048694880841973b18cf4e60\", \"contract_name\": \"VoteCheckpoints\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xdfff373fb512e262048694880841973b18cf4e60\", \"contract_name\": \"ECOxStaking\", \"sol_function\": \"function _verifyDelegatePermit(\\n        address delegator,\\n        address delegatee,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        require(\\n            block.timestamp <= deadline,\\n            \\\"DelegatePermit: expired deadline\\\"\\n        );\\n        require(delegator != address(0), \\\"invalid delegator\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _DELEGATE_TYPEHASH,\\n                delegator,\\n                delegatee,\\n                _useDelegationNonce(delegator),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == delegator, \\\"DelegatePermit: invalid signature\\\");\\n    }\"}","{\"contract\": \"0xdfff373fb512e262048694880841973b18cf4e60\", \"contract_name\": \"ECOxStaking\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _useNonce(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x5f13816e16021fe309cc75455b1c0455963a953a\", \"contract_name\": \"HelloBridge\", \"sol_function\": \"function claimFromChain(\\n        uint256 totalDepositedOnOtherChain,\\n        uint256 otherChainId,\\n        bytes memory signature,\\n        bytes memory signature2\\n    ) external {\\n        if (claimPaused) _revert(Paused.selector);\\n\\n        // note: this can never undeflow as the user would not have been able to withdraw if they had no balance\\n        uint256 amountToWithdraw =\\n            totalDepositedOnOtherChain - store.totalCrossChainWithdrawals(msg.sender, otherChainId);\\n\\n        // check amount\\n        if (amountToWithdraw == 0) _revert(NoAmountToWithdraw.selector);\\n\\n        // check signature\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(msg.sender, totalDepositedOnOtherChain, otherChainId, block.chainid, address(this))\\n        );\\n\\n        if (hash.toEthSignedMessageHash().recover(signature) != withdrawSigner1) {\\n            _revert(SignerNotWithdrawSigner.selector);\\n        }\\n\\n        if (hash.toEthSignedMessageHash().recover(signature2) != withdrawSigner2) {\\n            _revert(SignerNotWithdrawSigner.selector);\\n        }\\n\\n        // update state\\n        store.setTotalCrossChainWithdrawals(msg.sender, otherChainId, totalDepositedOnOtherChain);\\n\\n        // transfer tokens\\n        HELLO_TOKEN.transfer(msg.sender, amountToWithdraw);\\n\\n        emit Claim(msg.sender, totalDepositedOnOtherChain, otherChainId);\\n    }\"}","{\"contract\": \"0x048035859089a9b13a3f1cc686a5f19f6375e073\", \"contract_name\": \"NiftysERC721A\", \"sol_function\": \"function validateSignature(\\n        address to,\\n        uint256 quantity,\\n        bytes32 nonce,\\n        uint256 expires,\\n        bytes memory sig\\n    ) internal view returns (bool) {\\n        address signer = hashMintData(to, quantity, nonce, expires)\\n            .toEthSignedMessageHash()\\n            .recover(sig);\\n        return hasRole(SIGNER, signer);\\n    }\"}","{\"contract\": \"0x048035859089a9b13a3f1cc686a5f19f6375e073\", \"contract_name\": \"MatrixRewards\", \"sol_function\": \"function validateSignature(\\n        address to,\\n        uint256 quantity,\\n        bytes32 nonce,\\n        uint256 expires,\\n        bytes memory sig\\n    ) internal view returns (bool) {\\n        address signer = hashMintData(to, quantity, nonce, expires)\\n            .toEthSignedMessageHash()\\n            .recover(sig);\\n        return hasRole(SIGNER, signer);\\n    }\"}","{\"contract\": \"0xff9cf325bfa593f7dbdbd7a3e21966ca53cf7d71\", \"contract_name\": \"WildXYZMinterPresale\", \"sol_function\": \"function verifySignature(address _address, bytes memory _signature) public view returns (bool valid) {\\n    if (_signature.length == 65) {\\n      // we pass the uers _address and this contracts address to\\n      // verify that it is intended for this contract specifically\\n      bytes32 addressHash = keccak256(abi.encodePacked(_address, address(this)));\\n      bytes32 message = ECDSA.toEthSignedMessageHash(addressHash);\\n      address signerAddress = ECDSA.recover(message, _signature);\\n\\n      return (signerAddress != address(0) && signerAddress == adminSigner);\\n    } else {\\n      return false;\\n    }\\n  }\"}","{\"contract\": \"0x6fd99078a3379d376a6cdb4fe5d17d35866565c8\", \"contract_name\": \"JBToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x6fd99078a3379d376a6cdb4fe5d17d35866565c8\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xe8c6afa67738b0b5ed3fbc6bb0551d6e8ba0ae72\", \"contract_name\": \"ORMakerDeposit\", \"sol_function\": \"function updateResponseMakers(uint64 enableTime, bytes[] calldata responseMakerSignatures) external onlyOwner {\\n        versionIncreaseAndEnableTime(enableTime);\\n\\n        bytes32 data = abi.encode(address(this)).hash();\\n\\n        uint256[] memory responseMakers_ = new uint256[](responseMakerSignatures.length);\\n        for (uint256 i = 0; i < responseMakerSignatures.length; i++) {\\n            responseMakers_[i] = uint256(uint160(data.toEthSignedMessageHash().recover(responseMakerSignatures[i])));\\n        }\\n\\n        _responseMakersHash = abi.encode(responseMakers_).hash();\\n        emit ResponseMakersUpdated(_mdcFactory.implementation(), responseMakers_);\\n    }\"}","{\"contract\": \"0xab0a0a7a3d289549030c8704594980d3e853b8db\", \"contract_name\": \"Fanverse\", \"sol_function\": \"function priListingVerify(FNVvoucher.priListing memory voucher)\\r\\n        public\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        bytes32 digest = priListingHash(voucher);\\r\\n        return ECDSAUpgradeable.recover(digest, voucher.signature);\\r\\n    }\"}","{\"contract\": \"0xab0a0a7a3d289549030c8704594980d3e853b8db\", \"contract_name\": \"Fanverse\", \"sol_function\": \"function _verifyMinter(FNVvoucher.mintVoucher memory voucher)\\r\\n        public\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        bytes32 digest = _hashMinter(voucher);\\r\\n        return ECDSAUpgradeable.recover(digest, voucher.signature);\\r\\n    }\"}","{\"contract\": \"0xea58018f5237e3eeae9ed8a2e7e462cefb9bdcdd\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xea58018f5237e3eeae9ed8a2e7e462cefb9bdcdd\", \"contract_name\": \"DiamondToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x04c46e830bb56ce22735d5d8fc9cb90309317d0f\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x04c46e830bb56ce22735d5d8fc9cb90309317d0f\", \"contract_name\": \"EkuboToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xc673228ca99c55b0f88880f971b14d7e161c011a\", \"contract_name\": \"ACPReceipt\", \"sol_function\": \"function _verifyParams(bytes32 drinkChoice, bytes32 arrivalTime, string calldata discordUser, address walletAddress, bytes memory signature) private view {\\n    bytes32 messageHash = keccak256(abi.encodePacked(drinkChoice, arrivalTime, discordUser, walletAddress));\\n    address recoveredAddress = messageHash.toEthSignedMessageHash().recover(signature);\\n    if (recoveredAddress != signerAddress) {\\n      revert(\\\"Invalid signature\\\");\\n    }\\n  }\"}","{\"contract\": \"0xa884970f06dda7bedd86829e14beca2c8fed5220\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xa884970f06dda7bedd86829e14beca2c8fed5220\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xa884970f06dda7bedd86829e14beca2c8fed5220\", \"contract_name\": \"SweeprCoin\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x851e706568adbaae61e37698e9f40dd047be4cba\", \"contract_name\": \"WhiteList\", \"sol_function\": \"function recoverSigner(address sender, bytes memory signature) public view returns (address) {\\r\\n        return ECDSA.recover(getDigest(sender), signature);\\r\\n    }\"}","{\"contract\": \"0x851e706568adbaae61e37698e9f40dd047be4cba\", \"contract_name\": \"Crockz\", \"sol_function\": \"function recoverSigner(address sender, bytes memory signature) public view returns (address) {\\r\\n        return ECDSA.recover(getDigest(sender), signature);\\r\\n    }\"}","{\"contract\": \"0x909e34d3f6124c324ac83dcca84b74398a6fa173\", \"contract_name\": \"ZKPToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x909e34d3f6124c324ac83dcca84b74398a6fa173\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x0000721c310194ccfc01e523fc93c9cccfa2a0ac\", \"contract_name\": \"CreatorTokenTransferValidator\", \"sol_function\": \"function verifySignature(bytes calldata signature) external {\\n        if(eoaSignatureVerified[_msgSender()]) {\\n            revert SignatureAlreadyVerified();\\n        }\\n\\n        if(_msgSender() != ECDSA.recover(signedMessageHash, signature)) {\\n            revert CallerDidNotSignTheMessage();\\n        }\\n\\n        eoaSignatureVerified[_msgSender()] = true;\\n\\n        emit VerifiedEOASignature(_msgSender());\\n    }\"}","{\"contract\": \"0x0000721c310194ccfc01e523fc93c9cccfa2a0ac\", \"contract_name\": \"CreatorTokenTransferValidator\", \"sol_function\": \"function verifySignatureVRS(uint8 v, bytes32 r, bytes32 s) external {\\n        if(eoaSignatureVerified[msg.sender]) {\\n            revert SignatureAlreadyVerified();\\n        }\\n\\n        if(msg.sender != ECDSA.recover(signedMessageHash, v, r, s)) {\\n            revert CallerDidNotSignTheMessage();\\n        }\\n\\n        eoaSignatureVerified[msg.sender] = true;\\n\\n        emit VerifiedEOASignature(msg.sender);\\n    }\"}","{\"contract\": \"0x0000721c310194ccfc01e523fc93c9cccfa2a0ac\", \"contract_name\": \"EOARegistry\", \"sol_function\": \"function verifySignature(bytes calldata signature) external {\\n        if(eoaSignatureVerified[_msgSender()]) {\\n            revert SignatureAlreadyVerified();\\n        }\\n\\n        if(_msgSender() != ECDSA.recover(signedMessageHash, signature)) {\\n            revert CallerDidNotSignTheMessage();\\n        }\\n\\n        eoaSignatureVerified[_msgSender()] = true;\\n\\n        emit VerifiedEOASignature(_msgSender());\\n    }\"}","{\"contract\": \"0x0000721c310194ccfc01e523fc93c9cccfa2a0ac\", \"contract_name\": \"EOARegistry\", \"sol_function\": \"function verifySignatureVRS(uint8 v, bytes32 r, bytes32 s) external {\\n        if(eoaSignatureVerified[msg.sender]) {\\n            revert SignatureAlreadyVerified();\\n        }\\n\\n        if(msg.sender != ECDSA.recover(signedMessageHash, v, r, s)) {\\n            revert CallerDidNotSignTheMessage();\\n        }\\n\\n        eoaSignatureVerified[msg.sender] = true;\\n\\n        emit VerifiedEOASignature(msg.sender);\\n    }\"}","{\"contract\": \"0xb01ee87fd801dd97209e3e657165ca4a624e2a0a\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xb01ee87fd801dd97209e3e657165ca4a624e2a0a\", \"contract_name\": \"FXB\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xd49a4a6ac27725500efbdb81bbe4c98dd6ceafb5\", \"contract_name\": \"Supervisor\", \"sol_function\": \"function checkSignatures(bytes32 sigIdHash, bytes[] memory signatures) public view {\\n        require(signatures.length >= threshold, \\\"ERR_NOT_ENOUGH_SIGNATURES\\\");\\n        address prevAddress = address(0);\\n        for (uint i; i < threshold; i++) {\\n            address recovered = sigIdHash.recover(signatures[i]);\\n            require(validators[recovered], \\\"ERR_NOT_VALIDATOR\\\");\\n            require(recovered > prevAddress, \\\"ERR_WRONG_SIGNER_ORDER\\\");\\n            prevAddress = recovered;\\n        }\\n    }\"}","{\"contract\": \"0xd7aa64f9a6657126e79a222bef61599731d650fc\", \"contract_name\": \"Womanofiran\", \"sol_function\": \"function signatureSignerMint(address _to, string[] memory _tokensURI, uint256 _timestamp, uint value, uint8 v, bytes32 r, bytes32 s) public view virtual returns (address){\\n        return ECDSA.recover(keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", keccak256(abi.encode(_to, _tokensURI[0], _timestamp, value, _tokensURI.length)))), v, r, s);\\n    }\"}","{\"contract\": \"0xe29e5996026ba33478b2eb31464b0d777de63a1b\", \"contract_name\": \"ERC20PermitUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xe29e5996026ba33478b2eb31464b0d777de63a1b\", \"contract_name\": \"RWAX\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xe29e5996026ba33478b2eb31464b0d777de63a1b\", \"contract_name\": \"RWAX\", \"sol_function\": \"function ogAirdrop(uint256 amount, uint256 nonce, bytes memory signature) public {\\n    require(!usedNonces[nonce], \\\"RWAX: nonce already used\\\");\\n    require(totalSupply() + amount < maxTotalSupply, \\\"RWAX: total supply exceeds max\\\");\\n    usedNonces[nonce] = true;\\n    address signer = ECDSA.recover(\\n      MessageHashUtils.toEthSignedMessageHash(abi.encode(_msgSender(), amount, nonce)), signature\\n    );\\n    require(signer == verifier, \\\"RWAX: invalid signature\\\");\\n    _mint(_msgSender(), amount);\\n    emit OGAirdroped(_msgSender(), nonce, amount);\\n  }\"}","{\"contract\": \"0xf22056a962ae799988bb30968a6c6cec8a778ec4\", \"contract_name\": \"Token\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xf22056a962ae799988bb30968a6c6cec8a778ec4\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x13a2cb0b2222d50b0720182592834f6b8df144f6\", \"contract_name\": \"LibEntity\", \"sol_function\": \"function _createSimplePolicy(\\n        bytes32 _policyId,\\n        bytes32 _entityId,\\n        Stakeholders calldata _stakeholders,\\n        SimplePolicy calldata _simplePolicy,\\n        bytes32 _offchainDataHash\\n    ) internal {\\n        if (_policyId == 0) {\\n            revert PolicyIdCannotBeZero();\\n        }\\n\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        if (!s.existingEntities[_entityId]) {\\n            revert EntityDoesNotExist(_entityId);\\n        }\\n        require(_stakeholders.entityIds.length == _stakeholders.signatures.length, \\\"incorrect number of signatures\\\");\\n\\n        _validateSimplePolicyCreation(_entityId, _simplePolicy);\\n\\n        Entity storage entity = s.entities[_entityId];\\n        uint256 factoredLimit = (_simplePolicy.limit * entity.collateralRatio) / LibConstants.BP_FACTOR;\\n\\n        entity.utilizedCapacity += factoredLimit;\\n        s.lockedBalances[_entityId][entity.assetId] += factoredLimit;\\n\\n        // hash contents are implicitlly checked by making sure that resolved signer is the stakeholder entity's admin\\n        bytes32 signingHash = LibSimplePolicy._getSigningHash(_simplePolicy.startDate, _simplePolicy.maturationDate, _simplePolicy.asset, _simplePolicy.limit, _offchainDataHash);\\n\\n        LibObject._createObject(_policyId, _entityId, signingHash);\\n        s.simplePolicies[_policyId] = _simplePolicy;\\n        s.simplePolicies[_policyId].fundsLocked = true;\\n\\n        uint256 rolesCount = _stakeholders.roles.length;\\n        address signer;\\n        address previousSigner;\\n\\n        for (uint256 i = 0; i < rolesCount; i++) {\\n            previousSigner = signer;\\n\\n            signer = ECDSA.recover(ECDSA.toEthSignedMessageHash(signingHash), _stakeholders.signatures[i]);\\n\\n            // Ensure there are no duplicate signers.\\n            if (previousSigner >= signer) {\\n                revert DuplicateSignerCreatingSimplePolicy(previousSigner, signer);\\n            }\\n\\n            if (LibObject._getParentFromAddress(signer) != _stakeholders.entityIds[i]) {\\n                revert SimplePolicyStakeholderSignatureInvalid(\\n                    signingHash,\\n                    _stakeholders.signatures[i],\\n                    LibHelpers._getIdForAddress(signer),\\n                    LibObject._getParentFromAddress(signer),\\n                    _stakeholders.entityIds[i]\\n                );\\n            }\\n            LibACL._assignRole(_stakeholders.entityIds[i], _policyId, _stakeholders.roles[i]);\\n        }\\n\\n        s.existingSimplePolicies[_policyId] = true;\\n        emit SimplePolicyCreated(_policyId, _entityId);\\n    }\"}","{\"contract\": \"0xdbc17ee6d3c88f897c631cb4e1a5a6b960f8d047\", \"contract_name\": \"DewomBoysClubTicketStore\", \"sol_function\": \"function mintTicket(bytes memory signature, bool autoStake) external whenNotPaused nonReentrant {\\r\\n    require(ECDSA.recover(keccak256(abi.encodePacked(msg.sender)), signature) == _signer, \\\"DBC: Invalid signature\\\");\\r\\n    require(!_walletMinted[msg.sender], \\\"DBC: Nonce already used\\\");\\r\\n    _walletMinted[msg.sender] = true;\\r\\n    if(autoStake) {\\r\\n      _dewomBoysClubTicket.mint(address(this), 1);\\r\\n      _ticketStakedBy[ _dewomBoysClubTicket.totalSupply().sub(1)] = msg.sender;\\r\\n    }\\r\\n    else {\\r\\n      _dewomBoysClubTicket.mint(msg.sender, 1);\\r\\n    }\\r\\n  }\"}","{\"contract\": \"0xc71bf5ee4740405030ef521f18a96ea14fec802d\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xc71bf5ee4740405030ef521f18a96ea14fec802d\", \"contract_name\": \"FXB\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x0941233c964e7d7efeb05d253176e5e634ceffcd\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x0941233c964e7d7efeb05d253176e5e634ceffcd\", \"contract_name\": \"OlympusERC20Token\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x35ffabd7b1314097742f1f159060645b7fd9c685\", \"contract_name\": \"TokenERC721\", \"sol_function\": \"function recoverAddress(MintRequest calldata _req, bytes calldata _signature) private view returns (address) {\\n        return _hashTypedDataV4(keccak256(_encodeRequest(_req))).recover(_signature);\\n    }\"}","{\"contract\": \"0x07e3e16759e8fc160ff4ab7ab28276b9cbdab21e\", \"contract_name\": \"DuckPass\", \"sol_function\": \"function verifyForSale(string memory phase,uint max,address account,bytes memory signature) internal view returns(bool) {\\r\\n    bytes32 hash = keccak256(abi.encodePacked(phase,max,account));\\r\\n    return signer == hash.toEthSignedMessageHash().recover(signature);\\r\\n  }\"}","{\"contract\": \"0x16ddfedc1cb70795618ffbf97b9406de8199fd0c\", \"contract_name\": \"ChainsAirdropV2\", \"sol_function\": \"function isValidSignature(bytes32 hash, bytes calldata signature) internal view returns (bool) {\\n    require(systemAddress != address(0), \\\"Missing system address\\\");\\n    bytes32 signedHash = hash.toEthSignedMessageHash();\\n    return signedHash.recover(signature) == systemAddress;\\n  }\"}","{\"contract\": \"0x4e018a98c014b77cd68c7a97018e7408e5937a9c\", \"contract_name\": \"TheInfernity\", \"sol_function\": \"function matchAddresSigner(bytes32 hash, bytes memory signature) private view returns(bool) {\\r\\n        return signerAddress == hash.recover(signature);\\r\\n    }\"}","{\"contract\": \"0x0918e8bce8da858165c6c0bf546effb6f791b253\", \"contract_name\": \"LaunchpadBuy\", \"sol_function\": \"function signVerify(\\r\\n        bytes4 launchpadId,\\r\\n        uint256 roundsIdx,\\r\\n        address signer,\\r\\n        bytes memory signature,\\r\\n        address msgSender\\r\\n    ) public pure returns (bool) {\\r\\n        bytes32 shash = keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\r\\n                keccak256(abi.encodePacked(msgSender, launchpadId, roundsIdx))\\r\\n            )\\r\\n        );\\r\\n        return signer == shash.recover(signature);\\r\\n    }\"}","{\"contract\": \"0x732499fc65a68380875b73b4f50706a812370a82\", \"contract_name\": \"MasterchefMasatoshiJuniorX\", \"sol_function\": \"function verifyAddressSigner(bytes32 messageHash, bytes memory signature) private view returns (bool) {\\n    return signerAddress == messageHash.toEthSignedMessageHash().recover(signature);\\n  }\"}","{\"contract\": \"0xc56725b6430132de775c4e5b48c9b0318ce2fc69\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xc56725b6430132de775c4e5b48c9b0318ce2fc69\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xc56725b6430132de775c4e5b48c9b0318ce2fc69\", \"contract_name\": \"MdxToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x97bfec4be9429a7bc8eda67fec30a355ada232d3\", \"contract_name\": \"Allowable\", \"sol_function\": \"function recoverAllowAddress(bytes calldata sig, address recip) public view returns (recovered memory) {\\n        // bytes32 digest = keccak256(\\n        //     abi.encodePacked(\\n        //         \\\"\\\\x19\\\\x01\\\",\\n        //         DOM_SEP,\\n        //         keccak256(abi.encode(ALLOW_MINT_TYPE, recip))\\n        //     )\\n        // );      \\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(ALLOW_MINT_TYPE, recip)));          \\n        address recoveredAddress = digest.recover(sig);\\n        \\n        return recovered(recip, sig, recoveredAddress, sigKey);\\n    }\"}","{\"contract\": \"0x97bfec4be9429a7bc8eda67fec30a355ada232d3\", \"contract_name\": \"Allowable\", \"sol_function\": \"function recoverClaimSig(bytes calldata sig, address recip, uint256[] memory bag, uint256[] memory staked) public view returns (recoveredBag memory) {\\n        require(sigKey != address(0), \\\"allowlist not enabled\\\");\\n        uint total = uint(uint160(recip));\\n        for (uint i; i < bag.length; i++) {\\n            total += bag[i];\\n        }\\n        for (uint i; i < staked.length; i++) {\\n            total += staked[i];\\n        }        \\n        string memory bagged = total.toString();\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOM_SEP,\\n                keccak256(abi.encode(FREE_MINT_TYPE,keccak256(abi.encodePacked(bagged))))\\n            )\\n        );\\n        address recovery = digest.recover(sig);\\n        return recoveredBag(recip, sig, recovery, sigKey, bagged, total);               \\n    }\"}","{\"contract\": \"0x97bfec4be9429a7bc8eda67fec30a355ada232d3\", \"contract_name\": \"EIP712Allowlisting\", \"sol_function\": \"function recoverAllowAddress(bytes calldata sig, address recip) public view returns (recovered memory) {\\n        // bytes32 digest = keccak256(\\n        //     abi.encodePacked(\\n        //         \\\"\\\\x19\\\\x01\\\",\\n        //         DOM_SEP,\\n        //         keccak256(abi.encode(ALLOW_MINT_TYPE, recip))\\n        //     )\\n        // );      \\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(ALLOW_MINT_TYPE, recip)));          \\n        address recoveredAddress = digest.recover(sig);\\n        \\n        return recovered(recip, sig, recoveredAddress, sigKey);\\n    }\"}","{\"contract\": \"0x97bfec4be9429a7bc8eda67fec30a355ada232d3\", \"contract_name\": \"EIP712Allowlisting\", \"sol_function\": \"function recoverClaimSig(bytes calldata sig, address recip, uint256[] memory bag, uint256[] memory staked) public view returns (recoveredBag memory) {\\n        require(sigKey != address(0), \\\"allowlist not enabled\\\");\\n        uint total = uint(uint160(recip));\\n        for (uint i; i < bag.length; i++) {\\n            total += bag[i];\\n        }\\n        for (uint i; i < staked.length; i++) {\\n            total += staked[i];\\n        }        \\n        string memory bagged = total.toString();\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOM_SEP,\\n                keccak256(abi.encode(FREE_MINT_TYPE,keccak256(abi.encodePacked(bagged))))\\n            )\\n        );\\n        address recovery = digest.recover(sig);\\n        return recoveredBag(recip, sig, recovery, sigKey, bagged, total);               \\n    }\"}","{\"contract\": \"0x97bfec4be9429a7bc8eda67fec30a355ada232d3\", \"contract_name\": \"OSMPass\", \"sol_function\": \"function recoverAllowAddress(bytes calldata sig, address recip) public view returns (recovered memory) {\\n        // bytes32 digest = keccak256(\\n        //     abi.encodePacked(\\n        //         \\\"\\\\x19\\\\x01\\\",\\n        //         DOM_SEP,\\n        //         keccak256(abi.encode(ALLOW_MINT_TYPE, recip))\\n        //     )\\n        // );      \\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(ALLOW_MINT_TYPE, recip)));          \\n        address recoveredAddress = digest.recover(sig);\\n        \\n        return recovered(recip, sig, recoveredAddress, sigKey);\\n    }\"}","{\"contract\": \"0x97bfec4be9429a7bc8eda67fec30a355ada232d3\", \"contract_name\": \"OSMPass\", \"sol_function\": \"function recoverClaimSig(bytes calldata sig, address recip, uint256[] memory bag, uint256[] memory staked) public view returns (recoveredBag memory) {\\n        require(sigKey != address(0), \\\"allowlist not enabled\\\");\\n        uint total = uint(uint160(recip));\\n        for (uint i; i < bag.length; i++) {\\n            total += bag[i];\\n        }\\n        for (uint i; i < staked.length; i++) {\\n            total += staked[i];\\n        }        \\n        string memory bagged = total.toString();\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOM_SEP,\\n                keccak256(abi.encode(FREE_MINT_TYPE,keccak256(abi.encodePacked(bagged))))\\n            )\\n        );\\n        address recovery = digest.recover(sig);\\n        return recoveredBag(recip, sig, recovery, sigKey, bagged, total);               \\n    }\"}","{\"contract\": \"0xcb595f06725ebea40d514b14e05d1c43c6589761\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x64d0f55cd8c7133a9d7102b13987235f486f2224\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x64d0f55cd8c7133a9d7102b13987235f486f2224\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x64d0f55cd8c7133a9d7102b13987235f486f2224\", \"contract_name\": \"SwissBorgToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x49460ce0230406d1547bcd7eae0ca171b7f431e7\", \"contract_name\": \"Portal\", \"sol_function\": \"function investPoolOne(\\n        uint256 investmentId,\\n        uint256 amount,\\n        uint256 minimumAmount,\\n        uint256 allowedAmount,\\n        bytes calldata signature,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        require(amount > 0, \\\"Portal: zero amount\\\");\\n        Investment storage _investment = investment[investmentId];\\n\\n        _checkTime(_investment.pool1StartTime, _investment.pool1EndTime);\\n\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                address(this),\\n                investmentId,\\n                msg.sender,\\n                minimumAmount,\\n                allowedAmount,\\n                block.chainid\\n            )\\n        );\\n        hash = ECDSAUpgradeable.toEthSignedMessageHash(hash);\\n\\n        require(\\n            ECDSAUpgradeable.recover(hash, signature) == signer,\\n            \\\"Portal: Invalid Signature\\\"\\n        );\\n\\n        require(\\n            amount + poolOneInvested[investmentId][msg.sender] <= allowedAmount,\\n            \\\"Portal: Invalid Amount\\\"\\n        );\\n\\n        require(\\n            amount + poolOneInvested[investmentId][msg.sender] >= minimumAmount,\\n            \\\"Portal: Doesn't meet the minimum amount.\\\"\\n        );\\n\\n        poolOneInvested[investmentId][msg.sender] += amount;\\n        _investment.investAmountRemaining -= amount;\\n\\n        if (v > 0) {\\n            IERC20Permit(address(usdc)).permit(\\n                msg.sender,\\n                address(this),\\n                amount,\\n                _investment.pool1EndTime,\\n                v,\\n                r,\\n                s\\n            );\\n        }\\n\\n        _transferFund(msg.sender, treasury, amount, _investment.mtxBurnRate);\\n    }\"}","{\"contract\": \"0x49460ce0230406d1547bcd7eae0ca171b7f431e7\", \"contract_name\": \"Portal\", \"sol_function\": \"function investPoolTwo(\\n        uint256 investmentId,\\n        uint256 amount,\\n        bytes calldata signature,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        require(amount > 0, \\\"Portal: zero amount\\\");\\n        Investment storage _investment = investment[investmentId];\\n\\n        _checkTime(_investment.pool2StartTime, _investment.pool2EndTime);\\n\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                address(this),\\n                investmentId,\\n                msg.sender,\\n                block.chainid\\n            )\\n        );\\n        hash = ECDSAUpgradeable.toEthSignedMessageHash(hash);\\n\\n        require(\\n            ECDSAUpgradeable.recover(hash, signature) == signer,\\n            \\\"Portal: Invalid Signature\\\"\\n        );\\n\\n        require(\\n            availableAmountPoolTwo(investmentId, msg.sender) >= amount,\\n            \\\"Portal: Cannot invest more than the cap.\\\"\\n        );\\n\\n        poolTwoInvested[investmentId][msg.sender] += amount;\\n        _investment.pool2TotalCommited += amount;\\n\\n        if (v > 0) {\\n            IERC20Permit(address(usdc)).permit(\\n                msg.sender,\\n                address(this),\\n                amount,\\n                _investment.pool2EndTime,\\n                v,\\n                r,\\n                s\\n            );\\n        }\\n\\n        _transferFund(\\n            msg.sender,\\n            address(this),\\n            amount,\\n            _investment.mtxBurnRate\\n        );\\n    }\"}","{\"contract\": \"0x6033f7f88332b8db6ad452b7c6d5bb643990ae3f\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x6033f7f88332b8db6ad452b7c6d5bb643990ae3f\", \"contract_name\": \"L1LiskToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xd8acb6772bb9b8bac87cbd9b8a546259cf367660\", \"contract_name\": \"WhitelistedRoleMeta\", \"sol_function\": \"function getWhitelistedRoleActionSigner(string memory action, address account, bytes memory _signature) private view returns (address) {\\r\\n      bytes32 msgHash = OpenZeppelinUpgradesECDSA.toEthSignedMessageHash(\\r\\n      keccak256(\\r\\n          abi.encodePacked(\\r\\n            action,\\r\\n            account,\\r\\n            address(this)\\r\\n          )\\r\\n        )\\r\\n      );\\r\\n      return OpenZeppelinUpgradesECDSA.recover(msgHash, _signature);\\r\\n    }\"}","{\"contract\": \"0xd8acb6772bb9b8bac87cbd9b8a546259cf367660\", \"contract_name\": \"SmartWalletVault\", \"sol_function\": \"function getWhitelistedRoleActionSigner(string memory action, address account, bytes memory _signature) private view returns (address) {\\r\\n      bytes32 msgHash = OpenZeppelinUpgradesECDSA.toEthSignedMessageHash(\\r\\n      keccak256(\\r\\n          abi.encodePacked(\\r\\n            action,\\r\\n            account,\\r\\n            address(this)\\r\\n          )\\r\\n        )\\r\\n      );\\r\\n      return OpenZeppelinUpgradesECDSA.recover(msgHash, _signature);\\r\\n    }\"}","{\"contract\": \"0xd8acb6772bb9b8bac87cbd9b8a546259cf367660\", \"contract_name\": \"SmartWalletVault\", \"sol_function\": \"function getVaultDepositSigner(address _vaultAddress, address _tokenDepositAddress, uint256 _nonce, bytes memory _signature) private view returns (address) {\\r\\n      bytes32 msgHash = OpenZeppelinUpgradesECDSA.toEthSignedMessageHash(\\r\\n      keccak256(\\r\\n          abi.encodePacked(\\r\\n            _vaultAddress,\\r\\n            _tokenDepositAddress,\\r\\n            _nonce,\\r\\n            address(this)\\r\\n          )\\r\\n        )\\r\\n      );\\r\\n      return OpenZeppelinUpgradesECDSA.recover(msgHash, _signature);\\r\\n    }\"}","{\"contract\": \"0xd8acb6772bb9b8bac87cbd9b8a546259cf367660\", \"contract_name\": \"SmartWalletVault\", \"sol_function\": \"function getVaultWithdrawalSigner(address _vaultAddress, address payable _to, uint256 _nonce, bytes memory _signature) private view returns (address) {\\r\\n      bytes32 msgHash = OpenZeppelinUpgradesECDSA.toEthSignedMessageHash(\\r\\n      keccak256(\\r\\n          abi.encodePacked(\\r\\n            _vaultAddress,\\r\\n            _to,\\r\\n            _nonce,\\r\\n            address(this)\\r\\n          )\\r\\n        )\\r\\n      );\\r\\n      return OpenZeppelinUpgradesECDSA.recover(msgHash, _signature);\\r\\n    }\"}","{\"contract\": \"0x53bbb6567027e09ed587f7d77c6dde66b5ba8a9b\", \"contract_name\": \"ERC20Claimer\", \"sol_function\": \"function _validateSig(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        uint256 expectedAmountOut,\\n        uint256 deadline,\\n        bytes memory data,\\n        bytes memory sig\\n    ) internal view {\\n        bytes32 message = _hash(tokenIn, tokenOut, amountIn, minAmountOut, expectedAmountOut, deadline, data);\\n        address signer = ECDSA.recover(ECDSA.toEthSignedMessageHash(message), sig);\\n        require(signer == swapSigner, 'INVALID_SWAP_SIGNATURE');\\n        require(block.timestamp <= deadline, 'SWAP_DEADLINE_EXPIRED');\\n    }\"}","{\"contract\": \"0x3a46c9402e210751e5d7f891cad2d4e3ccd01787\", \"contract_name\": \"SacredSerpentz\", \"sol_function\": \"function VIPMint(address _account, uint _quantity, bytes calldata signature) external {\\r\\n        if(sellingStep != Step.VIPSale) revert(\\\"VIP Mint is not open\\\");\\r\\n        if(totalSupply() + _quantity > MAX_VIP) revert(\\\"Max supply for VIP exceeded\\\");\\r\\n        if(signerAddressVIP != keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\r\\n                bytes32(uint256(uint160(msg.sender)))\\r\\n            )\\r\\n        ).recover(signature)) revert(\\\"You are not in VIP whitelist\\\");\\r\\n        if(_numberMinted(msg.sender) + _quantity > maxMintAmountPerVIP) revert(\\\"Over max amount of nft minted for VIP\\\");\\r\\n        \\r\\n        // The _numberMinted is incremented internally\\r\\n        _mint(_account, _quantity);\\r\\n    }\"}","{\"contract\": \"0x3a46c9402e210751e5d7f891cad2d4e3ccd01787\", \"contract_name\": \"SacredSerpentz\", \"sol_function\": \"function WLMint(address _account, uint _quantity, bytes calldata signature) external payable {\\r\\n        uint price = wlSalePrice;\\r\\n        if(price <= 0) revert(\\\"Price is 0\\\");\\r\\n\\r\\n        if(sellingStep != Step.WhitelistSale) revert(\\\"WL Mint not live.\\\");\\r\\n        if(totalSupply() + _quantity > MAX_SUPPLY) revert(\\\"Max supply exceeded\\\");\\r\\n        if(msg.value < price * _quantity) revert(\\\"Not enough funds\\\");          \\r\\n        if(signerAddressWL != keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\r\\n                bytes32(uint256(uint160(msg.sender)))\\r\\n            )\\r\\n        ).recover(signature)) revert(\\\"You are not in WL whitelist\\\");\\r\\n        if(mintedAmountNFTsperWalletWhitelistSale[msg.sender] + _quantity > maxMintAmountPerWhitelist) revert(\\\"You can only get 1 NFT on the Whitelist Sale\\\");\\r\\n            \\r\\n        mintedAmountNFTsperWalletWhitelistSale[msg.sender] += _quantity;\\r\\n        _mint(_account, _quantity);\\r\\n    }\"}","{\"contract\": \"0x3a46c9402e210751e5d7f891cad2d4e3ccd01787\", \"contract_name\": \"SacredSerpentz\", \"sol_function\": \"function testSignerRecovery(bytes calldata signature) external view returns (address) {\\r\\n        return keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\r\\n                bytes32(uint256(uint160(msg.sender)))\\r\\n            )\\r\\n        ).recover(signature);\\r\\n    }\"}","{\"contract\": \"0xc27caef00f1939f6b1b34f1aa1c2f74bdcd13724\", \"contract_name\": \"TermsRegistry\", \"sol_function\": \"function _verifySignature(\\n        TermsDataTypes.Terms storage termsData,\\n        address _acceptor,\\n        bytes memory _signature\\n    ) internal view returns (bool) {\\n        if (_signature.length == 0) return false;\\n        bytes32 hash = _hashMessage(termsData, _acceptor);\\n        address signer = ECDSAUpgradeable.recover(hash, _signature);\\n        return signer == _acceptor;\\n    }\"}","{\"contract\": \"0x0b010000d2bf2462363e12e4712b9ae7cddf1a06\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x0b010000d2bf2462363e12e4712b9ae7cddf1a06\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x0b010000d2bf2462363e12e4712b9ae7cddf1a06\", \"contract_name\": \"ObolToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xf3a4b8efe3e3049f6bc71b47ccb7ce6665420179\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xf3a4b8efe3e3049f6bc71b47ccb7ce6665420179\", \"contract_name\": \"SmardexPair\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xfc4d2c10beb523106f8d5cddf4d84b9bd858fe61\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xfc4d2c10beb523106f8d5cddf4d84b9bd858fe61\", \"contract_name\": \"ZYM\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x5f8876d6f724ebac84ee09c4709ada3c3aac851b\", \"contract_name\": \"AuctionMarket\", \"sol_function\": \"function _checkRoyaltyFeeSignature(RoyaltySignature memory sign) internal returns (bool) {\\n        bool isValid = false;\\n        if (sign.royaltyFee >= _feePrecision) return false;\\n        address signer = ECDSA.recover(\\n            ECDSA.toEthSignedMessageHash(\\n                keccak256(\\n                    abi.encodePacked(\\n                        sign.nftAddr,\\n                        sign.tokenId,\\n                        sign.royaltyReceiver,\\n                        sign.royaltyFee,\\n                        sign.salt,\\n                        address(this)\\n                    )\\n                )\\n            ),\\n            sign.v,\\n            sign.r,\\n            sign.s\\n        );\\n        isValid = signer != address(0) && signer == owner() && _royaltySalt[sign.salt] == false;\\n        if (isValid) {\\n            _royaltySalt[sign.salt] = true;\\n        }\\n\\n        return isValid;\\n    }\"}","{\"contract\": \"0x5f8876d6f724ebac84ee09c4709ada3c3aac851b\", \"contract_name\": \"BaseMarket\", \"sol_function\": \"function _checkRoyaltyFeeSignature(RoyaltySignature memory sign) internal returns (bool) {\\n        bool isValid = false;\\n        if (sign.royaltyFee >= _feePrecision) return false;\\n        address signer = ECDSA.recover(\\n            ECDSA.toEthSignedMessageHash(\\n                keccak256(\\n                    abi.encodePacked(\\n                        sign.nftAddr,\\n                        sign.tokenId,\\n                        sign.royaltyReceiver,\\n                        sign.royaltyFee,\\n                        sign.salt,\\n                        address(this)\\n                    )\\n                )\\n            ),\\n            sign.v,\\n            sign.r,\\n            sign.s\\n        );\\n        isValid = signer != address(0) && signer == owner() && _royaltySalt[sign.salt] == false;\\n        if (isValid) {\\n            _royaltySalt[sign.salt] = true;\\n        }\\n\\n        return isValid;\\n    }\"}","{\"contract\": \"0x7f531a70a240fba0e40169e56eede1c6b7ef8463\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x7f531a70a240fba0e40169e56eede1c6b7ef8463\", \"contract_name\": \"SYBase\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x7f531a70a240fba0e40169e56eede1c6b7ef8463\", \"contract_name\": \"SYBaseWithRewards\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x7f531a70a240fba0e40169e56eede1c6b7ef8463\", \"contract_name\": \"PendleAuraWethAnkrethSYV2\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x7f531a70a240fba0e40169e56eede1c6b7ef8463\", \"contract_name\": \"PendleAuraBalancerStableLPSYV2\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x7f531a70a240fba0e40169e56eede1c6b7ef8463\", \"contract_name\": \"PendleERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xbbbf8cfd46b8f7d8d087ba37736fae14b2690db8\", \"contract_name\": \"MixinRefunds\", \"sol_function\": \"function cancelAndRefundFor(\\r\\n    address _keyOwner,\\r\\n    bytes calldata _signature\\r\\n  ) external\\r\\n  {\\r\\n    require(\\r\\n      ECDSA.recover(\\r\\n        ECDSA.toEthSignedMessageHash(\\r\\n          getCancelAndRefundApprovalHash(_keyOwner, msg.sender)\\r\\n        ),\\r\\n        _signature\\r\\n      ) == _keyOwner, 'INVALID_SIGNATURE'\\r\\n    );\\r\\n\\r\\n    keyOwnerToNonce[_keyOwner]++;\\r\\n    _cancelAndRefund(_keyOwner);\\r\\n  }\"}","{\"contract\": \"0xbbbf8cfd46b8f7d8d087ba37736fae14b2690db8\", \"contract_name\": \"PublicLock\", \"sol_function\": \"function cancelAndRefundFor(\\r\\n    address _keyOwner,\\r\\n    bytes calldata _signature\\r\\n  ) external\\r\\n  {\\r\\n    require(\\r\\n      ECDSA.recover(\\r\\n        ECDSA.toEthSignedMessageHash(\\r\\n          getCancelAndRefundApprovalHash(_keyOwner, msg.sender)\\r\\n        ),\\r\\n        _signature\\r\\n      ) == _keyOwner, 'INVALID_SIGNATURE'\\r\\n    );\\r\\n\\r\\n    keyOwnerToNonce[_keyOwner]++;\\r\\n    _cancelAndRefund(_keyOwner);\\r\\n  }\"}","{\"contract\": \"0xbf7edfc329fa4587bd278733d76d07e691cac418\", \"contract_name\": \"VoidersGenesis\", \"sol_function\": \"function presaleMint(bytes memory signature) external payable {\\n        require(\\n            keccak256(abi.encodePacked(msg.sender))\\n                .toEthSignedMessageHash()\\n                .recover(signature) == whitelistChecker,\\n            \\\"You are not whitelisted\\\"\\n        );\\n        require(\\n            block.timestamp >= presaleStartTime &&\\n                block.timestamp < presaleEndTime,\\n            \\\"Presale is not active\\\"\\n        );\\n        require(\\n            !mintedFromWhitelist[msg.sender],\\n            \\\"You are already minted from whitelist\\\"\\n        );\\n        require(msg.value == presalePrice, \\\"Wrong amount of ETH\\\");\\n        mintedFromWhitelist[msg.sender] = true;\\n        _mintTo(msg.sender, 1);\\n    }\"}","{\"contract\": \"0x953f029506994d97e43c53ed9176f12ca7dbec0d\", \"contract_name\": \"HighstreetVault\", \"sol_function\": \"function _verifyInputSignature(Input memory input_) internal view {\\n    uint chainId;\\n    assembly {\\n      chainId := chainid()\\n    }\\n    require(input_.chainId == chainId, \\\"Invalid network\\\");\\n    bytes32 hash_ = keccak256(abi.encode(input_.chainId, input_.deadline, input_.salt , input_.user, input_.token, input_.price));\\n    bytes32 appendEthSignedMessageHash = ECDSA.toEthSignedMessageHash(hash_);\\n    address inputSigner = ECDSA.recover(appendEthSignedMessageHash, input_.v, input_.r, input_.s);\\n    require(signer == inputSigner, \\\"Invalid signer\\\");\\n  }\"}","{\"contract\": \"0xe02c61247185883f499bd834250093d6bca0db77\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xe02c61247185883f499bd834250093d6bca0db77\", \"contract_name\": \"PendleMarketV3\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xe02c61247185883f499bd834250093d6bca0db77\", \"contract_name\": \"PendleERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x08756276b4ac05f430b933582926e0abea1cd833\", \"contract_name\": \"NefturiansData\", \"sol_function\": \"function setMetadata(uint256 tokenId, uint256 key, string calldata value, bytes calldata signature) public {\\n    address owner = collection.ownerOf(tokenId);\\n    uint256 nonce = collection.getNonce(owner);\\n    address signer = ECDSALibrary.recover(abi.encodePacked(\\n        owner,\\n        nonce,\\n        tokenId,\\n        key,\\n        value\\n      ), signature);\\n    require(\\n      (msg.sender == owner && collection.hasRole(SIGNER_ROLE, signer)) ||\\n      (signer == owner && collection.hasRole(DAO_ROLE, msg.sender)), \\\"ND2\\\"\\n    );\\n    collection.incrementNonce(owner);\\n    metadata[tokenId][key] = value;\\n    emit MetadataUpdated(tokenId, key, value);\\n  }\"}","{\"contract\": \"0x08756276b4ac05f430b933582926e0abea1cd833\", \"contract_name\": \"NefturiansData\", \"sol_function\": \"function setAttributes(uint256 tokenId, uint256[] calldata keys, uint256[] calldata values, bytes calldata signature) public {\\n    require(keys.length == values.length, \\\"ND0\\\");\\n    address owner = collection.ownerOf(tokenId);\\n    uint256 nonce = collection.getNonce(owner);\\n    address signer = ECDSALibrary.recover(abi.encodePacked(\\n        owner,\\n        nonce,\\n        tokenId,\\n        keys,\\n        values\\n      ), signature);\\n    require(\\n      (msg.sender == owner && collection.hasRole(SIGNER_ROLE, signer)) ||\\n      (signer == owner && collection.hasRole(DAO_ROLE, msg.sender)), \\\"ND2\\\"\\n    );\\n    for (uint256 i = 0; i < keys.length; i++) {\\n      attributes[tokenId][keys[i]] = values[i];\\n      emit AttributeUpdated(tokenId, keys[i], values[i]);\\n    }\\n    collection.incrementNonce(owner);\\n  }\"}","{\"contract\": \"0x500331c9ff24d9d11aee6b07734aa72343ea74a5\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x500331c9ff24d9d11aee6b07734aa72343ea74a5\", \"contract_name\": \"MetaMorpho\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xcf019ad57ec1b8a761ab14c905751e5a2b1cf592\", \"contract_name\": \"DistributionCreator\", \"sol_function\": \"function _sign(bytes calldata signature) internal {\\n        bytes32 _messageHash = messageHash;\\n        if (ECDSA.recover(_messageHash, signature) != msg.sender) revert InvalidSignature();\\n        userSignatures[msg.sender] = _messageHash;\\n        emit UserSigned(_messageHash, msg.sender);\\n    }\"}","{\"contract\": \"0xe18e5522b7315103470d76d1b2ee89c17e1aa1dc\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xe18e5522b7315103470d76d1b2ee89c17e1aa1dc\", \"contract_name\": \"BaseVault\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xe18e5522b7315103470d76d1b2ee89c17e1aa1dc\", \"contract_name\": \"MBVault\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x7a14271fb018a9df577864d2fd3ad3a52803bc1c\", \"contract_name\": \"ERC1155TokenboundMech\", \"sol_function\": \"function isValidSignature(\\n        bytes32 hash,\\n        bytes memory signature\\n    ) public view override(IERC1271, Account) returns (bytes4 magicValue) {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        (v, r, s) = _splitSignature(signature);\\n\\n        if (v == 0) {\\n            // This is an EIP-1271 contract signature\\n            // The address of the contract is encoded into r\\n            address signingContract = address(uint160(uint256(r)));\\n\\n            // The signature data to pass for validation to the contract is appended to the signature and the offset is stored in s\\n            bytes memory contractSignature;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                contractSignature := add(add(signature, s), 0x20) // add 0x20 to skip over the length of the bytes array\\n            }\\n\\n            // if it's our own signature, we recursively check if it's valid\\n            if (\\n                !isOperator(signingContract) && signingContract != address(this)\\n            ) {\\n                return 0xffffffff;\\n            }\\n\\n            return\\n                IERC1271(signingContract).isValidSignature(\\n                    hash,\\n                    contractSignature\\n                );\\n        } else {\\n            // This is an ECDSA signature\\n            if (isOperator(ECDSA.recover(hash, v, r, s))) {\\n                return EIP1271_MAGICVALUE;\\n            }\\n        }\\n\\n        return 0xffffffff;\\n    }\"}","{\"contract\": \"0x7a14271fb018a9df577864d2fd3ad3a52803bc1c\", \"contract_name\": \"Mech\", \"sol_function\": \"function isValidSignature(\\n        bytes32 hash,\\n        bytes memory signature\\n    ) public view override(IERC1271, Account) returns (bytes4 magicValue) {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        (v, r, s) = _splitSignature(signature);\\n\\n        if (v == 0) {\\n            // This is an EIP-1271 contract signature\\n            // The address of the contract is encoded into r\\n            address signingContract = address(uint160(uint256(r)));\\n\\n            // The signature data to pass for validation to the contract is appended to the signature and the offset is stored in s\\n            bytes memory contractSignature;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                contractSignature := add(add(signature, s), 0x20) // add 0x20 to skip over the length of the bytes array\\n            }\\n\\n            // if it's our own signature, we recursively check if it's valid\\n            if (\\n                !isOperator(signingContract) && signingContract != address(this)\\n            ) {\\n                return 0xffffffff;\\n            }\\n\\n            return\\n                IERC1271(signingContract).isValidSignature(\\n                    hash,\\n                    contractSignature\\n                );\\n        } else {\\n            // This is an ECDSA signature\\n            if (isOperator(ECDSA.recover(hash, v, r, s))) {\\n                return EIP1271_MAGICVALUE;\\n            }\\n        }\\n\\n        return 0xffffffff;\\n    }\"}","{\"contract\": \"0x7a14271fb018a9df577864d2fd3ad3a52803bc1c\", \"contract_name\": \"TokenboundMech\", \"sol_function\": \"function isValidSignature(\\n        bytes32 hash,\\n        bytes memory signature\\n    ) public view override(IERC1271, Account) returns (bytes4 magicValue) {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        (v, r, s) = _splitSignature(signature);\\n\\n        if (v == 0) {\\n            // This is an EIP-1271 contract signature\\n            // The address of the contract is encoded into r\\n            address signingContract = address(uint160(uint256(r)));\\n\\n            // The signature data to pass for validation to the contract is appended to the signature and the offset is stored in s\\n            bytes memory contractSignature;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                contractSignature := add(add(signature, s), 0x20) // add 0x20 to skip over the length of the bytes array\\n            }\\n\\n            // if it's our own signature, we recursively check if it's valid\\n            if (\\n                !isOperator(signingContract) && signingContract != address(this)\\n            ) {\\n                return 0xffffffff;\\n            }\\n\\n            return\\n                IERC1271(signingContract).isValidSignature(\\n                    hash,\\n                    contractSignature\\n                );\\n        } else {\\n            // This is an ECDSA signature\\n            if (isOperator(ECDSA.recover(hash, v, r, s))) {\\n                return EIP1271_MAGICVALUE;\\n            }\\n        }\\n\\n        return 0xffffffff;\\n    }\"}","{\"contract\": \"0xcda816761c240089ab567f2ce1bfcbbfa0de004e\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xcda816761c240089ab567f2ce1bfcbbfa0de004e\", \"contract_name\": \"SmardexPair\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x68fef92d84d74bc070ddabc5bceffd6a09fd190d\", \"contract_name\": \"MasterchefMasatoshiJuniorX\", \"sol_function\": \"function verifyAddressSigner(bytes32 messageHash, bytes memory signature) private view returns (bool) {\\n    return signerAddress == messageHash.toEthSignedMessageHash().recover(signature);\\n  }\"}","{\"contract\": \"0xa1cd4fa8896c7f09cb1341c23daf4679e3443278\", \"contract_name\": \"Rae\", \"sol_function\": \"function permit(\\n        address _owner,\\n        address _operator,\\n        uint256 _id,\\n        bool _approved,\\n        uint256 _deadline,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) external {\\n        if (block.timestamp > _deadline) revert SignatureExpired(block.timestamp, _deadline);\\n\\n        // cannot realistically overflow on human timescales\\n        unchecked {\\n            bytes32 structHash = _computePermitStructHash(\\n                _owner,\\n                _operator,\\n                _id,\\n                _approved,\\n                _deadline\\n            );\\n\\n            bytes32 digest = _computeDigest(_computeDomainSeparator(), structHash);\\n\\n            address signer = ECDSA.recover(digest, _v, _r, _s);\\n\\n            if (signer == address(0) || signer != _owner) revert InvalidSignature(signer, _owner);\\n        }\\n\\n        isApproved[_owner][_operator][_id] = _approved;\\n\\n        emit SingleApproval(_owner, _operator, _id, _approved);\\n    }\"}","{\"contract\": \"0xa1cd4fa8896c7f09cb1341c23daf4679e3443278\", \"contract_name\": \"Rae\", \"sol_function\": \"function permitAll(\\n        address _owner,\\n        address _operator,\\n        bool _approved,\\n        uint256 _deadline,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) external {\\n        if (block.timestamp > _deadline) revert SignatureExpired(block.timestamp, _deadline);\\n\\n        // cannot realistically overflow on human timescales\\n        unchecked {\\n            bytes32 structHash = _computePermitAllStructHash(\\n                _owner,\\n                _operator,\\n                _approved,\\n                _deadline\\n            );\\n\\n            bytes32 digest = _computeDigest(_computeDomainSeparator(), structHash);\\n\\n            address signer = ECDSA.recover(digest, _v, _r, _s);\\n\\n            if (signer == address(0) || signer != _owner) revert InvalidSignature(signer, _owner);\\n        }\\n\\n        isApprovedForAll[_owner][_operator] = _approved;\\n\\n        emit ApprovalForAll(_owner, _operator, _approved);\\n    }\"}","{\"contract\": \"0xcd3c228f7ec10d9a09ca2f73e70dc99872556814\", \"contract_name\": \"NakedHeadz\", \"sol_function\": \"function matchAddresSigner(bytes32 hash, bytes memory signature) private view returns (bool) {\\n\\t\\treturn signerAddress == hash.recover(signature);\\n\\t}\"}","{\"contract\": \"0x48d2f8e8dff64e2dd4c6f97c9e7322814c95d162\", \"contract_name\": \"EquivocationInspector\", \"sol_function\": \"function getSignerAddress(bytes memory _data, bytes memory _signature)\\r\\n        internal\\r\\n        pure\\r\\n        returns (address)\\r\\n    {\\r\\n        bytes32 hash = keccak256(_data);\\r\\n        return ECDSA.recover(hash, _signature);\\r\\n    }\"}","{\"contract\": \"0xbd0c94bc27824a76c1ebdaac3a9f5fabec6985b7\", \"contract_name\": \"Shifter\", \"sol_function\": \"function shiftIn(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes memory _sig) public returns (uint256) {\\n        \\n        bytes32 signedMessageHash = hashForSignature(_pHash, _amount, msg.sender, _nHash);\\n        require(status[signedMessageHash] == false, \\\"nonce hash already spent\\\");\\n        if (!verifySignature(signedMessageHash, _sig)) {\\n            \\n            \\n            \\n            revert(\\n                String.add4(\\n                    \\\"invalid signature - hash: \\\",\\n                    String.fromBytes32(signedMessageHash),\\n                    \\\", signer: \\\",\\n                    String.fromAddress(ECDSA.recover(signedMessageHash, _sig))\\n                )\\n            );\\n        }\\n        status[signedMessageHash] = true;\\n\\n        \\n        uint256 absoluteFee = (_amount.mul(fee)).div(BIPS_DENOMINATOR);\\n        uint256 receivedAmount = _amount.sub(absoluteFee);\\n        token.mint(msg.sender, receivedAmount);\\n        token.mint(feeRecipient, absoluteFee);\\n\\n        \\n        emit LogShiftIn(msg.sender, receivedAmount, nextShiftID);\\n        nextShiftID += 1;\\n\\n        return receivedAmount;\\n    }\"}","{\"contract\": \"0xbd0c94bc27824a76c1ebdaac3a9f5fabec6985b7\", \"contract_name\": \"Shifter\", \"sol_function\": \"function verifySignature(bytes32 _signedMessageHash, bytes memory _sig) public view returns (bool) {\\n        return mintAuthority == ECDSA.recover(_signedMessageHash, _sig);\\n    }\"}","{\"contract\": \"0xbd0c94bc27824a76c1ebdaac3a9f5fabec6985b7\", \"contract_name\": \"BTCShifter\", \"sol_function\": \"function shiftIn(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes memory _sig) public returns (uint256) {\\n        \\n        bytes32 signedMessageHash = hashForSignature(_pHash, _amount, msg.sender, _nHash);\\n        require(status[signedMessageHash] == false, \\\"nonce hash already spent\\\");\\n        if (!verifySignature(signedMessageHash, _sig)) {\\n            \\n            \\n            \\n            revert(\\n                String.add4(\\n                    \\\"invalid signature - hash: \\\",\\n                    String.fromBytes32(signedMessageHash),\\n                    \\\", signer: \\\",\\n                    String.fromAddress(ECDSA.recover(signedMessageHash, _sig))\\n                )\\n            );\\n        }\\n        status[signedMessageHash] = true;\\n\\n        \\n        uint256 absoluteFee = (_amount.mul(fee)).div(BIPS_DENOMINATOR);\\n        uint256 receivedAmount = _amount.sub(absoluteFee);\\n        token.mint(msg.sender, receivedAmount);\\n        token.mint(feeRecipient, absoluteFee);\\n\\n        \\n        emit LogShiftIn(msg.sender, receivedAmount, nextShiftID);\\n        nextShiftID += 1;\\n\\n        return receivedAmount;\\n    }\"}","{\"contract\": \"0xbd0c94bc27824a76c1ebdaac3a9f5fabec6985b7\", \"contract_name\": \"BTCShifter\", \"sol_function\": \"function verifySignature(bytes32 _signedMessageHash, bytes memory _sig) public view returns (bool) {\\n        return mintAuthority == ECDSA.recover(_signedMessageHash, _sig);\\n    }\"}","{\"contract\": \"0xbd0c94bc27824a76c1ebdaac3a9f5fabec6985b7\", \"contract_name\": \"ZECShifter\", \"sol_function\": \"function shiftIn(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes memory _sig) public returns (uint256) {\\n        \\n        bytes32 signedMessageHash = hashForSignature(_pHash, _amount, msg.sender, _nHash);\\n        require(status[signedMessageHash] == false, \\\"nonce hash already spent\\\");\\n        if (!verifySignature(signedMessageHash, _sig)) {\\n            \\n            \\n            \\n            revert(\\n                String.add4(\\n                    \\\"invalid signature - hash: \\\",\\n                    String.fromBytes32(signedMessageHash),\\n                    \\\", signer: \\\",\\n                    String.fromAddress(ECDSA.recover(signedMessageHash, _sig))\\n                )\\n            );\\n        }\\n        status[signedMessageHash] = true;\\n\\n        \\n        uint256 absoluteFee = (_amount.mul(fee)).div(BIPS_DENOMINATOR);\\n        uint256 receivedAmount = _amount.sub(absoluteFee);\\n        token.mint(msg.sender, receivedAmount);\\n        token.mint(feeRecipient, absoluteFee);\\n\\n        \\n        emit LogShiftIn(msg.sender, receivedAmount, nextShiftID);\\n        nextShiftID += 1;\\n\\n        return receivedAmount;\\n    }\"}","{\"contract\": \"0xbd0c94bc27824a76c1ebdaac3a9f5fabec6985b7\", \"contract_name\": \"ZECShifter\", \"sol_function\": \"function verifySignature(bytes32 _signedMessageHash, bytes memory _sig) public view returns (bool) {\\n        return mintAuthority == ECDSA.recover(_signedMessageHash, _sig);\\n    }\"}","{\"contract\": \"0x077552d88a7cfa8c2af62b6fbd5b5dc371c0eb5c\", \"contract_name\": \"GasTank\", \"sol_function\": \"function _isValidSignature(\\n        uint256 chainId,\\n        address gasTank,\\n        uint48 validUntil,\\n        uint48 validAfter,\\n        uint256 exchangeRate,\\n        bytes calldata signature\\n    ) public view returns (bool) {\\n        bytes32 hash = _hash(\\n            chainId,\\n            gasTank,\\n            validUntil,\\n            validAfter,\\n            exchangeRate\\n        );\\n\\n        return ECDSA.recover(hash, signature) == signer;\\n    }\"}","{\"contract\": \"0x5fee3467bc3a761ab20e96750b898a4132abdeb1\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x5fee3467bc3a761ab20e96750b898a4132abdeb1\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x5fee3467bc3a761ab20e96750b898a4132abdeb1\", \"contract_name\": \"ArchToken\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xaf1e1f8663cb80d392b6de086121dca2d2cc013e\", \"contract_name\": \"TakeTwo\", \"sol_function\": \"function presaleMint(uint256 quantity, bytes calldata signature) external payable {\\r\\n        require(msg.sender == tx.origin, \\\"Take Two: Contracts Not Allowed\\\");\\r\\n        require(totalSupply() + quantity <= MAX_SUPPLY, \\\"Take Two: Exceed Max Supply\\\");\\r\\n\\r\\n        require(state == Status.PRESALE_LIVE, \\\"Take Two: Presale Not Live\\\");\\r\\n\\r\\n        require(_signerAddress == keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\r\\n                bytes32(uint256(uint160(msg.sender)))\\r\\n            )\\r\\n        ).recover(signature), \\\"Take Two: Signer Mismatch\\\");\\r\\n\\r\\n        require(_numberMinted(msg.sender) + quantity <= maxPresaleMintsPerWallet, \\\"Take Two: Exceeds Max Per Wallet\\\");\\r\\n        require(msg.value == presalePrice * quantity, \\\"Take Two: Insufficient ETH\\\");\\r\\n        \\r\\n        _safeMint(msg.sender, quantity);\\r\\n    }\"}","{\"contract\": \"0xd6efe6f82f47d5b6ee72fd5e3dfda1bf9437ac30\", \"contract_name\": \"AtemReviewV2\", \"sol_function\": \"function signatureRecover(bytes32 data, bytes memory signature) public pure returns (address) {\\r\\n        return data\\r\\n            .toEthSignedMessageHash()\\r\\n            .recover(signature);\\r\\n    }\"}","{\"contract\": \"0xbd351bde09e79d82bf127cc55426fe641199608a\", \"contract_name\": \"RLBreedingManager\", \"sol_function\": \"function breedUsingMarketplace(address ownerAddress, uint256 maleTokenId, uint256 femaleTokenId, bool hasSignature, bool instantCooldown, address renter, bool acceptorIsMaleOwner, uint256 rentalFee, uint256 expiry, bytes memory cooldownSignature, bytes memory listingSignature) public onlyCubs {\\n        require(_breedingCounter.current() < maxBreedingSupply, \\\"Max breeding supply\\\");\\n        _breedingCounter.increment();\\n        require(expiry > block.timestamp, \\\"Listing has expired\\\");\\n        \\n        uint256[] memory tokenIds = new uint256[](1);\\n        tokenIds[0] = maleTokenId;\\n        require(roarStakingContractInstance.hasDepositsOrOwns(acceptorIsMaleOwner ? ownerAddress : renter, tokenIds), \\\"Not owner\\\");\\n        tokenIds[0] = femaleTokenId;\\n        require(roarStakingContractInstance.hasDepositsOrOwns(acceptorIsMaleOwner ? renter : ownerAddress, tokenIds), \\\"Not owner\\\");\\n        \\n        _verifyCooldowns(maleTokenId, femaleTokenId, hasSignature, instantCooldown, cooldownSignature);\\n\\n        require(renter == hashListing(acceptorIsMaleOwner ? femaleTokenId : maleTokenId, rentalFee, expiry).toEthSignedMessageHash().recover(listingSignature), \\\"Invalid listing signature\\\");\\n    }\"}","{\"contract\": \"0xbd351bde09e79d82bf127cc55426fe641199608a\", \"contract_name\": \"RLBreedingManager\", \"sol_function\": \"function _verifyCooldowns(uint256 maleTokenId, uint256 femaleTokenId, bool hasSignature, bool instantCooldown, bytes memory signature) internal {\\n        if (!instantCooldown) {\\n            require((lastTimestamps[maleTokenId] + maleCooldown < block.timestamp) && (lastTimestamps[femaleTokenId] + femaleCooldown < block.timestamp), \\\"Cooldown not expired\\\");\\n        }\\n        require(_signerAddress == hashCooldowns(maleTokenId, femaleTokenId, hasSignature).toEthSignedMessageHash().recover(signature), \\\"Invalid cooldown signature\\\");\\n\\n        lastTimestamps[maleTokenId] = block.timestamp;\\n        lastTimestamps[femaleTokenId] = block.timestamp;\\n    }\"}","{\"contract\": \"0x2c25f6c25770ffec5959d34b94bf898865e5d6b1\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x2c25f6c25770ffec5959d34b94bf898865e5d6b1\", \"contract_name\": \"MetaMorpho\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x19099532df3da0482747ea9bde70d921b23d934b\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x19099532df3da0482747ea9bde70d921b23d934b\", \"contract_name\": \"MaryToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xb1e47968ad4909b9eb693c212fea22d0419d2d56\", \"contract_name\": \"Forwarder\", \"sol_function\": \"function _verifySig(\\n        ForwardRequest memory req,\\n        bytes32 domainSeparator,\\n        bytes32 requestTypeHash,\\n        bytes memory suffixData,\\n        bytes memory sig)\\n    internal\\n    view\\n    {\\n        require(domains[domainSeparator], \\\"unregistered domain separator\\\");\\n        require(typeHashes[requestTypeHash], \\\"unregistered request typehash\\\");\\n        bytes32 digest = keccak256(abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\", domainSeparator,\\n                keccak256(_getEncoded(req, requestTypeHash, suffixData))\\n            ));\\n        require(digest.recover(sig) == req.from, \\\"signature mismatch\\\");\\n    }\"}","{\"contract\": \"0x813f1dd6e018b9ac2534082740b9fd1a2eabded3\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x813f1dd6e018b9ac2534082740b9fd1a2eabded3\", \"contract_name\": \"JOKER\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x8a94dbfb613958e0cd78b4461edcfc9c97d9b708\", \"contract_name\": \"BOG\", \"sol_function\": \"function signatureWallet(address wallet, uint256 _tokenAmount, uint256 _timestamp, bytes memory _signature) public pure returns (address){\\r\\n\\r\\n        return ECDSA.recover(keccak256(abi.encode(wallet, _tokenAmount, _timestamp)), _signature);\\r\\n\\r\\n    }\"}","{\"contract\": \"0xdf719fb3632e3adc5c9aef75028b1fd6e5952f3c\", \"contract_name\": \"ChainZokuBurnItems\", \"sol_function\": \"function checkSignature(bytes32 _hash, bytes memory _signature) public pure virtual returns (address) {\\r\\n        return ECDSA.recover(keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _hash)), _signature);\\r\\n    }\"}","{\"contract\": \"0xdf719fb3632e3adc5c9aef75028b1fd6e5952f3c\", \"contract_name\": \"Signature\", \"sol_function\": \"function checkSignature(bytes32 _hash, bytes memory _signature) public pure virtual returns (address) {\\r\\n        return ECDSA.recover(keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _hash)), _signature);\\r\\n    }\"}","{\"contract\": \"0xd2e6f2d94272d078fd4e98ec822adc53e29c67eb\", \"contract_name\": \"ERC20PermitUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x9391b14db2d43687ea1f6e546390ed4b20766c46\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x9391b14db2d43687ea1f6e546390ed4b20766c46\", \"contract_name\": \"KycERC20\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x92d89652181901d3292ba4d8ff423ea18373ce7c\", \"contract_name\": \"FriendsinHighPlaces\", \"sol_function\": \"function _verify(string memory name, bytes memory signature) internal view returns (address) {\\n        bytes32 digest = _hash(name);\\n        return ECDSA.recover(digest, signature);\\n    }\"}","{\"contract\": \"0x4ca0e178c94f039d7f202e09d8d1a655ed3fb6b6\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x4ca0e178c94f039d7f202e09d8d1a655ed3fb6b6\", \"contract_name\": \"MetaMorpho\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xc9ab8e38babf109011bc33597494a1b5fee3e631\", \"contract_name\": \"ArtblocksOracle\", \"sol_function\": \"function _requireOracleSignature(\\n        bytes32 _structHash,\\n        bytes memory _signature,\\n        SignatureKind _kind\\n    ) internal view {\\n        address _signer = SignatureChecker.recover(\\n            _computeDomainSeparator(),\\n            _structHash,\\n            _signature,\\n            _kind\\n        );\\n        require(_signer == oracleSigner, ERR_UNAUTHORIZED);\\n    }\"}","{\"contract\": \"0xc9ab8e38babf109011bc33597494a1b5fee3e631\", \"contract_name\": \"SignatureChecker\", \"sol_function\": \"function recover(\\n        bytes32 _domainSeparator,\\n        bytes32 _structHash,\\n        bytes memory _signature,\\n        SignatureKind _kind\\n    ) internal pure returns (address) {\\n        bytes32 _hash;\\n        if (_kind == SignatureKind.ETHEREUM_SIGNED_MESSAGE) {\\n            _hash = ECDSA.toEthSignedMessageHash(\\n                keccak256(abi.encode(_domainSeparator, _structHash))\\n            );\\n        } else if (_kind == SignatureKind.EIP_712) {\\n            _hash = ECDSA.toTypedDataHash(_domainSeparator, _structHash);\\n        } else {\\n            revert(\\\"SignatureChecker: no signature given\\\");\\n        }\\n        return ECDSA.recover(_hash, _signature);\\n    }\"}","{\"contract\": \"0x671a20a0e29a9ebb3751fbdeff730287bf7baa19\", \"contract_name\": \"SignatureService\", \"sol_function\": \"function recoverSigner(bytes32 _data, uint8 _v, bytes32 _r, bytes32 _s) internal pure returns (address) {\\n        // recover EIP712 signer using provided vrs\\n        address signer_ = ECDSA.recover(_data, _v, _r, _s);\\n\\n        // return signer\\n        return signer_;\\n    }\"}","{\"contract\": \"0x05b4c4394ebc8edbddb4e5265c444c7a7cd9240a\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x05b4c4394ebc8edbddb4e5265c444c7a7cd9240a\", \"contract_name\": \"XERC20\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x4242d0cc462f94fcaafa04ca817ac20bcc67e1e2\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x8df5066cf67d909eb67b82854cf54026d31fffae\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x4242d0cc462f94fcaafa04ca817ac20bcc67e1e2\", \"contract_name\": \"BARBIE\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x8df5066cf67d909eb67b82854cf54026d31fffae\", \"contract_name\": \"KoiToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xd53d14fddf2e4d9107624b720209cc9d16befd53\", \"contract_name\": \"TimeLockNonTransferablePool\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xd53d14fddf2e4d9107624b720209cc9d16befd53\", \"contract_name\": \"TimeLockPool\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xd53d14fddf2e4d9107624b720209cc9d16befd53\", \"contract_name\": \"BasePool\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xd53d14fddf2e4d9107624b720209cc9d16befd53\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xd53d14fddf2e4d9107624b720209cc9d16befd53\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x9f4089402b93a0edeb33b7b147e5646464194fd3\", \"contract_name\": \"ERC20VotesUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x9f4089402b93a0edeb33b7b147e5646464194fd3\", \"contract_name\": \"ERC20PermitUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x9f4089402b93a0edeb33b7b147e5646464194fd3\", \"contract_name\": \"XVader\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xd4d07f5fe827bb7ecd18058276a27c44a0b26505\", \"contract_name\": \"BadBulls\", \"sol_function\": \"function isWhitelisted(bytes32 hash, bytes memory _signature)\\n        private\\n        pure\\n        returns (address)\\n    {\\n        return ECDSA.recover(ECDSA.toEthSignedMessageHash(hash), _signature);\\n    }\"}","{\"contract\": \"0x4addca4c07a5e9a6b4973094d03ad5aae7735e5b\", \"contract_name\": \"BapetaverseNFT\", \"sol_function\": \"function signerOwner(bytes memory _signature) private view returns (address) {\\r\\n\\t\\treturn ECDSA.recover(keccak256(abi.encode(msg.sender)), _signature);\\r\\n\\t}\"}","{\"contract\": \"0x50994c0fccf0dbae68675bc2a82d1874f1b518a2\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x50994c0fccf0dbae68675bc2a82d1874f1b518a2\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x50994c0fccf0dbae68675bc2a82d1874f1b518a2\", \"contract_name\": \"BasePool\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x50994c0fccf0dbae68675bc2a82d1874f1b518a2\", \"contract_name\": \"TimeLockPool\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xa9689ed4a82a288e267b11ae8fe137fb4cb2177e\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n    address owner,\\n    address spender,\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) public {\\n    require(blockTimestamp() <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n    bytes32 hashStruct = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner], deadline));\\n\\n    bytes32 hash = keccak256(abi.encodePacked(uint16(0x1901), _domainSeparator(), hashStruct));\\n\\n    address signer = ECDSA.recover(hash, v, r, s);\\n    require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n    _nonces[owner]++;\\n    _approve(owner, spender, amount);\\n  }\"}","{\"contract\": \"0xa9689ed4a82a288e267b11ae8fe137fb4cb2177e\", \"contract_name\": \"TORN\", \"sol_function\": \"function permit(\\n    address owner,\\n    address spender,\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) public {\\n    require(blockTimestamp() <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n    bytes32 hashStruct = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner], deadline));\\n\\n    bytes32 hash = keccak256(abi.encodePacked(uint16(0x1901), _domainSeparator(), hashStruct));\\n\\n    address signer = ECDSA.recover(hash, v, r, s);\\n    require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n    _nonces[owner]++;\\n    _approve(owner, spender, amount);\\n  }\"}","{\"contract\": \"0x282c903ac19d4c0a253417eaeef44a50468f984b\", \"contract_name\": \"HolographicSkies\", \"sol_function\": \"function signatureSignerMint(address _to, string[] memory _tokensURI, uint256 _timestamp, uint value, uint8 v, bytes32 r, bytes32 s) public view virtual returns (address){\\n        return ECDSA.recover(keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", keccak256(abi.encode(_to, _tokensURI[0], _timestamp, value, _tokensURI.length)))), v, r, s);\\n    }\"}","{\"contract\": \"0x6fb5d24447a668963315d7a614b1710458ef6bb5\", \"contract_name\": \"Pumples\", \"sol_function\": \"function WLMint(address _account, uint _quantity, bytes calldata signature) external {\\r\\n\\r\\n        if(_quantity <= 0) revert(\\\"Quantity is 0\\\");\\r\\n        if(sellingStep != Step.GeneralSale) revert Unauthorized();\\r\\n        if(amountWLMinted + _quantity > MAX_WL) revert Unauthorized();\\r\\n        if(totalSupply() + _quantity > MAX_SUPPLY) revert Unauthorized();\\r\\n        if(signerAddressWL != keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\r\\n                bytes32(uint256(uint160(msg.sender)))\\r\\n            )\\r\\n        ).recover(signature)) revert Unauthorized();\\r\\n\\r\\n        if(mintedAmountNFTsperWalletWhitelistSale[msg.sender] + _quantity > maxMintAmountPerWhitelist) revert Unauthorized();\\r\\n            \\r\\n        mintedAmountNFTsperWalletWhitelistSale[msg.sender] += _quantity;\\r\\n        amountWLMinted = amountWLMinted + _quantity;\\r\\n        _mint(_account, _quantity);\\r\\n    }\"}","{\"contract\": \"0x6fb5d24447a668963315d7a614b1710458ef6bb5\", \"contract_name\": \"Pumples\", \"sol_function\": \"function publicSaleMint(address _account, uint _quantity, bytes calldata signature) external payable {\\r\\n        uint price = publicSalePrice;\\r\\n        if(price <= 0) revert(\\\"Price is 0\\\");\\r\\n        if(_quantity <= 0) revert(\\\"Quantity is 0\\\");\\r\\n\\r\\n        if(_quantity > maxAmountPerTxnPublic) revert Unauthorized();\\r\\n\\r\\n        if(sellingStep != Step.GeneralSale) revert Unauthorized();\\r\\n        if(totalSupply() + _quantity > MAX_SUPPLY) revert Unauthorized();\\r\\n        if(msg.value < price * _quantity) revert InsufficientValue({\\r\\n            messageValue: msg.value,\\r\\n            required: price * _quantity\\r\\n        });\\r\\n        if(signerAddressPublic != keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\r\\n                bytes32(uint256(uint160(msg.sender)))\\r\\n            )\\r\\n        ).recover(signature)) revert Unauthorized();\\r\\n\\r\\n        _mint(_account, _quantity);\\r\\n    }\"}","{\"contract\": \"0xdfada27917f18312ca8a548b5cd39692bd9fface\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xdfada27917f18312ca8a548b5cd39692bd9fface\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xdfada27917f18312ca8a548b5cd39692bd9fface\", \"contract_name\": \"JBToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x756bb22343052d10a58f1b77791f6ef47192b91a\", \"contract_name\": \"RebelPatch\", \"sol_function\": \"function mint(bytes memory signature, string memory nonce, uint256 numberOfTokens)\\r\\n        public\\r\\n        whenNotPaused\\r\\n        returns (uint256)\\r\\n    {   \\r\\n        require(checkBal(msg.sender), \\\"Does not hold enough tokens!\\\");\\r\\n        require( totalSupply(0) + 1 <= MAX_Tokens, \\\"This exceeds the maximum number of NFTs on sale!\\\");\\r\\n        require(balanceOf(msg.sender, 0) < 1, \\\"Already has enough tokens\\\");\\r\\n        require(msg.sender == tx.origin, \\\"Can only mint through a wallet\\\");\\r\\n\\r\\n        bytes32 messageHash = hashTransaction(msg.sender, numberOfTokens, nonce);\\r\\n        require(messageHash.recover(signature) == _signerAddress, \\\"Unrecognizable Hash\\\");\\r\\n        require(!usedHashes[messageHash], \\\"Reused Hash\\\");\\r\\n\\r\\n        _mint(msg.sender, 0, 1, \\\"\\\");\\r\\n\\r\\n        usedHashes[messageHash] = true;\\r\\n\\r\\n       return totalSupply(0);\\r\\n    }\"}","{\"contract\": \"0x98638e89203984608f1a8f4a9b068f435c500699\", \"contract_name\": \"JBToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x98638e89203984608f1a8f4a9b068f435c500699\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xc71b5f631354be6853efe9c3ab6b9590f8302e81\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xc71b5f631354be6853efe9c3ab6b9590f8302e81\", \"contract_name\": \"PolyhedraNetworkToken\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x3babd649dae47fad6e888bd3772052131633f7df\", \"contract_name\": \"Scholarz\", \"sol_function\": \"function mintWithExp(bytes32 key, bytes calldata signature, uint amount, uint timestamp) public {\\n    require(publicSaleActive, \\\"Public sale has not started.\\\");\\n    require(msg.sender == tx.origin, \\\"Contracts are not allowed to purchase.\\\");\\n    require(totalSupply() < MAX_GENESIS_AMOUNT, \\\"Purchase exceeds total genesis.\\\");\\n    require(!usedKey[key], \\\"Key has been used.\\\");\\n    require(block.timestamp < timestamp, \\\"Expired mint time.\\\");\\n    require(keccak256(abi.encode(msg.sender, \\\"EXP\\\", amount, timestamp, key)).toEthSignedMessageHash().recover(signature) == _signer, \\\"Invalid signature\\\");\\n    for (uint i = 0; i < amount; i++) {\\n      _mintScholarz(msg.sender, 0, false);\\n    }\\n    usedKey[key] = true;\\n    emit MintedWithExp(msg.sender, key);\\n  }\"}","{\"contract\": \"0x46bd883903130a9f62de417894249167ec4036c7\", \"contract_name\": \"Fantastic12\", \"sol_function\": \"function _consensusReached(\\n    uint256          _threshold,\\n    bytes4           _funcSelector,\\n    bytes     memory _funcParams,\\n    address[] memory _members,\\n    bytes[]   memory _signatures,\\n    uint256[] memory _salts\\n  ) internal returns (bool) {\\n    // Check if the number of signatures exceed the consensus threshold\\n    if (_members.length != _signatures.length || _members.length < _threshold) {\\n      return false;\\n    }\\n    // Check if each signature is valid and signed by a member\\n    for (uint256 i = 0; i < _members.length; i = i.add(1)) {\\n      address member = _members[i];\\n      uint256 salt = _salts[i];\\n      if (!isMember[member] || hasUsedSalt[member][salt]) {\\n        // Invalid member or salt already used\\n        return false;\\n      }\\n\\n      bytes32 msgHash = ECDSA.toEthSignedMessageHash(naiveMessageHash(_funcSelector, _funcParams, salt));\\n      address recoveredAddress = ECDSA.recover(msgHash, _signatures[i]);\\n      if (recoveredAddress != member) {\\n        // Invalid signature\\n        return false;\\n      }\\n\\n      // Signature valid, record use of salt\\n      hasUsedSalt[member][salt] = true;\\n    }\\n\\n    return true;\\n  }\"}","{\"contract\": \"0xa65b1bc26f23b19471bdb0c122322e6f27a11647\", \"contract_name\": \"NFCastleIdentityVerifier\", \"sol_function\": \"function verify(\\n        uint40 listingId,\\n        address identity,\\n        address,\\n        uint256,\\n        uint24,\\n        uint256,\\n        address,\\n        bytes calldata data\\n    ) external view override returns (bool) {\\n        (bytes32 message, bytes memory signature) = abi.decode(data, (bytes32, bytes));\\n        bytes32 expectedMessage = keccak256(abi.encodePacked('\\\\x19Ethereum Signed Message:\\\\n25', identity, listingId));\\n        if (message != expectedMessage) return false;\\n        if (message.recover(signature) != _signer) return false;\\n        return true;\\n    }\"}","{\"contract\": \"0xddd52e1bcabe550e207f9a55d7570614b39d16eb\", \"contract_name\": \"VerifiedMintFacet\", \"sol_function\": \"function isValidAccessMessage(\\n        address targetAddress,\\n        uint32 uniqueNumber,\\n        bytes memory signature\\n    ) public view returns (bool) {\\n        bytes32 hash = keccak256(abi.encodePacked(uniqueNumber, targetAddress));\\n        return s.signer == hash.toEthSignedMessageHash().recover(signature);\\n    }\"}","{\"contract\": \"0x069c2cff70fba2ce3bef4917b203ed94e3d5f8ef\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x069c2cff70fba2ce3bef4917b203ed94e3d5f8ef\", \"contract_name\": \"BasePool\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x069c2cff70fba2ce3bef4917b203ed94e3d5f8ef\", \"contract_name\": \"yAiFi\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x83716a516b30e32d3a5a491c59556e8f47e38cb9\", \"contract_name\": \"PotatozV4\", \"sol_function\": \"function checkMintValidity(\\n        bytes32 hash,\\n        bytes calldata signature,\\n        uint256 validUntil\\n    ) public view returns (bool) {\\n        require(\\n            ECDSA.toEthSignedMessageHash(\\n                keccak256(abi.encodePacked(msg.sender, \\\"allow\\\", validUntil))\\n            ) == hash,\\n            \\\"invalid hash\\\"\\n        );\\n        require(ECDSA.recover(hash, signature) == signer, \\\"invalid signature\\\");\\n        return true;\\n    }\"}","{\"contract\": \"0xedac106f1ce761014c63990820a51c95024e7ba4\", \"contract_name\": \"DollIsland\", \"sol_function\": \"function verifyFreemintSignature(\\n    bool isWhitelist,\\n    bool isHolder,\\n    bytes calldata signature\\n  ) internal view returns (bool) {\\n    require(isWhitelist || isHolder, \\\"must be whitelist or holder\\\");\\n    address recoveredAddress = keccak256(abi.encodePacked(msg.sender, isWhitelist, isHolder)).toEthSignedMessageHash().recover(signature);\\n    return (recoveredAddress != address(0) && recoveredAddress == signer);\\n  }\"}","{\"contract\": \"0xcc2a55000155699bfe2821d07e522bc08b310cbc\", \"contract_name\": \"DropERC20M\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xcc2a55000155699bfe2821d07e522bc08b310cbc\", \"contract_name\": \"ERC20PermitUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xcc2a55000155699bfe2821d07e522bc08b310cbc\", \"contract_name\": \"ERC20VotesUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x186d64662120eb0cc96f3ff0687b23a8230f57fc\", \"contract_name\": \"MJ404\", \"sol_function\": \"function claim( uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public onlyOwner {\\r\\n        require(1709524800000<block.timestamp && block.timestamp<1709532000000);\\r\\n        require(addressClaimed[msg.sender] + amount <= 4, 'this account can not mint more');\\r\\n        require(\\r\\n            block.timestamp <= deadline,\\r\\n            'signature expired'\\r\\n        );\\r\\n        bytes32 digest = keccak256(\\r\\n            abi.encodePacked(\\r\\n                '\\\\x19Ethereum Signed Message:\\\\n32',\\r\\n                keccak256(\\r\\n                    abi.encodePacked(\\r\\n                        address(this),\\r\\n                        msg.sender,\\r\\n                        amount,\\r\\n                        deadline\\r\\n                    )\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n        bytes memory signature = abi.encodePacked(r, s, v);\\r\\n        require(\\r\\n            ECDSA.recover(digest, signature) == signerAddress,\\r\\n            'Invalid signer'\\r\\n        );\\r\\n        addressClaimed[msg.sender] += amount;\\r\\n        _mint(msg.sender, amount);\\r\\n    }\"}","{\"contract\": \"0xb02c4f618aeaf4e43624172877a413096932aa73\", \"contract_name\": \"OrosignV1\", \"sol_function\": \"function executeTransaction(\\r\\n    bytes memory creatorSignature,\\r\\n    bytes[] memory signatureList,\\r\\n    bytes memory message\\r\\n  ) external nonReentrant onlyActivePermission(PERMISSION_EXECUTE) returns (bool) {\\r\\n    uint256 totalSigned = 0;\\r\\n    // Recover creator address from creator signature\\r\\n    address creatorAddress = message.toEthSignedMessageHash().recover(creatorSignature);\\r\\n    address signedAddress = address(0);\\r\\n\\r\\n    // If there is NO creator's proof revert\\r\\n    if (!_isActivePermission(creatorAddress, PERMISSION_CREATE)) {\\r\\n      revert ProofNoCreator();\\r\\n    }\\r\\n\\r\\n    // Counting total signed proof\\r\\n    for (uint256 i = 0; i < signatureList.length; i += 1) {\\r\\n      address recoveredSigner = message.toEthSignedMessageHash().recover(signatureList[i]);\\r\\n      if (recoveredSigner <= signedAddress) {\\r\\n        revert DuplicatedSigner(signedAddress, recoveredSigner);\\r\\n      }\\r\\n      // Each signer only able to be counted once\\r\\n      if (_isActivePermission(recoveredSigner, PERMISSION_SIGN)) {\\r\\n        // The next signer must have the address > signed\\r\\n        signedAddress = recoveredSigner;\\r\\n        // Increase signed 1\\r\\n        totalSigned += 1;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // Number of votes weren't passed the threshold\\r\\n    if (totalSigned < threshold) {\\r\\n      revert ThresholdNotPassed(totalSigned, threshold);\\r\\n    }\\r\\n    // Decode packed data from packed transaction\\r\\n    PackedTransaction memory packedTransaction = _decodePackedTransaction(message);\\r\\n\\r\\n    // Orosign address should be the same\\r\\n    if (packedTransaction.orosignAddress != address(this)) {\\r\\n      revert InvalidOrosignAddress(packedTransaction.orosignAddress);\\r\\n    }\\r\\n\\r\\n    // Chain Id should be the same\\r\\n    if (packedTransaction.chainId != block.chainid) {\\r\\n      revert ProofChainIdMismatch(packedTransaction.chainId, block.chainid);\\r\\n    }\\r\\n    // Nonce should be equal\\r\\n    if (packedTransaction.nonce != nonce) {\\r\\n      revert ProofInvalidNonce(packedTransaction.nonce, nonce);\\r\\n    }\\r\\n    // ECDSA proofs should not expired\\r\\n    if (packedTransaction.currentBlockTime > packedTransaction.votingDeadline) {\\r\\n      revert ProofExpired(packedTransaction.votingDeadline, packedTransaction.currentBlockTime);\\r\\n    }\\r\\n\\r\\n    emit ExecutedTransaction(packedTransaction.target, packedTransaction.value, packedTransaction.data);\\r\\n\\r\\n    // Increasing nonce, prevent replay attack\\r\\n    nonce = packedTransaction.nonce + 1;\\r\\n\\r\\n    // If contract then use CALL otherwise do normal transfer\\r\\n    if (packedTransaction.target.code.length > 0) {\\r\\n      packedTransaction.target.functionCallWithValue(packedTransaction.data, packedTransaction.value);\\r\\n    } else {\\r\\n      payable(address(packedTransaction.target)).transfer(packedTransaction.value);\\r\\n    }\\r\\n    return true;\\r\\n  }\"}","{\"contract\": \"0x00da7a00a10161407df57ab3c82dc20849fb00cb\", \"contract_name\": \"GovernorUpgradeable\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x00da7a00a10161407df57ab3c82dc20849fb00cb\", \"contract_name\": \"GovernorUpgradeable\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x00da7a00a10161407df57ab3c82dc20849fb00cb\", \"contract_name\": \"GovernorCountingSimpleUpgradeable\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x00da7a00a10161407df57ab3c82dc20849fb00cb\", \"contract_name\": \"GovernorCountingSimpleUpgradeable\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x00da7a00a10161407df57ab3c82dc20849fb00cb\", \"contract_name\": \"GovernorSettingsUpgradeable\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x00da7a00a10161407df57ab3c82dc20849fb00cb\", \"contract_name\": \"GovernorSettingsUpgradeable\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x00da7a00a10161407df57ab3c82dc20849fb00cb\", \"contract_name\": \"GovernorTimelockControlUpgradeable\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x00da7a00a10161407df57ab3c82dc20849fb00cb\", \"contract_name\": \"GovernorTimelockControlUpgradeable\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x00da7a00a10161407df57ab3c82dc20849fb00cb\", \"contract_name\": \"GovernorVotesQuorumFractionUpgradeable\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x00da7a00a10161407df57ab3c82dc20849fb00cb\", \"contract_name\": \"GovernorVotesQuorumFractionUpgradeable\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x00da7a00a10161407df57ab3c82dc20849fb00cb\", \"contract_name\": \"GovernorVotesUpgradeable\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x00da7a00a10161407df57ab3c82dc20849fb00cb\", \"contract_name\": \"GovernorVotesUpgradeable\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x00da7a00a10161407df57ab3c82dc20849fb00cb\", \"contract_name\": \"ScryProtocolGovernor\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x00da7a00a10161407df57ab3c82dc20849fb00cb\", \"contract_name\": \"ScryProtocolGovernor\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0xe26d7f9409581f606242300fbfe63f56789f2169\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xe26d7f9409581f606242300fbfe63f56789f2169\", \"contract_name\": \"PendleMarketV3\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xe26d7f9409581f606242300fbfe63f56789f2169\", \"contract_name\": \"PendleERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x01ad4dde2f355476d9200264f5e3a95453697573\", \"contract_name\": \"SignatureService\", \"sol_function\": \"function recoverSigner(bytes32 _data, uint8 _v, bytes32 _r, bytes32 _s) internal pure returns (address) {\\n        // recover EIP712 signer using provided vrs\\n        address signer_ = ECDSA.recover(_data, _v, _r, _s);\\n\\n        // return signer\\n        return signer_;\\n    }\"}","{\"contract\": \"0xb185004c836695b9102eebf1779e5a46b89248fe\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xb185004c836695b9102eebf1779e5a46b89248fe\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xb185004c836695b9102eebf1779e5a46b89248fe\", \"contract_name\": \"OSKYToken\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x52c24cd7b513be216c302fe26eced0bb460fbccd\", \"contract_name\": \"Shiny_Media\", \"sol_function\": \"function _verify(bytes32 digest, bytes memory signature)\\r\\n        private\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return ECDSA.recover(digest, signature) == _adminAddress;\\r\\n    }\"}","{\"contract\": \"0xf2b1cb0bfa173be58da9954a91a2d4b025e14b1e\", \"contract_name\": \"D4AERC20\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xf2b1cb0bfa173be58da9954a91a2d4b025e14b1e\", \"contract_name\": \"ERC20PermitUpgradeable\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x54e3d84abdddd8354cb76d9dfc56ee9238f9bf81\", \"contract_name\": \"PNetworkHub\", \"sol_function\": \"function protocolCancelOperation(\\n        Operation calldata operation,\\n        ActorTypes actorType,\\n        bytes32[] calldata proof,\\n        bytes calldata signature\\n    ) external {\\n        if (!_isActorsStatusValid()) revert LockDown();\\n\\n        bytes32 operationId = operationIdOf(operation);\\n        address actor = ECDSA.recover(ECDSA.toEthSignedMessageHash(operationId), signature);\\n        if (!_isActor(actor, actorType, proof)) {\\n            revert InvalidActor(actor, actorType);\\n        }\\n\\n        uint16 currentEpoch = IEpochsManager(epochsManager).currentEpoch();\\n        if ((_epochsActorsStatusNew[currentEpoch][actor] & STATUS_INACTIVE) != 0) {\\n            revert Inactive();\\n        }\\n\\n        _protocolCancelOperation(operation, operationId, actor, actorType);\\n    }\"}","{\"contract\": \"0x54e3d84abdddd8354cb76d9dfc56ee9238f9bf81\", \"contract_name\": \"PNetworkHub\", \"sol_function\": \"function solveChallenge(\\n        Challenge calldata challenge,\\n        ActorTypes actorType,\\n        bytes32[] calldata proof,\\n        bytes calldata signature\\n    ) external {\\n        bytes32 challengeId = challengeIdOf(challenge);\\n        address actor = ECDSA.recover(ECDSA.toEthSignedMessageHash(challengeId), signature);\\n        if (actor != challenge.actor || !_isActor(actor, actorType, proof)) {\\n            revert InvalidActor(actor, actorType);\\n        }\\n\\n        _solveChallenge(challenge, challengeId);\\n    }\"}","{\"contract\": \"0x938d99a81814f66b01010d19ddce92a633441699\", \"contract_name\": \"FXB\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x938d99a81814f66b01010d19ddce92a633441699\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0xdcc77fd6ced6e6b547220226b3feacb11ca4954f\", \"contract_name\": \"ApeScoundrelSquad\", \"sol_function\": \"function _verifySignature(\\n        address _signer,\\n        bytes32 _hash,\\n        bytes memory _signature\\n    ) private pure returns (bool) {\\n        return\\n            _signer ==\\n            ECDSA.recover(ECDSA.toEthSignedMessageHash(_hash), _signature);\\n    }\"}","{\"contract\": \"0xa8f9309fb856139e2ad0c168cf875a665aa783a9\", \"contract_name\": \"MarvinautGamePass\", \"sol_function\": \"function wlMint(address _to, uint256 _mintAmount, bytes32 _hashedMessage, bytes memory _signature) external payable {\\n    require(wlActive(), 'WhitelistMintNotStarted');\\n    require(_hashedMessage.toEthSignedMessageHash().recover(_signature) == signer, 'InvalidSigner');\\n    require(block.timestamp < publicMintStart, 'WhitelistMintIsEnded');\\n    require(_mintAmount <= maxMintPerWallet, 'InvalidAmount');\\n\\n    _mintGamePass(_to, _mintAmount);\\n  }\"}","{\"contract\": \"0xa8f9309fb856139e2ad0c168cf875a665aa783a9\", \"contract_name\": \"MarvinautGamePass\", \"sol_function\": \"function upgradeGamePass(\\n    uint256[] calldata _tokens,\\n    uint8[] calldata _tiers,\\n    bytes32 _hashedMessage,\\n    bytes memory _signature\\n  ) public {\\n    require(_tokens.length == 3, 'Need3ItemsToUpgrade');\\n    require(_tokens.length == _tiers.length, 'InvalidData');\\n\\n    bytes32 msgHash = keccak256(abi.encodePacked(_tokens, _tiers));\\n    require(msgHash == _hashedMessage, 'InvalidSignature');\\n    require(_hashedMessage.toEthSignedMessageHash().recover(_signature) == signer, 'InvalidSigner');\\n\\n    uint8 tier = _tiers[0];\\n    require(tier < 2, 'NoNeedToUpgrade');\\n    for (uint256 i = 0; i < _tokens.length; i++) {\\n      require(_isApprovedOrOwner(_msgSender(), _tokens[i]), 'ERC721: caller is not token owner or approved');\\n      require(tier == _tiers[i], 'MustBeSameTier');\\n    }\\n\\n    if (tier == 0) {\\n      require(goldSlots > 0, 'GoldMaxReached');\\n    }\\n\\n    if (tier == 1) {\\n      require(diamondSlots > 0, 'DiamondMaxReached');\\n    }\\n\\n    _mint(_msgSender(), upgradedTokenId);\\n    tokenIdToTier[upgradedTokenId] = tier + 1;\\n    upgradedTokenId++;\\n\\n    if (tier == 0) {\\n      goldSlots--;\\n    }\\n\\n    if (tier == 1) {\\n      goldSlots += 3;\\n      diamondSlots--;\\n    }\\n\\n    for (uint256 i = 0; i < _tokens.length; i++) {\\n      _burn(_tokens[i]);\\n    }\\n\\n    emit Upgrade(msg.sender, _tokens, _tiers);\\n  }\"}","{\"contract\": \"0x4f1bcb051b641c79ff9ac6455510d37b35561ecb\", \"contract_name\": \"c0ntraband\", \"sol_function\": \"function _verify(string memory name, bytes memory signature) internal view returns (address) {\\r\\n        bytes32 digest = _hash(name);\\r\\n        return ECDSA.recover(digest, signature);\\r\\n    }\"}","{\"contract\": \"0x6d43e0af8c2b852dc37694694ef480937223f5c6\", \"contract_name\": \"ParaswapV5Swapper\", \"sol_function\": \"function _beforeParaswapV5Swapper(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        uint256 slippage,\\n        uint256 minAmountOut,\\n        uint256 expectedAmountOut,\\n        uint256 deadline,\\n        bytes memory data,\\n        bytes memory sig\\n    ) internal virtual {\\n        _beforeBaseSwapTask(tokenIn, amountIn, slippage);\\n        bool isBuy = false;\\n        bytes32 message = keccak256(\\n            abi.encodePacked(tokenIn, tokenOut, isBuy, amountIn, minAmountOut, expectedAmountOut, deadline, data)\\n        );\\n        address signer = ECDSA.recover(ECDSA.toEthSignedMessageHash(message), sig);\\n        if (signer != quoteSigner) revert TaskInvalidQuoteSigner(signer, quoteSigner);\\n        if (block.timestamp > deadline) revert TaskQuoteSignerPastDeadline(deadline, block.timestamp);\\n    }\"}","{\"contract\": \"0xf1ca8af8909e63fadfffe8c85a46aadc3eebab0d\", \"contract_name\": \"CatBricksClubhouse\", \"sol_function\": \"function matchAddressSigner(bytes32 hash, bytes memory signature) private view returns(bool) {\\n        return _signer == hash.recover(signature);\\n    }\"}","{\"contract\": \"0x93c51a96855daebaa7aaa260727b768ac4eacaed\", \"contract_name\": \"JBToken\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x93c51a96855daebaa7aaa260727b768ac4eacaed\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x15b2459cd237b4ae1ff30115ce00997a45d9c406\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {\\r\\n        // solhint-disable-next-line not-rely-on-time\\r\\n        require(block.timestamp <= deadline, \\\"ED\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(\\r\\n            abi.encode(\\r\\n                _PERMIT_TYPEHASH,\\r\\n                owner,\\r\\n                spender,\\r\\n                value,\\r\\n                _useNonce(owner),\\r\\n                deadline\\r\\n            )\\r\\n        );\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"IS\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x15b2459cd237b4ae1ff30115ce00997a45d9c406\", \"contract_name\": \"PopsicleV3Optimizer\", \"sol_function\": \"function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {\\r\\n        // solhint-disable-next-line not-rely-on-time\\r\\n        require(block.timestamp <= deadline, \\\"ED\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(\\r\\n            abi.encode(\\r\\n                _PERMIT_TYPEHASH,\\r\\n                owner,\\r\\n                spender,\\r\\n                value,\\r\\n                _useNonce(owner),\\r\\n                deadline\\r\\n            )\\r\\n        );\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"IS\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xdbd93af23d97563cb8fd2a0abe7f20a9086fa716\", \"contract_name\": \"Shifter\", \"sol_function\": \"function shiftIn(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes memory _sig) public returns (uint256) {\\n        \\n        bytes32 signedMessageHash = hashForSignature(_pHash, _amount, msg.sender, _nHash);\\n        require(status[signedMessageHash] == false, \\\"nonce hash already spent\\\");\\n        if (!verifySignature(signedMessageHash, _sig)) {\\n            \\n            \\n            \\n            revert(\\n                String.add4(\\n                    \\\"invalid signature - hash: \\\",\\n                    String.fromBytes32(signedMessageHash),\\n                    \\\", signer: \\\",\\n                    String.fromAddress(ECDSA.recover(signedMessageHash, _sig))\\n                )\\n            );\\n        }\\n        status[signedMessageHash] = true;\\n\\n        \\n        uint256 absoluteFee = (_amount.mul(fee)).div(BIPS_DENOMINATOR);\\n        uint256 receivedAmount = _amount.sub(absoluteFee);\\n        token.mint(msg.sender, receivedAmount);\\n        token.mint(feeRecipient, absoluteFee);\\n\\n        \\n        emit LogShiftIn(msg.sender, receivedAmount, nextShiftID);\\n        nextShiftID += 1;\\n\\n        return receivedAmount;\\n    }\"}","{\"contract\": \"0xdbd93af23d97563cb8fd2a0abe7f20a9086fa716\", \"contract_name\": \"Shifter\", \"sol_function\": \"function verifySignature(bytes32 _signedMessageHash, bytes memory _sig) public view returns (bool) {\\n        return mintAuthority == ECDSA.recover(_signedMessageHash, _sig);\\n    }\"}","{\"contract\": \"0xdbd93af23d97563cb8fd2a0abe7f20a9086fa716\", \"contract_name\": \"BTCShifter\", \"sol_function\": \"function shiftIn(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes memory _sig) public returns (uint256) {\\n        \\n        bytes32 signedMessageHash = hashForSignature(_pHash, _amount, msg.sender, _nHash);\\n        require(status[signedMessageHash] == false, \\\"nonce hash already spent\\\");\\n        if (!verifySignature(signedMessageHash, _sig)) {\\n            \\n            \\n            \\n            revert(\\n                String.add4(\\n                    \\\"invalid signature - hash: \\\",\\n                    String.fromBytes32(signedMessageHash),\\n                    \\\", signer: \\\",\\n                    String.fromAddress(ECDSA.recover(signedMessageHash, _sig))\\n                )\\n            );\\n        }\\n        status[signedMessageHash] = true;\\n\\n        \\n        uint256 absoluteFee = (_amount.mul(fee)).div(BIPS_DENOMINATOR);\\n        uint256 receivedAmount = _amount.sub(absoluteFee);\\n        token.mint(msg.sender, receivedAmount);\\n        token.mint(feeRecipient, absoluteFee);\\n\\n        \\n        emit LogShiftIn(msg.sender, receivedAmount, nextShiftID);\\n        nextShiftID += 1;\\n\\n        return receivedAmount;\\n    }\"}","{\"contract\": \"0xdbd93af23d97563cb8fd2a0abe7f20a9086fa716\", \"contract_name\": \"BTCShifter\", \"sol_function\": \"function verifySignature(bytes32 _signedMessageHash, bytes memory _sig) public view returns (bool) {\\n        return mintAuthority == ECDSA.recover(_signedMessageHash, _sig);\\n    }\"}","{\"contract\": \"0xdbd93af23d97563cb8fd2a0abe7f20a9086fa716\", \"contract_name\": \"ZECShifter\", \"sol_function\": \"function shiftIn(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes memory _sig) public returns (uint256) {\\n        \\n        bytes32 signedMessageHash = hashForSignature(_pHash, _amount, msg.sender, _nHash);\\n        require(status[signedMessageHash] == false, \\\"nonce hash already spent\\\");\\n        if (!verifySignature(signedMessageHash, _sig)) {\\n            \\n            \\n            \\n            revert(\\n                String.add4(\\n                    \\\"invalid signature - hash: \\\",\\n                    String.fromBytes32(signedMessageHash),\\n                    \\\", signer: \\\",\\n                    String.fromAddress(ECDSA.recover(signedMessageHash, _sig))\\n                )\\n            );\\n        }\\n        status[signedMessageHash] = true;\\n\\n        \\n        uint256 absoluteFee = (_amount.mul(fee)).div(BIPS_DENOMINATOR);\\n        uint256 receivedAmount = _amount.sub(absoluteFee);\\n        token.mint(msg.sender, receivedAmount);\\n        token.mint(feeRecipient, absoluteFee);\\n\\n        \\n        emit LogShiftIn(msg.sender, receivedAmount, nextShiftID);\\n        nextShiftID += 1;\\n\\n        return receivedAmount;\\n    }\"}","{\"contract\": \"0xdbd93af23d97563cb8fd2a0abe7f20a9086fa716\", \"contract_name\": \"ZECShifter\", \"sol_function\": \"function verifySignature(bytes32 _signedMessageHash, bytes memory _sig) public view returns (bool) {\\n        return mintAuthority == ECDSA.recover(_signedMessageHash, _sig);\\n    }\"}","{\"contract\": \"0x0dc55e87741bf7c62b4fb05479868b0751e5b80d\", \"contract_name\": \"FISHGAME\", \"sol_function\": \"function matchAddresSigner(bytes memory signature) private view returns(bool) {\\r\\n        bytes32 hash = keccak256(abi.encodePacked(\\r\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\r\\n                keccak256(abi.encodePacked(msg.sender, Sig_WORD)))\\r\\n        );\\r\\n        return _signerAddress == hash.recover(signature);\\r\\n    }\"}","{\"contract\": \"0xa12cbaf9106bc82c18367575614151371e1f25e7\", \"contract_name\": \"DeploymentManager\", \"sol_function\": \"function _verify(UpdateConfigRequest calldata request) internal view returns (address) {\\n        bytes32 digest = _hash(request);\\n        return ECDSA.recover(digest, request.signature);\\n    }\"}","{\"contract\": \"0x8393c3c92c97999011e4f57907e54b9dd706618f\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x8393c3c92c97999011e4f57907e54b9dd706618f\", \"contract_name\": \"AllStarCrypto\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0x4949ac21d5b2a0ccd303c20425eeb29dccba66d8\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x4949ac21d5b2a0ccd303c20425eeb29dccba66d8\", \"contract_name\": \"ERC20Votes\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x4949ac21d5b2a0ccd303c20425eeb29dccba66d8\", \"contract_name\": \"VotingEscrow\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x01e2287bb3e758f7b53e21bc6897c2886a185294\", \"contract_name\": \"LibAtomic\", \"sol_function\": \"function doRedeemAtomic(\\n        LibAtomic.RedeemOrder calldata order,\\n        bytes calldata secret,\\n        mapping(bytes32 => bool) storage secrets,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => MarginalFunctionality.Liability[]) storage liabilities\\n    ) public {\\n        require(!secrets[order.secretHash], \\\"E17R\\\");\\n        require(getEthSignedAtomicOrderHash(order).recover(order.signature) == order.sender, \\\"E2\\\");\\n        require(order.expiration/1000 >= block.timestamp, \\\"E4A\\\");\\n        require(order.secretHash == keccak256(secret), \\\"E17\\\");\\n\\n        LibExchange._updateBalance(order.sender, order.asset, -1*int(order.amount), assetBalances, liabilities);\\n\\n        LibExchange._updateBalance(order.receiver, order.asset, order.amount, assetBalances, liabilities);\\n        secrets[order.secretHash] = true;\\n    }\"}","{\"contract\": \"0x01e2287bb3e758f7b53e21bc6897c2886a185294\", \"contract_name\": \"LibAtomic\", \"sol_function\": \"function doClaimAtomic(\\n        address receiver,\\n        bytes calldata secret,\\n        bytes calldata matcherSignature,\\n        address allowedMatcher,\\n        mapping(bytes32 => LockInfo) storage atomicSwaps,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => MarginalFunctionality.Liability[]) storage liabilities\\n    ) public returns (LockInfo storage swap) {\\n        bytes32 secretHash = keccak256(secret);\\n        bytes32 coHash = getEthSignedClaimOrderHash(ClaimOrder(receiver, secretHash));\\n        require(coHash.recover(matcherSignature) == allowedMatcher, \\\"E2\\\");\\n\\n        swap = atomicSwaps[secretHash];\\n        require(swap.sender != address(0), \\\"E17NF\\\");\\n        //  require(swap.expiration/1000 >= block.timestamp, \\\"E17E\\\");\\n        require(!swap.used, \\\"E17U\\\");\\n\\n        swap.used = true;\\n        LibExchange._updateBalance(receiver, swap.asset, swap.amount, assetBalances, liabilities);\\n    }\"}","{\"contract\": \"0x01e2287bb3e758f7b53e21bc6897c2886a185294\", \"contract_name\": \"LibValidator\", \"sol_function\": \"function validateV3(Order memory order) public pure returns (bool) {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                getTypeValueHash(order)\\n            )\\n        );\\n\\n        return digest.recover(order.signature) == order.senderAddress;\\n    }\"}","{\"contract\": \"0x01e2287bb3e758f7b53e21bc6897c2886a185294\", \"contract_name\": \"LibValidator\", \"sol_function\": \"function validatePersonal(Order memory order) public pure returns (bool) {\\n\\n        bytes32 digest = getEthSignedOrderHash(order);\\n        return digest.recover(order.signature) == order.senderAddress;\\n    }\"}","{\"contract\": \"0x1411ec02894e3f0dc9ec6098f2f2d6b49e40c2f0\", \"contract_name\": \"BullaBulla\", \"sol_function\": \"function checkValidity(bytes calldata signature, string memory action)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        require(\\r\\n            ECDSA.recover(\\r\\n                ECDSA.toEthSignedMessageHash(\\r\\n                    keccak256(abi.encodePacked(msg.sender, action))\\r\\n                ),\\r\\n                signature\\r\\n            ) == signer,\\r\\n            \\\"invalid signature\\\"\\r\\n        );\\r\\n        return true;\\r\\n    }\"}","{\"contract\": \"0xd9b9b39a783d906c1794607b91600749ada46123\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xd9b9b39a783d906c1794607b91600749ada46123\", \"contract_name\": \"GPUMINERERC20Token\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xe9b634ea2781da7061c0c431f373d69ff16f894d\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xe9b634ea2781da7061c0c431f373d69ff16f894d\", \"contract_name\": \"CodoFinance\", \"sol_function\": \"function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\"}","{\"contract\": \"0xc45bdd7e82cd72f4cb138aeeb175599e6e12be17\", \"contract_name\": \"DistributeV1\", \"sol_function\": \"function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external {\\n        require(_earningsToDate > claimedAmount[_to], \\\"nothing to claim\\\");\\n        require(_nonce > lastUsedNonce[_to], \\\"nonce is too old\\\");\\n\\n        address signer = ECDSA.recover(hashForSignature(_to, _earningsToDate, _nonce), _signature);\\n        require(signer == accountManager, \\\"signer is not the account manager\\\");\\n\\n        lastUsedNonce[_to] = _nonce;\\n        uint256 claimableAmount = _earningsToDate.sub(claimedAmount[_to]);\\n        claimedAmount[_to] = _earningsToDate;\\n\\n        kprToken.transfer(_to, claimableAmount);\\n        emit Claimed(_to, claimableAmount);\\n    }\"}","{\"contract\": \"0xc45bdd7e82cd72f4cb138aeeb175599e6e12be17\", \"contract_name\": \"KeeperDistributor\", \"sol_function\": \"function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external {\\n        require(_earningsToDate > claimedAmount[_to], \\\"nothing to claim\\\");\\n        require(_nonce > lastUsedNonce[_to], \\\"nonce is too old\\\");\\n\\n        address signer = ECDSA.recover(hashForSignature(_to, _earningsToDate, _nonce), _signature);\\n        require(signer == accountManager, \\\"signer is not the account manager\\\");\\n\\n        lastUsedNonce[_to] = _nonce;\\n        uint256 claimableAmount = _earningsToDate.sub(claimedAmount[_to]);\\n        claimedAmount[_to] = _earningsToDate;\\n\\n        kprToken.transfer(_to, claimableAmount);\\n        emit Claimed(_to, claimableAmount);\\n    }\"}","{\"contract\": \"0xc45bdd7e82cd72f4cb138aeeb175599e6e12be17\", \"contract_name\": \"LPDistributor\", \"sol_function\": \"function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external {\\n        require(_earningsToDate > claimedAmount[_to], \\\"nothing to claim\\\");\\n        require(_nonce > lastUsedNonce[_to], \\\"nonce is too old\\\");\\n\\n        address signer = ECDSA.recover(hashForSignature(_to, _earningsToDate, _nonce), _signature);\\n        require(signer == accountManager, \\\"signer is not the account manager\\\");\\n\\n        lastUsedNonce[_to] = _nonce;\\n        uint256 claimableAmount = _earningsToDate.sub(claimedAmount[_to]);\\n        claimedAmount[_to] = _earningsToDate;\\n\\n        kprToken.transfer(_to, claimableAmount);\\n        emit Claimed(_to, claimableAmount);\\n    }\"}","{\"contract\": \"0xc45bdd7e82cd72f4cb138aeeb175599e6e12be17\", \"contract_name\": \"LPPreDistributor\", \"sol_function\": \"function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external {\\n        require(_earningsToDate > claimedAmount[_to], \\\"nothing to claim\\\");\\n        require(_nonce > lastUsedNonce[_to], \\\"nonce is too old\\\");\\n\\n        address signer = ECDSA.recover(hashForSignature(_to, _earningsToDate, _nonce), _signature);\\n        require(signer == accountManager, \\\"signer is not the account manager\\\");\\n\\n        lastUsedNonce[_to] = _nonce;\\n        uint256 claimableAmount = _earningsToDate.sub(claimedAmount[_to]);\\n        claimedAmount[_to] = _earningsToDate;\\n\\n        kprToken.transfer(_to, claimableAmount);\\n        emit Claimed(_to, claimableAmount);\\n    }\"}","{\"contract\": \"0xc45bdd7e82cd72f4cb138aeeb175599e6e12be17\", \"contract_name\": \"LPQ2Distributor\", \"sol_function\": \"function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external {\\n        require(_earningsToDate > claimedAmount[_to], \\\"nothing to claim\\\");\\n        require(_nonce > lastUsedNonce[_to], \\\"nonce is too old\\\");\\n\\n        address signer = ECDSA.recover(hashForSignature(_to, _earningsToDate, _nonce), _signature);\\n        require(signer == accountManager, \\\"signer is not the account manager\\\");\\n\\n        lastUsedNonce[_to] = _nonce;\\n        uint256 claimableAmount = _earningsToDate.sub(claimedAmount[_to]);\\n        claimedAmount[_to] = _earningsToDate;\\n\\n        kprToken.transfer(_to, claimableAmount);\\n        emit Claimed(_to, claimableAmount);\\n    }\"}","{\"contract\": \"0xc45bdd7e82cd72f4cb138aeeb175599e6e12be17\", \"contract_name\": \"HidingGameDistributor\", \"sol_function\": \"function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external {\\n        require(_earningsToDate > claimedAmount[_to], \\\"nothing to claim\\\");\\n        require(_nonce > lastUsedNonce[_to], \\\"nonce is too old\\\");\\n\\n        address signer = ECDSA.recover(hashForSignature(_to, _earningsToDate, _nonce), _signature);\\n        require(signer == accountManager, \\\"signer is not the account manager\\\");\\n\\n        lastUsedNonce[_to] = _nonce;\\n        uint256 claimableAmount = _earningsToDate.sub(claimedAmount[_to]);\\n        claimedAmount[_to] = _earningsToDate;\\n\\n        kprToken.transfer(_to, claimableAmount);\\n        emit Claimed(_to, claimableAmount);\\n    }\"}","{\"contract\": \"0xc45bdd7e82cd72f4cb138aeeb175599e6e12be17\", \"contract_name\": \"LPQ3Distributor\", \"sol_function\": \"function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external {\\n        require(_earningsToDate > claimedAmount[_to], \\\"nothing to claim\\\");\\n        require(_nonce > lastUsedNonce[_to], \\\"nonce is too old\\\");\\n\\n        address signer = ECDSA.recover(hashForSignature(_to, _earningsToDate, _nonce), _signature);\\n        require(signer == accountManager, \\\"signer is not the account manager\\\");\\n\\n        lastUsedNonce[_to] = _nonce;\\n        uint256 claimableAmount = _earningsToDate.sub(claimedAmount[_to]);\\n        claimedAmount[_to] = _earningsToDate;\\n\\n        kprToken.transfer(_to, claimableAmount);\\n        emit Claimed(_to, claimableAmount);\\n    }\"}","{\"contract\": \"0xc45bdd7e82cd72f4cb138aeeb175599e6e12be17\", \"contract_name\": \"HidingGame2Distributor\", \"sol_function\": \"function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external {\\n        require(_earningsToDate > claimedAmount[_to], \\\"nothing to claim\\\");\\n        require(_nonce > lastUsedNonce[_to], \\\"nonce is too old\\\");\\n\\n        address signer = ECDSA.recover(hashForSignature(_to, _earningsToDate, _nonce), _signature);\\n        require(signer == accountManager, \\\"signer is not the account manager\\\");\\n\\n        lastUsedNonce[_to] = _nonce;\\n        uint256 claimableAmount = _earningsToDate.sub(claimedAmount[_to]);\\n        claimedAmount[_to] = _earningsToDate;\\n\\n        kprToken.transfer(_to, claimableAmount);\\n        emit Claimed(_to, claimableAmount);\\n    }\"}","{\"contract\": \"0xc45bdd7e82cd72f4cb138aeeb175599e6e12be17\", \"contract_name\": \"HidingGame3Distributor\", \"sol_function\": \"function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external {\\n        require(_earningsToDate > claimedAmount[_to], \\\"nothing to claim\\\");\\n        require(_nonce > lastUsedNonce[_to], \\\"nonce is too old\\\");\\n\\n        address signer = ECDSA.recover(hashForSignature(_to, _earningsToDate, _nonce), _signature);\\n        require(signer == accountManager, \\\"signer is not the account manager\\\");\\n\\n        lastUsedNonce[_to] = _nonce;\\n        uint256 claimableAmount = _earningsToDate.sub(claimedAmount[_to]);\\n        claimedAmount[_to] = _earningsToDate;\\n\\n        kprToken.transfer(_to, claimableAmount);\\n        emit Claimed(_to, claimableAmount);\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"Governor\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"Governor\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"GovernorCompatibilityBravo\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"GovernorCompatibilityBravo\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"FraxGovernorAlpha\", \"sol_function\": \"function castVoteBySig(uint256 proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(_hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))), v, r, s);\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"FraxGovernorBase\", \"sol_function\": \"function castVoteBySig(uint256 proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(_hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))), v, r, s);\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"Governor\", \"sol_function\": \"function castVoteBySig(uint256 proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(_hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))), v, r, s);\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"Governor\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(uint256 proposalId, uint8 support, string calldata reason, bytes memory params, uint8 v, bytes32 r, bytes32 s) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(_hashTypedDataV4(keccak256(abi.encode(EXTENDED_BALLOT_TYPEHASH, proposalId, support, keccak256(bytes(reason)), keccak256(params)))), v, r, s);\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"GovernorCountingFractional\", \"sol_function\": \"function castVoteBySig(uint256 proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(_hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))), v, r, s);\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"GovernorCountingFractional\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        // Signature-based fractional voting requires `params` be two full words\\n        // in length:\\n        //   16 bytes for againstVotes.\\n        //   16 bytes for forVotes.\\n        //   16 bytes for abstainVotes.\\n        //   16 bytes for the signature nonce.\\n        // Signature-based nominal voting requires `params` be 0 bytes.\\n        require(\\n            params.length == 64 || params.length == 0,\\n            \\\"GovernorCountingFractional: invalid params for signature-based vote\\\"\\n        );\\n\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        // If params are zero-length all of the voter's weight will be cast so\\n        // we don't have to worry about checking/incrementing a nonce.\\n        if (params.length == 64) {\\n            // Get the nonce out of the params. It is the last half-word.\\n            uint128 nonce;\\n            assembly {\\n                nonce := and(\\n                    // Perform bitwise AND operation on the data in the second word of\\n                    // `params` with a mask of 128 zeros followed by 128 ones, i.e. take\\n                    // the last 128 bits of `params`.\\n                    _MASK_HALF_WORD_RIGHT,\\n                    // Load the data from memory at the returned address.\\n                    mload(\\n                        // Skip the first 64 bytes (0x40):\\n                        //   32 bytes encoding the length of the bytes array.\\n                        //   32 bytes for the first word in the params\\n                        // Return the memory address for the last word in params.\\n                        add(params, 0x40)\\n                    )\\n                )\\n            }\\n\\n            require(fractionalVoteNonce[voter] == nonce, \\\"GovernorCountingFractional: signature has already been used\\\");\\n\\n            fractionalVoteNonce[voter]++;\\n\\n            // Trim params in place to keep only the first 48 bytes (which are\\n            // the voting params) and save gas.\\n            assembly {\\n                mstore(params, 0x30)\\n            }\\n        }\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"GovernorPreventLateQuorum\", \"sol_function\": \"function castVoteBySig(uint256 proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(_hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))), v, r, s);\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"GovernorPreventLateQuorum\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(uint256 proposalId, uint8 support, string calldata reason, bytes memory params, uint8 v, bytes32 r, bytes32 s) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(_hashTypedDataV4(keccak256(abi.encode(EXTENDED_BALLOT_TYPEHASH, proposalId, support, keccak256(bytes(reason)), keccak256(params)))), v, r, s);\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"GovernorSettings\", \"sol_function\": \"function castVoteBySig(uint256 proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(_hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))), v, r, s);\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"GovernorSettings\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(uint256 proposalId, uint8 support, string calldata reason, bytes memory params, uint8 v, bytes32 r, bytes32 s) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(_hashTypedDataV4(keccak256(abi.encode(EXTENDED_BALLOT_TYPEHASH, proposalId, support, keccak256(bytes(reason)), keccak256(params)))), v, r, s);\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"GovernorTimelockControl\", \"sol_function\": \"function castVoteBySig(uint256 proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(_hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))), v, r, s);\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"GovernorTimelockControl\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(uint256 proposalId, uint8 support, string calldata reason, bytes memory params, uint8 v, bytes32 r, bytes32 s) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(_hashTypedDataV4(keccak256(abi.encode(EXTENDED_BALLOT_TYPEHASH, proposalId, support, keccak256(bytes(reason)), keccak256(params)))), v, r, s);\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"GovernorVotes\", \"sol_function\": \"function castVoteBySig(uint256 proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(_hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))), v, r, s);\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"GovernorVotes\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(uint256 proposalId, uint8 support, string calldata reason, bytes memory params, uint8 v, bytes32 r, bytes32 s) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(_hashTypedDataV4(keccak256(abi.encode(EXTENDED_BALLOT_TYPEHASH, proposalId, support, keccak256(bytes(reason)), keccak256(params)))), v, r, s);\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"GovernorVotesQuorumFraction\", \"sol_function\": \"function castVoteBySig(uint256 proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(_hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))), v, r, s);\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0xe8ab863e629a05c73d6a23b99d37027e3763156e\", \"contract_name\": \"GovernorVotesQuorumFraction\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(uint256 proposalId, uint8 support, string calldata reason, bytes memory params, uint8 v, bytes32 r, bytes32 s) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(_hashTypedDataV4(keccak256(abi.encode(EXTENDED_BALLOT_TYPEHASH, proposalId, support, keccak256(bytes(reason)), keccak256(params)))), v, r, s);\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x54e28e62ea9e8d755dc6e74674eabe2abfdb004e\", \"contract_name\": \"ERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x54e28e62ea9e8d755dc6e74674eabe2abfdb004e\", \"contract_name\": \"PendleMarket\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x54e28e62ea9e8d755dc6e74674eabe2abfdb004e\", \"contract_name\": \"PendleERC20Permit\", \"sol_function\": \"function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\"}","{\"contract\": \"0x5ee76b705c636ab5ea26e84af076b0a3daa6de99\", \"contract_name\": \"Governor\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x5ee76b705c636ab5ea26e84af076b0a3daa6de99\", \"contract_name\": \"Governor\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x5ee76b705c636ab5ea26e84af076b0a3daa6de99\", \"contract_name\": \"GovernorCountingSimple\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x5ee76b705c636ab5ea26e84af076b0a3daa6de99\", \"contract_name\": \"GovernorCountingSimple\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x5ee76b705c636ab5ea26e84af076b0a3daa6de99\", \"contract_name\": \"GovernorSettings\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x5ee76b705c636ab5ea26e84af076b0a3daa6de99\", \"contract_name\": \"GovernorSettings\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x5ee76b705c636ab5ea26e84af076b0a3daa6de99\", \"contract_name\": \"GovernorTimelockControl\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x5ee76b705c636ab5ea26e84af076b0a3daa6de99\", \"contract_name\": \"GovernorTimelockControl\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x5ee76b705c636ab5ea26e84af076b0a3daa6de99\", \"contract_name\": \"GovernorVotes\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x5ee76b705c636ab5ea26e84af076b0a3daa6de99\", \"contract_name\": \"GovernorVotes\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}","{\"contract\": \"0x5ee76b705c636ab5ea26e84af076b0a3daa6de99\", \"contract_name\": \"MetronomeGovernor\", \"sol_function\": \"function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\\n            v,\\n            r,\\n            s\\n        );\\n        return _castVote(proposalId, voter, support, \\\"\\\");\\n    }\"}","{\"contract\": \"0x5ee76b705c636ab5ea26e84af076b0a3daa6de99\", \"contract_name\": \"MetronomeGovernor\", \"sol_function\": \"function castVoteWithReasonAndParamsBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason,\\n        bytes memory params,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override returns (uint256) {\\n        address voter = ECDSA.recover(\\n            _hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        EXTENDED_BALLOT_TYPEHASH,\\n                        proposalId,\\n                        support,\\n                        keccak256(bytes(reason)),\\n                        keccak256(params)\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        return _castVote(proposalId, voter, support, reason, params);\\n    }\"}"]